(self.webpackChunk=self.webpackChunk||[]).push([[273],{273:module=>{eval("/**!\n * MixItUp v3.3.1\n * A high-performance, dependency-free library for animated filtering, sorting and more\n * Build 94e0fbf6-cd0b-4987-b3c0-14b59b67b8a0\n *\n * @copyright Copyright 2014-2018 KunkaLabs Limited.\n * @author    KunkaLabs Limited.\n * @link      https://www.kunkalabs.com/mixitup/\n *\n * @license   Commercial use requires a commercial license.\n *            https://www.kunkalabs.com/mixitup/licenses/\n *\n *            Non-commercial use permitted under same terms as CC BY-NC 3.0 license.\n *            http://creativecommons.org/licenses/by-nc/3.0/\n */\n\n(function(window) {\n    'use strict';\n\n    var mixitup = null,\n        h       = null;\n\n    (function() {\n        var VENDORS = ['webkit', 'moz', 'o', 'ms'],\n            canary  = window.document.createElement('div'),\n            i       = -1;\n\n        // window.requestAnimationFrame\n\n        for (i = 0; i < VENDORS.length && !window.requestAnimationFrame; i++) {\n            window.requestAnimationFrame = window[VENDORS[i] + 'RequestAnimationFrame'];\n        }\n\n        // Element.nextElementSibling\n\n        if (typeof canary.nextElementSibling === 'undefined') {\n            Object.defineProperty(window.Element.prototype, 'nextElementSibling', {\n                get: function() {\n                    var el = this.nextSibling;\n\n                    while (el) {\n                        if (el.nodeType === 1) {\n                            return el;\n                        }\n\n                        el = el.nextSibling;\n                    }\n\n                    return null;\n                }\n            });\n        }\n\n        // Element.matches\n\n        (function(ElementPrototype) {\n            ElementPrototype.matches =\n                ElementPrototype.matches ||\n                ElementPrototype.machesSelector ||\n                ElementPrototype.mozMatchesSelector ||\n                ElementPrototype.msMatchesSelector ||\n                ElementPrototype.oMatchesSelector ||\n                ElementPrototype.webkitMatchesSelector ||\n                function (selector) {\n                    return Array.prototype.indexOf.call(this.parentElement.querySelectorAll(selector), this) > -1;\n                };\n        })(window.Element.prototype);\n\n        // Object.keys\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\n        if (!Object.keys) {\n            Object.keys = (function() {\n                var hasOwnProperty      = Object.prototype.hasOwnProperty,\n                    hasDontEnumBug      = false,\n                    dontEnums           = [],\n                    dontEnumsLength     = -1;\n\n                hasDontEnumBug = !({\n                    toString: null\n                })\n                    .propertyIsEnumerable('toString');\n\n                dontEnums = [\n                    'toString',\n                    'toLocaleString',\n                    'valueOf',\n                    'hasOwnProperty',\n                    'isPrototypeOf',\n                    'propertyIsEnumerable',\n                    'constructor'\n                ];\n\n                dontEnumsLength = dontEnums.length;\n\n                return function(obj) {\n                    var result  = [],\n                        prop    = '',\n                        i       = -1;\n\n                    if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n                        throw new TypeError('Object.keys called on non-object');\n                    }\n\n                    for (prop in obj) {\n                        if (hasOwnProperty.call(obj, prop)) {\n                            result.push(prop);\n                        }\n                    }\n\n                    if (hasDontEnumBug) {\n                        for (i = 0; i < dontEnumsLength; i++) {\n                            if (hasOwnProperty.call(obj, dontEnums[i])) {\n                                result.push(dontEnums[i]);\n                            }\n                        }\n                    }\n\n                    return result;\n                };\n            }());\n        }\n\n        // Array.isArray\n        // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\n\n        if (!Array.isArray) {\n            Array.isArray = function(arg) {\n                return Object.prototype.toString.call(arg) === '[object Array]';\n            };\n        }\n\n        // Object.create\n        // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n\n        if (typeof Object.create !== 'function') {\n            Object.create = (function(undefined) {\n                var Temp = function() {};\n\n                return function (prototype, propertiesObject) {\n                    if (prototype !== Object(prototype) && prototype !== null) {\n                        throw TypeError('Argument must be an object, or null');\n                    }\n\n                    Temp.prototype = prototype || {};\n\n                    var result = new Temp();\n\n                    Temp.prototype = null;\n\n                    if (propertiesObject !== undefined) {\n                        Object.defineProperties(result, propertiesObject);\n                    }\n\n                    if (prototype === null) {\n                        /* jshint ignore:start */\n                        result.__proto__ = null;\n                        /* jshint ignore:end */\n                    }\n\n                    return result;\n                };\n            })();\n        }\n\n        // String.prototyoe.trim\n\n        if (!String.prototype.trim) {\n            String.prototype.trim = function() {\n                return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n            };\n        }\n\n        // Array.prototype.indexOf\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\n\n        if (!Array.prototype.indexOf) {\n            Array.prototype.indexOf = function(searchElement) {\n                var n, k, t, len;\n\n                if (this === null) {\n                    throw new TypeError();\n                }\n\n                t = Object(this);\n\n                len = t.length >>> 0;\n\n                if (len === 0) {\n                    return -1;\n                }\n\n                n = 0;\n\n                if (arguments.length > 1) {\n                    n = Number(arguments[1]);\n\n                    if (n !== n) {\n                        n = 0;\n                    } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n                        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n                    }\n                }\n\n                if (n >= len) {\n                    return -1;\n                }\n\n                for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0); k < len; k++) {\n                    if (k in t && t[k] === searchElement) {\n                        return k;\n                    }\n                }\n\n                return -1;\n            };\n        }\n\n        // Function.prototype.bind\n        // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\n\n        if (!Function.prototype.bind) {\n            Function.prototype.bind = function(oThis) {\n                var aArgs, self, FNOP, fBound;\n\n                if (typeof this !== 'function') {\n                    throw new TypeError();\n                }\n\n                aArgs = Array.prototype.slice.call(arguments, 1);\n\n                self = this;\n\n                FNOP = function() {};\n\n                fBound = function() {\n                    return self.apply(this instanceof FNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n                if (this.prototype) {\n                    FNOP.prototype = this.prototype;\n                }\n\n                fBound.prototype = new FNOP();\n\n                return fBound;\n            };\n        }\n\n        // Element.prototype.dispatchEvent\n\n        if (!window.Element.prototype.dispatchEvent) {\n            window.Element.prototype.dispatchEvent = function(event) {\n                try {\n                    return this.fireEvent('on' + event.type, event);\n                } catch (err) {}\n            };\n        }\n    })();\n\n    /**\n     * The `mixitup()` \"factory\" function creates and returns individual instances\n     * of MixItUp, known as \"mixers\", on which API methods can be called.\n     *\n     * When loading MixItUp via a script tag, the factory function is accessed\n     * via the global variable `mixitup`. When using a module loading\n     * system (e.g. ES2015, CommonJS, RequireJS), the factory function is\n     * exported into your module when you require the MixItUp library.\n     *\n     * @example\n     * mixitup(container [,config] [,foreignDoc])\n     *\n     * @example <caption>Example 1: Creating a mixer instance with an element reference</caption>\n     * var containerEl = document.querySelector('.container');\n     *\n     * var mixer = mixitup(containerEl);\n     *\n     * @example <caption>Example 2: Creating a mixer instance with a selector string</caption>\n     * var mixer = mixitup('.container');\n     *\n     * @example <caption>Example 3: Passing a configuration object</caption>\n     * var mixer = mixitup(containerEl, {\n     *     animation: {\n     *         effects: 'fade scale(0.5)'\n     *     }\n     * });\n     *\n     * @example <caption>Example 4: Passing an iframe reference</caption>\n     * var mixer = mixitup(containerEl, config, foreignDocument);\n     *\n     * @global\n     * @namespace\n     * @public\n     * @kind        function\n     * @since       3.0.0\n     * @param       {(Element|string)}  container\n     *      A DOM element or selector string representing the container(s) on which to instantiate MixItUp.\n     * @param       {object}            [config]\n     *      An optional \"configuration object\" used to customize the behavior of the MixItUp instance.\n     * @param       {object}            [foreignDoc]\n     *      An optional reference to a `document`, which can be used to control a MixItUp instance in an iframe.\n     * @return      {mixitup.Mixer}\n     *      A \"mixer\" object holding the MixItUp instance.\n     */\n\n    mixitup = function(container, config, foreignDoc) {\n        var el                  = null,\n            returnCollection    = false,\n            instance            = null,\n            facade              = null,\n            doc                 = null,\n            output              = null,\n            instances           = [],\n            id                  = '',\n            elements            = [],\n            i                   = -1;\n\n        doc = foreignDoc || window.document;\n\n        if (returnCollection = arguments[3]) {\n            // A non-documented 4th paramater enabling control of multiple instances\n\n            returnCollection = typeof returnCollection === 'boolean';\n        }\n\n        if (typeof container === 'string') {\n            elements = doc.querySelectorAll(container);\n        } else if (container && typeof container === 'object' && h.isElement(container, doc)) {\n            elements = [container];\n        } else if (container && typeof container === 'object' && container.length) {\n            // Although not documented, the container may also be an array-like list of\n            // elements such as a NodeList or jQuery collection, is returnCollection is true\n\n            elements = container;\n        } else {\n            throw new Error(mixitup.messages.errorFactoryInvalidContainer());\n        }\n\n        if (elements.length < 1) {\n            throw new Error(mixitup.messages.errorFactoryContainerNotFound());\n        }\n\n        for (i = 0; el = elements[i]; i++) {\n            if (i > 0 && !returnCollection) break;\n\n            if (!el.id) {\n                id = 'MixItUp' + h.randomHex();\n\n                el.id = id;\n            } else {\n                id = el.id;\n            }\n\n            if (mixitup.instances[id] instanceof mixitup.Mixer) {\n                instance = mixitup.instances[id];\n\n                if (!config || (config && config.debug && config.debug.showWarnings !== false)) {\n                    console.warn(mixitup.messages.warningFactoryPreexistingInstance());\n                }\n            } else {\n                instance = new mixitup.Mixer();\n\n                instance.attach(el, doc, id, config);\n\n                mixitup.instances[id] = instance;\n            }\n\n            facade = new mixitup.Facade(instance);\n\n            if (config && config.debug && config.debug.enable) {\n                instances.push(instance);\n            } else {\n                instances.push(facade);\n            }\n        }\n\n        if (returnCollection) {\n            output = new mixitup.Collection(instances);\n        } else {\n            // Return the first instance regardless\n\n            output = instances[0];\n        }\n\n        return output;\n    };\n\n    /**\n     * The `.use()` static method is used to extend the functionality of mixitup with compatible\n     * extensions and libraries in an environment with modular scoping e.g. ES2015, CommonJS, or RequireJS.\n     *\n     * You need only call the `.use()` function once per project, per extension, as module loaders\n     * will cache a single reference to MixItUp inclusive of all changes made.\n     *\n     * @example\n     * mixitup.use(extension)\n     *\n     * @example <caption>Example 1: Extending MixItUp with the Pagination Extension</caption>\n     *\n     * import mixitup from 'mixitup';\n     * import mixitupPagination from 'mixitup-pagination';\n     *\n     * mixitup.use(mixitupPagination);\n     *\n     * // All mixers created by the factory function in all modules will now\n     * // have pagination functionality\n     *\n     * var mixer = mixitup('.container');\n     *\n     * @public\n     * @name     use\n     * @memberof mixitup\n     * @kind     function\n     * @static\n     * @since    3.0.0\n     * @param    {*}  extension   A reference to the extension or library to be used.\n     * @return   {void}\n     */\n\n    mixitup.use = function(extension) {\n        mixitup.Base.prototype.callActions.call(mixitup, 'beforeUse', arguments);\n\n        // Call the extension's factory function, passing\n        // the mixitup factory as a paramater\n\n        if (typeof extension === 'function' && extension.TYPE === 'mixitup-extension') {\n            // Mixitup extension\n\n            if (typeof mixitup.extensions[extension.NAME] === 'undefined') {\n                extension(mixitup);\n\n                mixitup.extensions[extension.NAME] = extension;\n            }\n        } else if (extension.fn && extension.fn.jquery) {\n            // jQuery\n\n            mixitup.libraries.$ = extension;\n        }\n\n        mixitup.Base.prototype.callActions.call(mixitup, 'afterUse', arguments);\n    };\n\n    mixitup.instances   = {};\n    mixitup.extensions  = {};\n    mixitup.libraries   = {};\n\n    /**\n     * @private\n     */\n\n    h = {\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        cls\n         * @return  {boolean}\n         */\n\n        hasClass: function(el, cls) {\n            return !!el.className.match(new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)'));\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        cls\n         * @return  {void}\n         */\n\n        addClass: function(el, cls) {\n            if (!this.hasClass(el, cls)) el.className += el.className ? ' ' + cls : cls;\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        cls\n         * @return  {void}\n         */\n\n        removeClass: function(el, cls) {\n            if (this.hasClass(el, cls)) {\n                var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n                el.className = el.className.replace(reg, ' ').trim();\n            }\n        },\n\n        /**\n         * Merges the properties of the source object onto the\n         * target object. Alters the target object.\n         *\n         * @private\n         * @param   {object}    destination\n         * @param   {object}    source\n         * @param   {boolean}   [deep=false]\n         * @param   {boolean}   [handleErrors=false]\n         * @return  {void}\n         */\n\n        extend: function(destination, source, deep, handleErrors) {\n            var sourceKeys  = [],\n                key         = '',\n                i           = -1;\n\n            deep = deep || false;\n            handleErrors = handleErrors || false;\n\n            try {\n                if (Array.isArray(source)) {\n                    for (i = 0; i < source.length; i++) {\n                        sourceKeys.push(i);\n                    }\n                } else if (source) {\n                    sourceKeys = Object.keys(source);\n                }\n\n                for (i = 0; i < sourceKeys.length; i++) {\n                    key = sourceKeys[i];\n\n                    if (!deep || typeof source[key] !== 'object' || this.isElement(source[key])) {\n                        // All non-object properties, or all properties if shallow extend\n\n                        destination[key] = source[key];\n                    } else if (Array.isArray(source[key])) {\n                        // Arrays\n\n                        if (!destination[key]) {\n                            destination[key] = [];\n                        }\n\n                        this.extend(destination[key], source[key], deep, handleErrors);\n                    } else {\n                        // Objects\n\n                        if (!destination[key]) {\n                            destination[key] = {};\n                        }\n\n                        this.extend(destination[key], source[key], deep, handleErrors);\n                    }\n                }\n            } catch(err) {\n                if (handleErrors) {\n                    this.handleExtendError(err, destination);\n                } else {\n                    throw err;\n                }\n            }\n\n            return destination;\n        },\n\n        /**\n         * @private\n         * @param   {Error}  err\n         * @param   {object} destination\n         * @return  {void}\n         */\n\n        handleExtendError: function(err, destination) {\n            var re                  = /property \"?(\\w*)\"?[,:] object/i,\n                matches             = null,\n                erroneous           = '',\n                message             = '',\n                suggestion          = '',\n                probableMatch       = '',\n                key                 = '',\n                mostMatchingChars   = -1,\n                i                   = -1;\n\n            if (err instanceof TypeError && (matches = re.exec(err.message))) {\n                erroneous = matches[1];\n\n                for (key in destination) {\n                    i = 0;\n\n                    while (i < erroneous.length && erroneous.charAt(i) === key.charAt(i)) {\n                        i++;\n                    }\n\n                    if (i > mostMatchingChars) {\n                        mostMatchingChars = i;\n                        probableMatch = key;\n                    }\n                }\n\n                if (mostMatchingChars > 1) {\n                    suggestion = mixitup.messages.errorConfigInvalidPropertySuggestion({\n                        probableMatch: probableMatch\n                    });\n                }\n\n                message = mixitup.messages.errorConfigInvalidProperty({\n                    erroneous: erroneous,\n                    suggestion: suggestion\n                });\n\n                throw new TypeError(message);\n            }\n\n            throw err;\n        },\n\n        /**\n         * @private\n         * @param   {string} str\n         * @return  {function}\n         */\n\n        template: function(str) {\n            var re          = /\\${([\\w]*)}/g,\n                dynamics    = {},\n                matches     = null;\n\n            while ((matches = re.exec(str))) {\n                dynamics[matches[1]] = new RegExp('\\\\${' + matches[1] + '}', 'g');\n            }\n\n            return function(data) {\n                var key     = '',\n                    output  = str;\n\n                data = data || {};\n\n                for (key in dynamics) {\n                    output = output.replace(dynamics[key], typeof data[key] !== 'undefined' ? data[key] : '');\n                }\n\n                return output;\n            };\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        type\n         * @param   {function}      fn\n         * @param   {boolean}       useCapture\n         * @return  {void}\n         */\n\n        on: function(el, type, fn, useCapture) {\n            if (!el) return;\n\n            if (el.addEventListener) {\n                el.addEventListener(type, fn, useCapture);\n            } else if (el.attachEvent) {\n                el['e' + type + fn] = fn;\n\n                el[type + fn] = function() {\n                    el['e' + type + fn](window.event);\n                };\n\n                el.attachEvent('on' + type, el[type + fn]);\n            }\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        type\n         * @param   {function}      fn\n         * @return  {void}\n         */\n\n        off: function(el, type, fn) {\n            if (!el) return;\n\n            if (el.removeEventListener) {\n                el.removeEventListener(type, fn, false);\n            } else if (el.detachEvent) {\n                el.detachEvent('on' + type, el[type + fn]);\n                el[type + fn] = null;\n            }\n        },\n\n        /**\n         * @private\n         * @param   {string}      eventType\n         * @param   {object}      detail\n         * @param   {Document}    [doc]\n         * @return  {CustomEvent}\n         */\n\n        getCustomEvent: function(eventType, detail, doc) {\n            var event = null;\n\n            doc = doc || window.document;\n\n            if (typeof window.CustomEvent === 'function') {\n                event = new window.CustomEvent(eventType, {\n                    detail: detail,\n                    bubbles: true,\n                    cancelable: true\n                });\n            } else if (typeof doc.createEvent === 'function') {\n                event = doc.createEvent('CustomEvent');\n                event.initCustomEvent(eventType, true, true, detail);\n            } else {\n                event = doc.createEventObject(),\n                event.type = eventType;\n\n                event.returnValue = false;\n                event.cancelBubble = false;\n                event.detail = detail;\n            }\n\n            return event;\n        },\n\n        /**\n         * @private\n         * @param   {Event} e\n         * @return  {Event}\n         */\n\n        getOriginalEvent: function(e) {\n            if (e.touches && e.touches.length) {\n                return e.touches[0];\n            } else if (e.changedTouches && e.changedTouches.length) {\n                return e.changedTouches[0];\n            } else {\n                return e;\n            }\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        selector\n         * @return  {Number}\n         */\n\n        index: function(el, selector) {\n            var i = 0;\n\n            while ((el = el.previousElementSibling) !== null) {\n                if (!selector || el.matches(selector)) {\n                    ++i;\n                }\n            }\n\n            return i;\n        },\n\n        /**\n         * Converts a dash or snake-case string to camel case.\n         *\n         * @private\n         * @param   {string}    str\n         * @param   {boolean}   [isPascal]\n         * @return  {string}\n         */\n\n        camelCase: function(str) {\n            return str.toLowerCase().replace(/([_-][a-z])/g, function($1) {\n                return $1.toUpperCase().replace(/[_-]/, '');\n            });\n        },\n\n        /**\n         * Converts a dash or snake-case string to pascal case.\n         *\n         * @private\n         * @param   {string}    str\n         * @param   {boolean}   [isPascal]\n         * @return  {string}\n         */\n\n        pascalCase: function(str) {\n            return (str = this.camelCase(str)).charAt(0).toUpperCase() + str.slice(1);\n        },\n\n        /**\n         * Converts a camel or pascal-case string to dash case.\n         *\n         * @private\n         * @param   {string}    str\n         * @return  {string}\n         */\n\n        dashCase: function(str) {\n            return str.replace(/([A-Z])/g, '-$1').replace(/^-/, '').toLowerCase();\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}       el\n         * @param   {HTMLHtmlElement}   [doc]\n         * @return  {boolean}\n         */\n\n        isElement: function(el, doc) {\n            doc = doc || window.document;\n\n            if (\n                window.HTMLElement &&\n                el instanceof window.HTMLElement\n            ) {\n                return true;\n            } else if (\n                doc.defaultView &&\n                doc.defaultView.HTMLElement &&\n                el instanceof doc.defaultView.HTMLElement\n            ) {\n                return true;\n            } else {\n                return (\n                    el !== null &&\n                    el.nodeType === 1 &&\n                    typeof el.nodeName === 'string'\n                );\n            }\n        },\n\n        /**\n         * @private\n         * @param   {string}            htmlString\n         * @param   {HTMLHtmlElement}   [doc]\n         * @return  {DocumentFragment}\n         */\n\n        createElement: function(htmlString, doc) {\n            var frag = null,\n                temp = null;\n\n            doc = doc || window.document;\n\n            frag = doc.createDocumentFragment();\n            temp = doc.createElement('div');\n\n            temp.innerHTML = htmlString.trim();\n\n            while (temp.firstChild) {\n                frag.appendChild(temp.firstChild);\n            }\n\n            return frag;\n        },\n\n        /**\n         * @private\n         * @param   {Node} node\n         * @return  {void}\n         */\n\n        removeWhitespace: function(node) {\n            var deleting;\n\n            while (node && node.nodeName === '#text') {\n                deleting = node;\n\n                node = node.previousSibling;\n\n                deleting.parentElement && deleting.parentElement.removeChild(deleting);\n            }\n        },\n\n        /**\n         * @private\n         * @param   {Array<*>}  a\n         * @param   {Array<*>}  b\n         * @return  {boolean}\n         */\n\n        isEqualArray: function(a, b) {\n            var i = a.length;\n\n            if (i !== b.length) return false;\n\n            while (i--) {\n                if (a[i] !== b[i]) return false;\n            }\n\n            return true;\n        },\n\n        /**\n         * @private\n         * @param   {object}  a\n         * @param   {object}  b\n         * @return  {boolean}\n         */\n\n        deepEquals: function(a, b) {\n            var key;\n\n            if (typeof a === 'object' && a && typeof b === 'object' && b) {\n                if (Object.keys(a).length !== Object.keys(b).length) return false;\n\n                for (key in a) {\n                    if (!b.hasOwnProperty(key) || !this.deepEquals(a[key], b[key])) return false;\n                }\n            } else if (a !== b) {\n                return false;\n            }\n\n            return true;\n        },\n\n        /**\n         * @private\n         * @param   {Array<*>}  oldArray\n         * @return  {Array<*>}\n         */\n\n        arrayShuffle: function(oldArray) {\n            var newArray    = oldArray.slice(),\n                len         = newArray.length,\n                i           = len,\n                p           = -1,\n                t           = [];\n\n            while (i--) {\n                p = ~~(Math.random() * len);\n                t = newArray[i];\n\n                newArray[i] = newArray[p];\n                newArray[p] = t;\n            }\n\n            return newArray;\n        },\n\n        /**\n         * @private\n         * @param   {object}    list\n         */\n\n        arrayFromList: function(list) {\n            var output, i;\n\n            try {\n                return Array.prototype.slice.call(list);\n            } catch(err) {\n                output = [];\n\n                for (i = 0; i < list.length; i++) {\n                    output.push(list[i]);\n                }\n\n                return output;\n            }\n        },\n\n        /**\n         * @private\n         * @param   {function}  func\n         * @param   {Number}    wait\n         * @param   {boolean}   immediate\n         * @return  {function}\n         */\n\n        debounce: function(func, wait, immediate) {\n            var timeout;\n\n            return function() {\n                var self     = this,\n                    args     = arguments,\n                    callNow  = immediate && !timeout,\n                    later    = null;\n\n                later = function() {\n                    timeout  = null;\n\n                    if (!immediate) {\n                        func.apply(self, args);\n                    }\n                };\n\n                clearTimeout(timeout);\n\n                timeout = setTimeout(later, wait);\n\n                if (callNow) func.apply(self, args);\n            };\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   element\n         * @return  {object}\n         */\n\n        position: function(element) {\n            var xPosition       = 0,\n                yPosition       = 0,\n                offsetParent    = element;\n\n            while (element) {\n                xPosition -= element.scrollLeft;\n                yPosition -= element.scrollTop;\n\n                if (element === offsetParent) {\n                    xPosition += element.offsetLeft;\n                    yPosition += element.offsetTop;\n\n                    offsetParent = element.offsetParent;\n                }\n\n                element = element.parentElement;\n            }\n\n            return {\n                x: xPosition,\n                y: yPosition\n            };\n        },\n\n        /**\n         * @private\n         * @param   {object}    node1\n         * @param   {object}    node2\n         * @return  {Number}\n         */\n\n        getHypotenuse: function(node1, node2) {\n            var distanceX = node1.x - node2.x,\n                distanceY = node1.y - node2.y;\n\n            distanceX = distanceX < 0 ? distanceX * -1 : distanceX,\n            distanceY = distanceY < 0 ? distanceY * -1 : distanceY;\n\n            return Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));\n        },\n\n        /**\n         * Calcuates the area of intersection between two rectangles and expresses it as\n         * a ratio in comparison to the area of the first rectangle.\n         *\n         * @private\n         * @param   {Rect}  box1\n         * @param   {Rect}  box2\n         * @return  {number}\n         */\n\n        getIntersectionRatio: function(box1, box2) {\n            var controlArea         = box1.width * box1.height,\n                intersectionX       = -1,\n                intersectionY       = -1,\n                intersectionArea    = -1,\n                ratio               = -1;\n\n            intersectionX =\n                Math.max(0, Math.min(box1.left + box1.width, box2.left + box2.width) - Math.max(box1.left, box2.left));\n\n            intersectionY =\n                Math.max(0, Math.min(box1.top + box1.height, box2.top + box2.height) - Math.max(box1.top, box2.top));\n\n            intersectionArea = intersectionY * intersectionX;\n\n            ratio = intersectionArea / controlArea;\n\n            return ratio;\n        },\n\n        /**\n         * @private\n         * @param   {object}            el\n         * @param   {string}            selector\n         * @param   {boolean}           [includeSelf]\n         * @param   {HTMLHtmlElement}   [doc]\n         * @return  {Element|null}\n         */\n\n        closestParent: function(el, selector, includeSelf, doc) {\n            var parent  = el.parentNode;\n\n            doc = doc || window.document;\n\n            if (includeSelf && el.matches(selector)) {\n                return el;\n            }\n\n            while (parent && parent != doc.body) {\n                if (parent.matches && parent.matches(selector)) {\n                    return parent;\n                } else if (parent.parentNode) {\n                    parent = parent.parentNode;\n                } else {\n                    return null;\n                }\n            }\n\n            return null;\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}       el\n         * @param   {string}            selector\n         * @param   {HTMLHtmlElement}   [doc]\n         * @return  {NodeList}\n         */\n\n        children: function(el, selector, doc) {\n            var children    = [],\n                tempId      = '';\n\n            doc = doc || window.doc;\n\n            if (el) {\n                if (!el.id) {\n                    tempId = 'Temp' + this.randomHexKey();\n\n                    el.id = tempId;\n                }\n\n                children = doc.querySelectorAll('#' + el.id + ' > ' + selector);\n\n                if (tempId) {\n                    el.removeAttribute('id');\n                }\n            }\n\n            return children;\n        },\n\n        /**\n         * Creates a clone of a provided array, with any empty strings removed.\n         *\n         * @private\n         * @param   {Array<*>} originalArray\n         * @return  {Array<*>}\n         */\n\n        clean: function(originalArray) {\n            var cleanArray = [],\n                i = -1;\n\n            for (i = 0; i < originalArray.length; i++) {\n                if (originalArray[i] !== '') {\n                    cleanArray.push(originalArray[i]);\n                }\n            }\n\n            return cleanArray;\n        },\n\n        /**\n         * Abstracts an ES6 promise into a q-like deferred interface for storage and deferred resolution.\n         *\n         * @private\n         * @param  {object} libraries\n         * @return {h.Deferred}\n         */\n\n        defer: function(libraries) {\n            var deferred       = null,\n                promiseWrapper = null,\n                $              = null;\n\n            promiseWrapper = new this.Deferred();\n\n            if (mixitup.features.has.promises) {\n                // ES6 native promise or polyfill\n\n                promiseWrapper.promise = new Promise(function(resolve, reject) {\n                    promiseWrapper.resolve = resolve;\n                    promiseWrapper.reject  = reject;\n                });\n            } else if (($ = (window.jQuery || libraries.$)) && typeof $.Deferred === 'function') {\n                // jQuery\n\n                deferred = $.Deferred();\n\n                promiseWrapper.promise = deferred.promise();\n                promiseWrapper.resolve = deferred.resolve;\n                promiseWrapper.reject  = deferred.reject;\n            } else if (window.console) {\n                // No implementation\n\n                console.warn(mixitup.messages.warningNoPromiseImplementation());\n            }\n\n            return promiseWrapper;\n        },\n\n        /**\n         * @private\n         * @param   {Array<Promise>}    tasks\n         * @param   {object}            libraries\n         * @return  {Promise<Array>}\n         */\n\n        all: function(tasks, libraries) {\n            var $ = null;\n\n            if (mixitup.features.has.promises) {\n                return Promise.all(tasks);\n            } else if (($ = (window.jQuery || libraries.$)) && typeof $.when === 'function') {\n                return $.when.apply($, tasks)\n                    .done(function() {\n                        // jQuery when returns spread arguments rather than an array or resolutions\n\n                        return arguments;\n                    });\n            }\n\n            // No implementation\n\n            if (window.console) {\n                console.warn(mixitup.messages.warningNoPromiseImplementation());\n            }\n\n            return [];\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @param   {string}        property\n         * @param   {Array<string>} vendors\n         * @return  {string}\n         */\n\n        getPrefix: function(el, property, vendors) {\n            var i       = -1,\n                prefix  = '';\n\n            if (h.dashCase(property) in el.style) return '';\n\n            for (i = 0; prefix = vendors[i]; i++) {\n                if (prefix + property in el.style) {\n                    return prefix.toLowerCase();\n                }\n            }\n\n            return 'unsupported';\n        },\n\n        /**\n         * @private\n         * @return  {string}\n         */\n\n        randomHex: function() {\n            return ('00000' + (Math.random() * 16777216 << 0).toString(16)).substr(-6).toUpperCase();\n        },\n\n        /**\n         * @private\n         * @param   {HTMLDocument}  [doc]\n         * @return  {object}\n         */\n\n        getDocumentState: function(doc) {\n            doc = typeof doc.body === 'object' ? doc : window.document;\n\n            return {\n                scrollTop: window.pageYOffset,\n                scrollLeft: window.pageXOffset,\n                docHeight: doc.documentElement.scrollHeight,\n                docWidth: doc.documentElement.scrollWidth,\n                viewportHeight: doc.documentElement.clientHeight,\n                viewportWidth: doc.documentElement.clientWidth\n            };\n        },\n\n        /**\n         * @private\n         * @param   {object}    obj\n         * @param   {function}  fn\n         * @return  {function}\n         */\n\n        bind: function(obj, fn) {\n            return function() {\n                return fn.apply(obj, arguments);\n            };\n        },\n\n        /**\n         * @private\n         * @param   {HTMLElement}   el\n         * @return  {boolean}\n         */\n\n        isVisible: function(el) {\n            var styles = null;\n\n            if (el.offsetParent) return true;\n\n            styles = window.getComputedStyle(el);\n\n            if (\n                styles.position === 'fixed' &&\n                styles.visibility !== 'hidden' &&\n                styles.opacity !== '0'\n            ) {\n                // Fixed elements report no offsetParent,\n                // but may still be invisible\n\n                return true;\n            }\n\n            return false;\n        },\n\n        /**\n         * @private\n         * @param   {object}    obj\n         */\n\n        seal: function(obj) {\n            if (typeof Object.seal === 'function') {\n                Object.seal(obj);\n            }\n        },\n\n        /**\n         * @private\n         * @param   {object}    obj\n         */\n\n        freeze: function(obj) {\n            if (typeof Object.freeze === 'function') {\n                Object.freeze(obj);\n            }\n        },\n\n        /**\n         * @private\n         * @param   {string}    control\n         * @param   {string}    specimen\n         * @return  {boolean}\n         */\n\n        compareVersions: function(control, specimen) {\n            var controlParts    = control.split('.'),\n                specimenParts   = specimen.split('.'),\n                controlPart     = -1,\n                specimenPart    = -1,\n                i               = -1;\n\n            for (i = 0; i < controlParts.length; i++) {\n                controlPart     = parseInt(controlParts[i].replace(/[^\\d.]/g, ''));\n                specimenPart    = parseInt(specimenParts[i].replace(/[^\\d.]/g, '') || 0);\n\n                if (specimenPart < controlPart) {\n                    return false;\n                } else if (specimenPart > controlPart) {\n                    return true;\n                }\n            }\n\n            return true;\n        },\n\n        /**\n         * @private\n         * @constructor\n         */\n\n        Deferred: function() {\n            this.promise    = null;\n            this.resolve    = null;\n            this.reject     = null;\n            this.id         = h.randomHex();\n        },\n\n        /**\n         * @private\n         * @param   {object}  obj\n         * @return  {boolean}\n         */\n\n        isEmptyObject: function(obj) {\n            var key = '';\n\n            if (typeof Object.keys === 'function') {\n                return Object.keys(obj).length === 0;\n            }\n\n            for (key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        /**\n         * @param   {mixitup.Config.ClassNames}   classNames\n         * @param   {string}                      elementName\n         * @param   {string}                      [modifier]\n         * @return  {string}\n         */\n\n        getClassname: function(classNames, elementName, modifier) {\n            var classname = '';\n\n            classname += classNames.block;\n\n            if (classname.length) {\n                classname += classNames.delineatorElement;\n            }\n\n            classname += classNames['element' + this.pascalCase(elementName)];\n\n            if (!modifier) return classname;\n\n            if (classname.length) {\n                classname += classNames.delineatorModifier;\n            }\n\n            classname += modifier;\n\n            return classname;\n        },\n\n        /**\n         * Returns the value of a property on a given object via its string key.\n         *\n         * @param   {object}    obj\n         * @param   {string}    stringKey\n         * @return  {*} value\n         */\n\n        getProperty: function(obj, stringKey) {\n            var parts           = stringKey.split('.'),\n                returnCurrent   = null,\n                current         = '',\n                i               = 0;\n\n            if (!stringKey) {\n                return obj;\n            }\n\n            returnCurrent = function(obj) {\n                if (!obj) {\n                    return null;\n                } else {\n                    return obj[current];\n                }\n            };\n\n            while (i < parts.length) {\n                current = parts[i];\n\n                obj = returnCurrent(obj);\n\n                i++;\n            }\n\n            if (typeof obj !== 'undefined') {\n                return obj;\n            } else {\n                return null;\n            }\n        }\n    };\n\n    mixitup.h = h;\n\n    /**\n     * The Base class adds instance methods to all other extensible MixItUp classes,\n     * enabling the calling of any registered hooks.\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Base = function() {};\n\n    mixitup.Base.prototype = {\n        constructor: mixitup.Base,\n\n        /**\n         * Calls any registered hooks for the provided action.\n         *\n         * @memberof    mixitup.Base\n         * @private\n         * @instance\n         * @since       2.0.0\n         * @param       {string}    actionName\n         * @param       {Array<*>}  args\n         * @return      {void}\n         */\n\n        callActions: function(actionName, args) {\n            var self            = this,\n                hooks           = self.constructor.actions[actionName],\n                extensionName   = '';\n\n            if (!hooks || h.isEmptyObject(hooks)) return;\n\n            for (extensionName in hooks) {\n                hooks[extensionName].apply(self, args);\n            }\n        },\n\n        /**\n         * Calls any registered hooks for the provided filter.\n         *\n         * @memberof    mixitup.Base\n         * @private\n         * @instance\n         * @since       2.0.0\n         * @param       {string}    filterName\n         * @param       {*}         input\n         * @param       {Array<*>}  args\n         * @return      {*}\n         */\n\n        callFilters: function(filterName, input, args) {\n            var self            = this,\n                hooks           = self.constructor.filters[filterName],\n                output          = input,\n                extensionName   = '';\n\n            if (!hooks || h.isEmptyObject(hooks)) return output;\n\n            args = args || [];\n\n            for (extensionName in hooks) {\n                args = h.arrayFromList(args);\n\n                args.unshift(output);\n\n                output = hooks[extensionName].apply(self, args);\n            }\n\n            return output;\n        }\n    };\n\n    /**\n     * The BaseStatic class holds a set of static methods which are then added to all other\n     * extensible MixItUp classes as a means of integrating extensions via the addition of new\n     * methods and/or actions and hooks.\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.BaseStatic = function() {\n        this.actions = {};\n        this.filters = {};\n\n        /**\n         * Performs a shallow extend on the class's prototype, adding one or more new members to\n         * the class in a single operation.\n         *\n         * @memberof    mixitup.BaseStatic\n         * @public\n         * @static\n         * @since       2.1.0\n         * @param       {object} extension\n         * @return      {void}\n         */\n\n        this.extend = function(extension) {\n            h.extend(this.prototype, extension);\n        };\n\n        /**\n         * Registers a function to be called on the action hook of the provided name.\n         *\n         * @memberof    mixitup.BaseStatic\n         * @public\n         * @static\n         * @since       2.1.0\n         * @param       {string}    hookName\n         * @param       {string}    extensionName\n         * @param       {function}  func\n         * @return      {void}\n         */\n\n        this.registerAction = function(hookName, extensionName, func) {\n            (this.actions[hookName] = this.actions[hookName] || {})[extensionName] = func;\n        };\n\n        /**\n         * Registers a function to be called on the filter of the provided name.\n         *\n         * @memberof    mixitup.BaseStatic\n         * @public\n         * @static\n         * @since       2.1.0\n         * @param       {string}    hookName\n         * @param       {string}    extensionName\n         * @param       {function}  func\n         * @return      {void}\n         */\n\n        this.registerFilter = function(hookName, extensionName, func) {\n            (this.filters[hookName] = this.filters[hookName] || {})[extensionName] = func;\n        };\n    };\n\n    /**\n     * The `mixitup.Features` class performs all feature and CSS prefix detection\n     * neccessary for MixItUp to function correctly, as well as storing various\n     * string and array constants. All feature decection is on evaluation of the\n     * library and stored in a singleton instance for use by other internal classes.\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Features = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.boxSizingPrefix            = '';\n        this.transformPrefix            = '';\n        this.transitionPrefix           = '';\n\n        this.boxSizingPrefix            = '';\n        this.transformProp              = '';\n        this.transformRule              = '';\n        this.transitionProp             = '';\n        this.perspectiveProp            = '';\n        this.perspectiveOriginProp      = '';\n\n        this.has                        = new mixitup.Has();\n\n        this.canary                     = null;\n\n        this.BOX_SIZING_PROP            = 'boxSizing';\n        this.TRANSITION_PROP            = 'transition';\n        this.TRANSFORM_PROP             = 'transform';\n        this.PERSPECTIVE_PROP           = 'perspective';\n        this.PERSPECTIVE_ORIGIN_PROP    = 'perspectiveOrigin';\n        this.VENDORS                    = ['Webkit', 'moz', 'O', 'ms'];\n\n        this.TWEENABLE = [\n            'opacity',\n            'width', 'height',\n            'marginRight', 'marginBottom',\n            'x', 'y',\n            'scale',\n            'translateX', 'translateY', 'translateZ',\n            'rotateX', 'rotateY', 'rotateZ'\n        ];\n\n        this.callActions('afterConstruct');\n    };\n\n    mixitup.BaseStatic.call(mixitup.Features);\n\n    mixitup.Features.prototype = Object.create(mixitup.Base.prototype);\n\n    h.extend(mixitup.Features.prototype,\n    /** @lends mixitup.Features */\n    {\n        constructor: mixitup.Features,\n\n        /**\n         * @private\n         * @return  {void}\n         */\n\n        init: function() {\n            var self = this;\n\n            self.callActions('beforeInit', arguments);\n\n            self.canary = document.createElement('div');\n\n            self.setPrefixes();\n            self.runTests();\n\n            self.callActions('beforeInit', arguments);\n        },\n\n        /**\n         * @private\n         * @return  {void}\n         */\n\n        runTests: function() {\n            var self = this;\n\n            self.callActions('beforeRunTests', arguments);\n\n            self.has.promises       = typeof window.Promise === 'function';\n            self.has.transitions    = self.transitionPrefix !== 'unsupported';\n\n            self.callActions('afterRunTests', arguments);\n\n            h.freeze(self.has);\n        },\n\n        /**\n         * @private\n         * @return  {void}\n         */\n\n        setPrefixes: function() {\n            var self = this;\n\n            self.callActions('beforeSetPrefixes', arguments);\n\n            self.transitionPrefix   = h.getPrefix(self.canary, 'Transition', self.VENDORS);\n            self.transformPrefix    = h.getPrefix(self.canary, 'Transform', self.VENDORS);\n            self.boxSizingPrefix    = h.getPrefix(self.canary, 'BoxSizing', self.VENDORS);\n\n            self.boxSizingProp = self.boxSizingPrefix ?\n                self.boxSizingPrefix + h.pascalCase(self.BOX_SIZING_PROP) : self.BOX_SIZING_PROP;\n\n            self.transitionProp = self.transitionPrefix ?\n                self.transitionPrefix + h.pascalCase(self.TRANSITION_PROP) : self.TRANSITION_PROP;\n\n            self.transformProp = self.transformPrefix ?\n                self.transformPrefix + h.pascalCase(self.TRANSFORM_PROP) : self.TRANSFORM_PROP;\n\n            self.transformRule = self.transformPrefix ?\n                '-' + self.transformPrefix + '-' + self.TRANSFORM_PROP : self.TRANSFORM_PROP;\n\n            self.perspectiveProp = self.transformPrefix ?\n                self.transformPrefix + h.pascalCase(self.PERSPECTIVE_PROP) : self.PERSPECTIVE_PROP;\n\n            self.perspectiveOriginProp = self.transformPrefix ?\n                self.transformPrefix + h.pascalCase(self.PERSPECTIVE_ORIGIN_PROP) :\n                self.PERSPECTIVE_ORIGIN_PROP;\n\n            self.callActions('afterSetPrefixes', arguments);\n        }\n    });\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Has = function() {\n        this.transitions    = false;\n        this.promises       = false;\n\n        h.seal(this);\n    };\n\n    // Assign a singleton instance to `mixitup.features` and initialise:\n\n    mixitup.features = new mixitup.Features();\n\n    mixitup.features.init();\n\n    /**\n     * A group of properties defining the mixer's animation and effects settings.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        animation\n     * @namespace\n     * @public\n     * @since       2.0.0\n     */\n\n    mixitup.ConfigAnimation = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A boolean dictating whether or not animation should be enabled for the MixItUp instance.\n         * If `false`, all operations will occur instantly and syncronously, although callback\n         * functions and any returned promises will still be fulfilled.\n         *\n         * @example <caption>Example: Create a mixer with all animations disabled</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         enable: false\n         *     }\n         * });\n         *\n         * @name        enable\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.enable = true;\n\n        /**\n         * A string of one or more space-seperated properties to which transitions will be\n         * applied for all filtering animations.\n         *\n         * Properties can be listed any order or combination, although they will be applied in a specific\n         * predefined order to produce consistent results.\n         *\n         * To learn more about available effects, experiment with our <a href=\"https://www.kunkalabs.com/mixitup/\">\n         * sandbox demo</a> and try out the \"Export config\" button in the Animation options drop down.\n         *\n         * @example <caption>Example: Apply \"fade\" and \"translateZ\" effects to all animations</caption>\n         * // As targets are filtered in and out, they will fade between\n         * // opacity 1 and 0 and transform between translateZ(-100px) and\n         * // translateZ(0).\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effects: 'fade translateZ(-100px)'\n         *     }\n         * });\n         *\n         * @name        effects\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {string}\n         * @default     'fade scale'\n         */\n\n        this.effects = 'fade scale';\n\n        /**\n         * A string of one or more space-seperated effects to be applied only to filter-in\n         * animations, overriding `config.animation.effects` if set.\n         *\n         * @example <caption>Example: Apply downwards vertical translate to targets being filtered in</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effectsIn: 'fade translateY(-100%)'\n         *     }\n         * });\n         *\n         * @name        effectsIn\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {string}\n         * @default     ''\n         */\n\n        this.effectsIn = '';\n\n        /**\n         * A string of one or more space-seperated effects to be applied only to filter-out\n         * animations, overriding `config.animation.effects` if set.\n         *\n         * @example <caption>Example: Apply upwards vertical translate to targets being filtered out</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effectsOut: 'fade translateY(-100%)'\n         *     }\n         * });\n         *\n         * @name        effectsOut\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {string}\n         * @default     ''\n         */\n\n        this.effectsOut = '';\n\n        /**\n         * An integer dictating the duration of all MixItUp animations in milliseconds, not\n         * including any additional delay apllied via the `'stagger'` effect.\n         *\n         * @example <caption>Example: Apply an animation duration of 200ms to all mixitup animations</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         duration: 200\n         *     }\n         * });\n         *\n         * @name        duration\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {number}\n         * @default     600\n         */\n\n        this.duration = 600;\n\n        /**\n         * A valid CSS3 transition-timing function or shorthand. For a full list of accepted\n         * values, visit <a href=\"http://easings.net\" target=\"_blank\">easings.net</a>.\n         *\n         * @example <caption>Example 1: Apply \"ease-in-out\" easing to all animations</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         easing: 'ease-in-out'\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Apply a custom \"cubic-bezier\" easing function to all animations</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         easing: 'cubic-bezier(0.645, 0.045, 0.355, 1)'\n         *     }\n         * });\n         *\n         * @name        easing\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {string}\n         * @default     'ease'\n         */\n\n        this.easing = 'ease';\n\n        /**\n         * A boolean dictating whether or not to apply perspective to the MixItUp container\n         * during animations. By default, perspective is always applied and creates the\n         * illusion of three-dimensional space for effects such as `translateZ`, `rotateX`,\n         * and `rotateY`.\n         *\n         * You may wish to disable this and define your own perspective settings via CSS.\n         *\n         * @example <caption>Example: Prevent perspective from being applied to any 3D transforms</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         applyPerspective: false\n         *     }\n         * });\n         *\n         * @name        applyPerspective\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {bolean}\n         * @default     true\n         */\n\n        this.applyPerspective = true;\n\n        /**\n         * The perspective distance value to be applied to the container during animations,\n         * affecting any 3D-transform-based effects.\n         *\n         * @example <caption>Example: Set a perspective distance of 2000px</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effects: 'rotateY(-25deg)',\n         *         perspectiveDistance: '2000px'\n         *     }\n         * });\n         *\n         * @name        perspectiveDistance\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {string}\n         * @default     '3000px'\n         */\n\n        this.perspectiveDistance = '3000px';\n\n        /**\n         * The perspective-origin value to be applied to the container during animations,\n         * affecting any 3D-transform-based effects.\n         *\n         * @example <caption>Example: Set a perspective origin in the top-right of the container</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effects: 'transateZ(-200px)',\n         *         perspectiveOrigin: '100% 0'\n         *     }\n         * });\n         *\n         * @name        perspectiveOrigin\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {string}\n         * @default     '50% 50%'\n         */\n\n        this.perspectiveOrigin = '50% 50%';\n\n        /**\n         * A boolean dictating whether or not to enable the queuing of operations.\n         *\n         * If `true` (default), and a control is clicked or an API call is made while another\n         * operation is progress, the operation will go into the queue and will be automatically exectuted\n         * when the previous operaitons is finished.\n         *\n         * If `false`, any requested operations will be ignored, and the `onMixBusy` callback and `mixBusy`\n         * event will be fired. If `debug.showWarnings` is enabled, a console warning will also occur.\n         *\n         * @example <caption>Example: Disable queuing</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         queue: false\n         *     }\n         * });\n         *\n         * @name        queue\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.queue = true;\n\n        /**\n         * An integer dictacting the maximum number of operations allowed in the queue at\n         * any time, when queuing is enabled.\n         *\n         * @example <caption>Example: Allow a maximum of 5 operations in the queue at any time</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         queueLimit: 5\n         *     }\n         * });\n         *\n         * @name        queueLimit\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {number}\n         * @default     3\n         */\n\n        this.queueLimit = 3;\n\n        /**\n         * A boolean dictating whether or not to transition the height and width of the\n         * container as elements are filtered in and out. If disabled, the container height\n         * will change abruptly.\n         *\n         * It may be desirable to disable this on mobile devices as the CSS `height` and\n         * `width` properties do not receive GPU-acceleration and can therefore cause stuttering.\n         *\n         * @example <caption>Example 1: Disable the transitioning of the container height and/or width</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         animateResizeContainer: false\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Disable the transitioning of the container height and/or width for mobile devices only</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         animateResizeContainer: myFeatureTests.isMobile ? false : true\n         *     }\n         * });\n         *\n         * @name        animateResizeContainer\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.animateResizeContainer = true;\n\n        /**\n         * A boolean dictating whether or not to transition the height and width of target\n         * elements as they change throughout the course of an animation.\n         *\n         * This is often a must for flex-box grid layouts where the size of target elements may change\n         * depending on final their position in relation to their siblings, or for `.changeLayout()`\n         * operations where the size of targets change between layouts.\n         *\n         * NB: This feature requires additional calculations and manipulation to non-hardware-accelerated\n         * properties which may adversely affect performance on slower devices, and is therefore\n         * disabled by default.\n         *\n         * @example <caption>Example: Enable the transitioning of target widths and heights</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         animateResizeTargets: true\n         *     }\n         * });\n         *\n         * @name        animateResizeTargets\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.animateResizeTargets = false;\n\n        /**\n         * A custom function used to manipulate the order in which the stagger delay is\n         * incremented when using the ‘stagger’ effect.\n         *\n         * When using the 'stagger' effect, the delay applied to each target element is incremented\n         * based on its index. You may create a custom function to manipulate the order in which the\n         * delay is incremented and create engaging non-linear stagger effects.\n         *\n         * The function receives the index of the target element as a parameter, and must\n         * return an integer which serves as the multiplier for the stagger delay.\n         *\n         * @example <caption>Example 1: Stagger target elements by column in a 3-column grid</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effects: 'fade stagger(100ms)',\n         *         staggerSequence: function(i) {\n         *             return i % 3;\n         *         }\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Using an algorithm to produce a more complex sequence</caption>\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effects: 'fade stagger(100ms)',\n         *         staggerSequence: function(i) {\n         *             return (2*i) - (5*((i/3) - ((1/3) * (i%3))));\n         *         }\n         *     }\n         * });\n         *\n         * @name        staggerSequence\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {function}\n         * @default     null\n         */\n\n        this.staggerSequence = null;\n\n        /**\n         * A boolean dictating whether or not to reverse the direction of `translate`\n         * and `rotate` transforms for elements being filtered out.\n         *\n         * It can be used to create carousel-like animations where elements enter and exit\n         * from opposite directions. If enabled, the effect `translateX(-100%)` for elements\n         * being filtered in would become `translateX(100%)` for targets being filtered out.\n         *\n         * This functionality can also be achieved by providing seperate effects\n         * strings for `config.animation.effectsIn` and `config.animation.effectsOut`.\n         *\n         * @example <caption>Example: Reverse the desired direction on any translate/rotate effect for targets being filtered out</caption>\n         * // Elements being filtered in will be translated from '100%' to '0' while\n         * // elements being filtered out will be translated from 0 to '-100%'\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         effects: 'fade translateX(100%)',\n         *         reverseOut: true,\n         *         nudge: false // Disable nudging to create a carousel-like effect\n         *     }\n         * });\n         *\n         * @name        reverseOut\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.reverseOut = false;\n\n        /**\n         * A boolean dictating whether or not to \"nudge\" the animation path of targets\n         * when they are being filtered in and out simulatenously.\n         *\n         * This has been the default behavior of MixItUp since version 1, but it\n         * may be desirable to disable this effect when filtering directly from\n         * one exclusive set of targets to a different exclusive set of targets,\n         * to create a carousel-like effect, or a generally more subtle animation.\n         *\n         * @example <caption>Example: Disable the \"nudging\" of targets being filtered in and out simulatenously</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         nudge: false\n         *     }\n         * });\n         *\n         * @name        nudge\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.nudge = true;\n\n        /**\n         * A boolean dictating whether or not to clamp the height of the container while MixItUp's\n         * geometry tests are carried out before an operation.\n         *\n         * To prevent scroll-bar flicker, clamping is turned on by default. But in the case where the\n         * height of the container might affect its vertical positioning in the viewport\n         * (e.g. a vertically-centered container), this should be turned off to ensure accurate\n         * test results and a smooth animation.\n         *\n         * @example <caption>Example: Disable container height-clamping</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         clampHeight: false\n         *     }\n         * });\n         *\n         * @name        clampHeight\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.clampHeight = true;\n\n        /**\n         * A boolean dictating whether or not to clamp the width of the container while MixItUp's\n         * geometry tests are carried out before an operation.\n         *\n         * To prevent scroll-bar flicker, clamping is turned on by default. But in the case where the\n         * width of the container might affect its horitzontal positioning in the viewport\n         * (e.g. a horizontall-centered container), this should be turned off to ensure accurate\n         * test results and a smooth animation.\n         *\n         * @example <caption>Example: Disable container width-clamping</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     animation: {\n         *         clampWidth: false\n         *     }\n         * });\n         *\n         * @name        clampWidth\n         * @memberof    mixitup.Config.animation\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.clampWidth = true;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigAnimation);\n\n    mixitup.ConfigAnimation.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigAnimation.prototype.constructor = mixitup.ConfigAnimation;\n\n    /**\n     * A group of properties relating to the behavior of the Mixer.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        behavior\n     * @namespace\n     * @public\n     * @since       3.1.12\n     */\n\n    mixitup.ConfigBehavior = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A boolean dictating whether to allow \"live\" sorting of the mixer.\n         *\n         * Because of the expensive nature of sorting, MixItUp makes use of several\n         * internal optimizations to skip redundant sorting operations, such as when\n         * the newly requested sort command is the same as the active one. The caveat\n         * to this optimization is that \"live\" edits to the value of a target's sorting\n         * attribute will be ignored when requesting a re-sort by the same attribute.\n         *\n         * By setting to `behavior.liveSort` to `true`, the mixer will always re-sort\n         * regardless of whether or not the sorting attribute and order have changed.\n         *\n         * @example <caption>Example: Enabling `liveSort` to allow for re-sorting</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     behavior: {\n         *         liveSort: true\n         *     },\n         *     load: {\n         *         sort: 'edited:desc'\n         *     }\n         * });\n         *\n         * var target = containerEl.children[3];\n         *\n         * console.log(target.getAttribute('data-edited')); // '2015-04-24'\n         *\n         * target.setAttribute('data-edited', '2017-08-10'); // Update the target's edited date\n         *\n         * mixer.sort('edited:desc')\n         *     .then(function(state) {\n         *         // The target is now at the top of the list\n         *\n         *         console.log(state.targets[0] === target); // true\n         *     });\n         *\n         * @name        liveSort\n         * @memberof    mixitup.Config.behavior\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.liveSort = false;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigBehavior);\n\n    mixitup.ConfigBehavior.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigBehavior.prototype.constructor = mixitup.ConfigBehavior;\n\n    /**\n     * A group of optional callback functions to be invoked at various\n     * points within the lifecycle of a mixer operation.\n     *\n     * Each function is analogous to an event of the same name triggered from the\n     * container element, and is invoked immediately after it.\n     *\n     * All callback functions receive the current `state` object as their first\n     * argument, as well as other more specific arguments described below.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        callbacks\n     * @namespace\n     * @public\n     * @since       2.0.0\n     */\n\n    mixitup.ConfigCallbacks = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A callback function invoked immediately after any MixItUp operation is requested\n         * and before animations have begun.\n         *\n         * A second `futureState` argument is passed to the function which represents the final\n         * state of the mixer once the requested operation has completed.\n         *\n         * @example <caption>Example: Adding an `onMixStart` callback function</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixStart: function(state, futureState) {\n         *              console.log('Starting operation...');\n         *         }\n         *     }\n         * });\n         *\n         * @name        onMixStart\n         * @memberof    mixitup.Config.callbacks\n         * @instance\n         * @type        {function}\n         * @default     null\n         */\n\n        this.onMixStart = null;\n\n        /**\n         * A callback function invoked when a MixItUp operation is requested while another\n         * operation is in progress, and the animation queue is full, or queueing\n         * is disabled.\n         *\n         * @example <caption>Example: Adding an `onMixBusy` callback function</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixBusy: function(state) {\n         *              console.log('Mixer busy');\n         *         }\n         *     }\n         * });\n         *\n         * @name        onMixBusy\n         * @memberof    mixitup.Config.callbacks\n         * @instance\n         * @type        {function}\n         * @default     null\n         */\n\n        this.onMixBusy  = null;\n\n        /**\n         * A callback function invoked after any MixItUp operation has completed, and the\n         * state has been updated.\n         *\n         * @example <caption>Example: Adding an `onMixEnd` callback function</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixEnd: function(state) {\n         *              console.log('Operation complete');\n         *         }\n         *     }\n         * });\n         *\n         * @name        onMixEnd\n         * @memberof    mixitup.Config.callbacks\n         * @instance\n         * @type        {function}\n         * @default     null\n         */\n\n        this.onMixEnd   = null;\n\n        /**\n         * A callback function invoked whenever an operation \"fails\", i.e. no targets\n         * could be found matching the requested filter.\n         *\n         * @example <caption>Example: Adding an `onMixFail` callback function</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixFail: function(state) {\n         *              console.log('No items could be found matching the requested filter');\n         *         }\n         *     }\n         * });\n         *\n         * @name        onMixFail\n         * @memberof    mixitup.Config.callbacks\n         * @instance\n         * @type        {function}\n         * @default     null\n         */\n\n        this.onMixFail  = null;\n\n        /**\n         * A callback function invoked whenever a MixItUp control is clicked, and before its\n         * respective operation is requested.\n         *\n         * The clicked element is assigned to the `this` keyword within the function. The original\n         * click event is passed to the function as the second argument, which can be useful if\n         * using `<a>` tags as controls where the default behavior needs to be prevented.\n         *\n         * Returning `false` from the callback will prevent the control click from triggering\n         * an operation.\n         *\n         * @example <caption>Example 1: Adding an `onMixClick` callback function</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixClick: function(state, originalEvent) {\n         *              console.log('The control \"' + this.innerText + '\" was clicked');\n         *         }\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Using `onMixClick` to manipulate the original click event</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixClick: function(state, originalEvent) {\n         *              // Prevent original click event from bubbling up:\n         *              originalEvent.stopPropagation();\n         *\n         *              // Prevent default behavior of clicked element:\n         *              originalEvent.preventDefault();\n         *         }\n         *     }\n         * });\n         *\n         * @example <caption>Example 3: Using `onMixClick` to conditionally cancel operations</caption>\n         * var mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixClick: function(state, originalEvent) {\n         *              // Perform some conditional check:\n         *\n         *              if (myApp.isLoading) {\n         *                  // By returning false, we can prevent the control click from triggering an operation.\n         *\n         *                  return false;\n         *              }\n         *         }\n         *     }\n         * });\n         *\n         * @name        onMixClick\n         * @memberof    mixitup.Config.callbacks\n         * @instance\n         * @type        {function}\n         * @default     null\n         */\n\n        this.onMixClick = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigCallbacks);\n\n    mixitup.ConfigCallbacks.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigCallbacks.prototype.constructor = mixitup.ConfigCallbacks;\n\n    /**\n     * A group of properties relating to clickable control elements.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        controls\n     * @namespace\n     * @public\n     * @since       2.0.0\n     */\n\n    mixitup.ConfigControls = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A boolean dictating whether or not controls should be enabled for the mixer instance.\n         *\n         * If `true` (default behavior), MixItUp will search the DOM for any clickable elements with\n         * `data-filter`, `data-sort` or `data-toggle` attributes, and bind them for click events.\n         *\n         * If `false`, no click handlers will be bound, and all functionality must therefore be performed\n         * via the mixer's API methods.\n         *\n         * If you do not intend to use the default controls, setting this property to `false` will\n         * marginally improve the startup time of your mixer instance, and will also prevent any other active\n         * mixer instances in the DOM which are bound to controls from controlling the instance.\n         *\n         * @example <caption>Example: Disabling controls</caption>\n         * var mixer = mixitup(containerEl, {\n         *     controls: {\n         *         enable: false\n         *     }\n         * });\n         *\n         * // With the default controls disabled, we can only control\n         * // the mixer via its API methods, e.g.:\n         *\n         * mixer.filter('.cat-1');\n         *\n         * @name        enable\n         * @memberof    mixitup.Config.controls\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.enable = true;\n\n        /**\n         * A boolean dictating whether or not to use event delegation when binding click events\n         * to the default controls.\n         *\n         * If `false` (default behavior), each control button in the DOM will be found and\n         * individually bound when a mixer is instantiated, with their corresponding actions\n         * cached for performance.\n         *\n         * If `true`, a single click handler will be applied to the `window` (or container element - see\n         * `config.controls.scope`), and any click events triggered by elements with `data-filter`,\n         * `data-sort` or `data-toggle` attributes present will be handled as they propagate upwards.\n         *\n         * If you require a user interface where control buttons may be added, removed, or changed during the\n         * lifetime of a mixer, `controls.live` should be set to `true`. There is a marginal but unavoidable\n         * performance deficit when using live controls, as the value of each control button must be read\n         * from the DOM in real time once the click event has propagated.\n         *\n         * @example <caption>Example: Setting live controls</caption>\n         * var mixer = mixitup(containerEl, {\n         *     controls: {\n         *         live: true\n         *     }\n         * });\n         *\n         * // Control buttons can now be added, remove and changed without breaking\n         * // the mixer's UI\n         *\n         * @name        live\n         * @memberof    mixitup.Config.controls\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.live = false;\n\n        /**\n         * A string dictating the \"scope\" to use when binding or querying the default controls. The available\n         * values are `'global'` or `'local'`.\n         *\n         * When set to `'global'` (default behavior), MixItUp will query the entire document for control buttons\n         * to bind, or delegate click events from (see `config.controls.live`).\n         *\n         * When set to `'local'`, MixItUp will only query (or bind click events to) its own container element.\n         * This may be desireable if you require multiple active mixer instances within the same document, with\n         * controls that would otherwise intefere with each other if scoped globally.\n         *\n         * Conversely, if you wish to control multiple instances with a single UI, you would create one\n         * set of controls and keep the controls scope of each mixer set to `global`.\n         *\n         * @example <caption>Example: Setting 'local' scoped controls</caption>\n         * var mixerOne = mixitup(containerOne, {\n         *     controls: {\n         *         scope: 'local'\n         *     }\n         * });\n         *\n         * var mixerTwo = mixitup(containerTwo, {\n         *     controls: {\n         *         scope: 'local'\n         *     }\n         * });\n         *\n         * // Both mixers can now exist within the same document with\n         * // isolated controls placed within their container elements.\n         *\n         * @name        scope\n         * @memberof    mixitup.Config.controls\n         * @instance\n         * @type        {string}\n         * @default     'global'\n         */\n\n        this.scope = 'global'; // enum: ['local' ,'global']\n\n        /**\n         * A string dictating the type of logic to apply when concatenating the filter selectors of\n         * active toggle buttons (i.e. any clickable element with a `data-toggle` attribute).\n         *\n         * If set to `'or'` (default behavior), selectors will be concatenated together as\n         * a comma-seperated list. For example:\n         *\n         * `'.cat-1, .cat-2'` (shows any elements matching `'.cat-1'` OR `'.cat-2'`)\n         *\n         * If set to `'and'`, selectors will be directly concatenated together. For example:\n         *\n         * `'.cat-1.cat-2'` (shows any elements which match both `'.cat-1'` AND `'.cat-2'`)\n         *\n         * @example <caption>Example: Setting \"and\" toggle logic</caption>\n         * var mixer = mixitup(containerEl, {\n         *     controls: {\n         *         toggleLogic: 'and'\n         *     }\n         * });\n         *\n         * @name        toggleLogic\n         * @memberof    mixitup.Config.controls\n         * @instance\n         * @type        {string}\n         * @default     'or'\n         */\n\n        this.toggleLogic = 'or'; // enum: ['or', 'and']\n\n        /**\n         * A string dictating the filter behavior when all toggles are inactive.\n         *\n         * When set to `'all'` (default behavior), *all* targets will be shown by default\n         * when no toggles are active, or at the moment all active toggles are toggled off.\n         *\n         * When set to `'none'`, no targets will be shown by default when no toggles are\n         * active, or at the moment all active toggles are toggled off.\n         *\n         * @example <caption>Example 1: Setting the default toggle behavior to `'all'`</caption>\n         * var mixer = mixitup(containerEl, {\n         *     controls: {\n         *         toggleDefault: 'all'\n         *     }\n         * });\n         *\n         * mixer.toggleOn('.cat-2')\n         *     .then(function() {\n         *         // Deactivate all active toggles\n         *\n         *         return mixer.toggleOff('.cat-2')\n         *     })\n         *     .then(function(state) {\n         *          console.log(state.activeFilter.selector); // 'all'\n         *          console.log(state.totalShow); // 12\n         *     });\n         *\n         * @example <caption>Example 2: Setting the default toggle behavior to `'none'`</caption>\n         * var mixer = mixitup(containerEl, {\n         *     controls: {\n         *         toggleDefault: 'none'\n         *     }\n         * });\n         *\n         * mixer.toggleOn('.cat-2')\n         *     .then(function() {\n         *         // Deactivate all active toggles\n         *\n         *         return mixer.toggleOff('.cat-2')\n         *     })\n         *     .then(function(state) {\n         *          console.log(state.activeFilter.selector); // 'none'\n         *          console.log(state.totalShow); // 0\n         *     });\n         *\n         * @name        toggleDefault\n         * @memberof    mixitup.Config.controls\n         * @instance\n         * @type        {string}\n         * @default     'all'\n         */\n\n        this.toggleDefault = 'all'; // enum: ['all', 'none']\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigControls);\n\n    mixitup.ConfigControls.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigControls.prototype.constructor = mixitup.ConfigControls;\n\n    /**\n     * A group of properties defining the output and structure of class names programmatically\n     * added to controls and containers to reflect the state of the mixer.\n     *\n     * Most commonly, class names are added to controls by MixItUp to indicate that\n     * the control is active so that it can be styled accordingly - `'mixitup-control-active'` by default.\n     *\n     * Using a \"BEM\" like structure, each classname is broken into the three parts:\n     * a block namespace (`'mixitup'`), an element name (e.g. `'control'`), and an optional modifier\n     * name (e.g. `'active'`) reflecting the state of the element.\n     *\n     * By default, each part of the classname is concatenated together using single hyphens as\n     * delineators, but this can be easily customised to match the naming convention and style of\n     * your project.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        classNames\n     * @namespace\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigClassNames = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * The \"block\" portion, or top-level namespace added to the start of any class names created by MixItUp.\n         *\n         * @example <caption>Example 1: changing the `config.classNames.block` value</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         block: 'portfolio'\n         *     }\n         * });\n         *\n         * // Active control output: \"portfolio-control-active\"\n         *\n         * @example <caption>Example 2: Removing `config.classNames.block`</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         block: ''\n         *     }\n         * });\n         *\n         * // Active control output: \"control-active\"\n         *\n         * @name        block\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'mixitup'\n         */\n\n        this.block = 'mixitup';\n\n        /**\n         * The \"element\" portion of the class name added to container.\n         *\n         * @name        elementContainer\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'container'\n         */\n\n        this.elementContainer = 'container';\n\n        /**\n         * The \"element\" portion of the class name added to filter controls.\n         *\n         * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but\n         * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.\n         *\n         * @example <caption>Example 1: changing the `config.classNames.elementFilter` value</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         elementFilter: 'filter'\n         *     }\n         * });\n         *\n         * // Active filter output: \"mixitup-filter-active\"\n         *\n         * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementFilter` values</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         block: 'portfolio',\n         *         elementFilter: 'filter'\n         *     }\n         * });\n         *\n         * // Active filter output: \"portfolio-filter-active\"\n         *\n         * @name        elementFilter\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'control'\n         */\n\n        this.elementFilter = 'control';\n\n        /**\n         * The \"element\" portion of the class name added to sort controls.\n         *\n         * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but\n         * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.\n         *\n         * @example <caption>Example 1: changing the `config.classNames.elementSort` value</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         elementSort: 'sort'\n         *     }\n         * });\n         *\n         * // Active sort output: \"mixitup-sort-active\"\n         *\n         * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementSort` values</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         block: 'portfolio',\n         *         elementSort: 'sort'\n         *     }\n         * });\n         *\n         * // Active sort output: \"portfolio-sort-active\"\n         *\n         * @name        elementSort\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'control'\n         */\n\n        this.elementSort = 'control';\n\n        /**\n         * The \"element\" portion of the class name added to multimix controls.\n         *\n         * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but\n         * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.\n         *\n         * @example <caption>Example 1: changing the `config.classNames.elementMultimix` value</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         elementMultimix: 'multimix'\n         *     }\n         * });\n         *\n         * // Active multimix output: \"mixitup-multimix-active\"\n         *\n         * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementMultimix` values</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         block: 'portfolio',\n         *         elementSort: 'multimix'\n         *     }\n         * });\n         *\n         * // Active multimix output: \"portfolio-multimix-active\"\n         *\n         * @name        elementMultimix\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'control'\n         */\n\n        this.elementMultimix = 'control';\n\n        /**\n         * The \"element\" portion of the class name added to toggle controls.\n         *\n         * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but\n         * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.\n         *\n         * @example <caption>Example 1: changing the `config.classNames.elementToggle` value</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         elementToggle: 'toggle'\n         *     }\n         * });\n         *\n         * // Active toggle output: \"mixitup-toggle-active\"\n         *\n         * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementToggle` values</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         block: 'portfolio',\n         *         elementToggle: 'toggle'\n         *     }\n         * });\n         *\n         * // Active toggle output: \"portfolio-toggle-active\"\n         *\n         * @name        elementToggle\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'control'\n         */\n\n        this.elementToggle = 'control';\n\n        /**\n         * The \"modifier\" portion of the class name added to active controls.\n         * @name        modifierActive\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'active'\n         */\n\n        this.modifierActive = 'active';\n\n        /**\n         * The \"modifier\" portion of the class name added to disabled controls.\n         *\n         * @name        modifierDisabled\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'disabled'\n         */\n\n        this.modifierDisabled = 'disabled';\n\n        /**\n         * The \"modifier\" portion of the class name added to the container when in a \"failed\" state.\n         *\n         * @name        modifierFailed\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     'failed'\n         */\n\n        this.modifierFailed = 'failed';\n\n        /**\n         * The delineator used between the \"block\" and \"element\" portions of any class name added by MixItUp.\n         *\n         * If the block portion is ommited by setting it to an empty string, no delineator will be added.\n         *\n         * @example <caption>Example: changing the delineator to match BEM convention</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         delineatorElement: '__'\n         *     }\n         * });\n         *\n         * // example active control output: \"mixitup__control-active\"\n         *\n         * @name        delineatorElement\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     '-'\n         */\n\n        this.delineatorElement = '-';\n\n        /**\n         * The delineator used between the \"element\" and \"modifier\" portions of any class name added by MixItUp.\n         *\n         * If the element portion is ommited by setting it to an empty string, no delineator will be added.\n         *\n         * @example <caption>Example: changing both delineators to match BEM convention</caption>\n         * var mixer = mixitup(containerEl, {\n         *     classNames: {\n         *         delineatorElement: '__'\n         *         delineatorModifier: '--'\n         *     }\n         * });\n         *\n         * // Active control output: \"mixitup__control--active\"\n         *\n         * @name        delineatorModifier\n         * @memberof    mixitup.Config.classNames\n         * @instance\n         * @type        {string}\n         * @default     '-'\n         */\n\n        this.delineatorModifier = '-';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigClassNames);\n\n    mixitup.ConfigClassNames.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigClassNames.prototype.constructor = mixitup.ConfigClassNames;\n\n    /**\n     * A group of properties relating to MixItUp's dataset API.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        data\n     * @namespace\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigData = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A string specifying the name of the key containing your data model's unique\n         * identifier (UID). To use the dataset API, a UID key must be specified and\n         * be present and unique on all objects in the dataset you provide to MixItUp.\n         *\n         * For example, if your dataset is made up of MongoDB documents, the UID\n         * key would be `'id'` or `'_id'`.\n         *\n         * @example <caption>Example: Setting the UID to `'id'`</caption>\n         * var mixer = mixitup(containerEl, {\n         *     data: {\n         *         uidKey: 'id'\n         *     }\n         * });\n         *\n         * @name        uidKey\n         * @memberof    mixitup.Config.data\n         * @instance\n         * @type        {string}\n         * @default     ''\n         */\n\n        this.uidKey = '';\n\n        /**\n         * A boolean dictating whether or not MixItUp should \"dirty check\" each object in\n         * your dataset for changes whenever `.dataset()` is called, and re-render any targets\n         * for which a change is found.\n         *\n         * Depending on the complexity of your data model, dirty checking can be expensive\n         * and is therefore disabled by default.\n         *\n         * NB: For changes to be detected, a new immutable instance of the edited model must be\n         * provided to mixitup, rather than manipulating properties on the existing instance.\n         * If your changes are a result of a DB write and read, you will most likely be calling\n         * `.dataset()` with a clean set of objects each time, so this will not be an issue.\n         *\n         * @example <caption>Example: Enabling dirty checking</caption>\n         *\n         * var myDataset = [\n         *     {\n         *         id: 0,\n         *         title: \"Blog Post Title 0\"\n         *         ...\n         *     },\n         *     {\n         *         id: 1,\n         *         title: \"Blog Post Title 1\"\n         *         ...\n         *     }\n         * ];\n         *\n         * // Instantiate a mixer with a pre-loaded dataset, and a target renderer\n         * // function defined\n         *\n         * var mixer = mixitup(containerEl, {\n         *     data: {\n         *         uidKey: 'id',\n         *         dirtyCheck: true\n         *     },\n         *     load: {\n         *         dataset: myDataset\n         *     },\n         *     render: {\n         *         target: function() { ... }\n         *     }\n         * });\n         *\n         * // For illustration, we will clone and edit the second object in the dataset.\n         * // NB: this would typically be done server-side in response to a DB update,\n         * and then re-queried via an API.\n         *\n         * myDataset[1] = Object.assign({}, myDataset[1]);\n         *\n         * myDataset[1].title = 'Blog Post Title 11';\n         *\n         * mixer.dataset(myDataset)\n         *    .then(function() {\n         *        // the target with ID \"1\", will be re-rendered reflecting its new title\n         *    });\n         *\n         * @name        dirtyCheck\n         * @memberof    mixitup.Config.data\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.dirtyCheck = false;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigData);\n\n    mixitup.ConfigData.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigData.prototype.constructor = mixitup.ConfigData;\n\n    /**\n     * A group of properties allowing the toggling of various debug features.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        debug\n     * @namespace\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigDebug = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A boolean dictating whether or not the mixer instance returned by the\n         * `mixitup()` factory function should expose private properties and methods.\n         *\n         * By default, mixer instances only expose their public API, but enabling\n         * debug mode will give you access to various mixer internals which may aid\n         * in debugging, or the authoring of extensions.\n         *\n         * @example <caption>Example: Enabling debug mode</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     debug: {\n         *         enable: true\n         *     }\n         * });\n         *\n         * // Private properties and methods will now be visible on the mixer instance:\n         *\n         * console.log(mixer);\n         *\n         * @name        enable\n         * @memberof    mixitup.Config.debug\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.enable = false;\n\n        /**\n         * A boolean dictating whether or not warnings should be shown when various\n         * common gotchas occur.\n         *\n         * Warnings are intended to provide insights during development when something\n         * occurs that is not a fatal, but may indicate an issue with your integration,\n         * and are therefore turned on by default. However, you may wish to disable\n         * them in production.\n         *\n         * @example <caption>Example 1: Disabling warnings</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     debug: {\n         *         showWarnings: false\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Disabling warnings based on environment</caption>\n         *\n         * var showWarnings = myAppConfig.environment === 'development' ? true : false;\n         *\n         * var mixer = mixitup(containerEl, {\n         *     debug: {\n         *         showWarnings: showWarnings\n         *     }\n         * });\n         *\n         * @name        showWarnings\n         * @memberof    mixitup.Config.debug\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.showWarnings = true;\n\n        /**\n         * Used for server-side testing only.\n         *\n         * @private\n         * @name        fauxAsync\n         * @memberof    mixitup.Config.debug\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.fauxAsync = false;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigDebug);\n\n    mixitup.ConfigDebug.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigDebug.prototype.constructor = mixitup.ConfigDebug;\n\n    /**\n     * A group of properties relating to the layout of the container.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        layout\n     * @namespace\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigLayout = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A boolean dictating whether or not mixitup should query all descendants\n         * of the container for targets, or only immediate children.\n         *\n         * By default, mixitup will query all descendants matching the\n         * `selectors.target` selector when indexing targets upon instantiation.\n         * This allows for targets to be nested inside a sub-container which is\n         * useful when ring-fencing targets from locally scoped controls in your\n         * markup (see `controls.scope`).\n         *\n         * However, if you are building a more complex UI requiring the nesting\n         * of mixers within mixers, you will most likely want to limit targets to\n         * immediate children of the container by setting this property to `false`.\n         *\n         * @example <caption>Example: Restricting targets to immediate children</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     layout: {\n         *         allowNestedTargets: false\n         *     }\n         * });\n         *\n         * @name        allowNestedTargets\n         * @memberof    mixitup.Config.layout\n         * @instance\n         * @type        {boolean}\n         * @default     true\n         */\n\n        this.allowNestedTargets = true;\n\n        /**\n         * A string specifying an optional class name to apply to the container when in\n         * its default state.\n         *\n         * By changing this class name or adding a class name to the container via the\n         * `.changeLayout()` API method, the CSS layout of the container can be changed,\n         * and MixItUp will attemp to gracefully animate the container and its targets\n         * between states.\n         *\n         * @example <caption>Example 1: Specifying a container class name</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     layout: {\n         *         containerClassName: 'grid'\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Changing the default class name with `.changeLayout()`</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     layout: {\n         *         containerClassName: 'grid'\n         *     }\n         * });\n         *\n         * mixer.changeLayout('list')\n         *     .then(function(state) {\n         *          console.log(state.activeContainerClass); // \"list\"\n         *     });\n         *\n         * @name        containerClassName\n         * @memberof    mixitup.Config.layout\n         * @instance\n         * @type        {string}\n         * @default     ''\n         */\n\n        this.containerClassName = '';\n\n        /**\n         * A reference to a non-target sibling element after which to insert targets\n         * when there are no targets in the container.\n         *\n         * @example <caption>Example: Setting a `siblingBefore` reference element</caption>\n         *\n         * var addButton = containerEl.querySelector('button');\n         *\n         * var mixer = mixitup(containerEl, {\n         *     layout: {\n         *         siblingBefore: addButton\n         *     }\n         * });\n         *\n         * @name        siblingBefore\n         * @memberof    mixitup.Config.layout\n         * @instance\n         * @type        {HTMLElement}\n         * @default     null\n         */\n\n        this.siblingBefore = null;\n\n        /**\n         * A reference to a non-target sibling element before which to insert targets\n         * when there are no targets in the container.\n         *\n         * @example <caption>Example: Setting an `siblingAfter` reference element</caption>\n         *\n         * var gap = containerEl.querySelector('.gap');\n         *\n         * var mixer = mixitup(containerEl, {\n         *     layout: {\n         *         siblingAfter: gap\n         *     }\n         * });\n         *\n         * @name        siblingAfter\n         * @memberof    mixitup.Config.layout\n         * @instance\n         * @type        {HTMLElement}\n         * @default     null\n         */\n\n        this.siblingAfter = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigLayout);\n\n    mixitup.ConfigLayout.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigLayout.prototype.constructor = mixitup.ConfigLayout;\n\n    /**\n     * A group of properties defining the initial state of the mixer on load (instantiation).\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        load\n     * @namespace\n     * @public\n     * @since       2.0.0\n     */\n\n    mixitup.ConfigLoad = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A string defining any filtering to be statically applied to the mixer on load.\n         * As per the `.filter()` API, this can be any valid selector string, or the\n         * values `'all'` or `'none'`.\n         *\n         * @example <caption>Example 1: Defining an initial filter selector to be applied on load</caption>\n         *\n         * // The mixer will show only those targets matching '.category-a' on load.\n         *\n         * var mixer = mixitup(containerEl, {\n         *     load: {\n         *         filter: '.category-a'\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Hiding all targets on load</caption>\n         *\n         * // The mixer will show hide all targets on load.\n         *\n         * var mixer = mixitup(containerEl, {\n         *     load: {\n         *         filter: 'none'\n         *     }\n         * });\n         *\n         * @name        filter\n         * @memberof    mixitup.Config.load\n         * @instance\n         * @type        {string}\n         * @default     'all'\n         */\n\n        this.filter = 'all';\n\n        /**\n         * A string defining any sorting to be statically applied to the mixer on load.\n         * As per the `.sort()` API, this should be a valid \"sort string\" made up of\n         * an attribute to sort by (or `'default'`) followed by an optional sorting\n         * order, or the value `'random'`;\n         *\n         * @example <caption>Example: Defining sorting to be applied on load</caption>\n         *\n         * // The mixer will sort the container by the value of the `data-published-date`\n         * // attribute, in descending order.\n         *\n         * var mixer = mixitup(containerEl, {\n         *     load: {\n         *         sort: 'published-date:desc'\n         *     }\n         * });\n         *\n         * @name        sort\n         * @memberof    mixitup.Config.load\n         * @instance\n         * @type        {string}\n         * @default     'default:asc'\n         */\n\n        this.sort = 'default:asc';\n\n        /**\n         * An array of objects representing the underlying data of any pre-rendered targets,\n         * when using the `.dataset()` API.\n         *\n         * NB: If targets are pre-rendered when the mixer is instantiated, this must be set.\n         *\n         * @example <caption>Example: Defining the initial underyling dataset</caption>\n         *\n         * var myDataset = [\n         *     {\n         *         id: 0,\n         *         title: \"Blog Post Title 0\",\n         *         ...\n         *     },\n         *     {\n         *         id: 1,\n         *         title: \"Blog Post Title 1\",\n         *         ...\n         *     }\n         * ];\n         *\n         * var mixer = mixitup(containerEl, {\n         *     data: {\n         *         uidKey: 'id'\n         *     },\n         *     load: {\n         *         dataset: myDataset\n         *     }\n         * });\n         *\n         * @name        dataset\n         * @memberof    mixitup.Config.load\n         * @instance\n         * @type        {Array.<object>}\n         * @default     null\n         */\n\n        this.dataset = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigLoad);\n\n    mixitup.ConfigLoad.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigLoad.prototype.constructor = mixitup.ConfigLoad;\n\n    /**\n     * A group of properties defining the selectors used to query elements within a mixitup container.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        selectors\n     * @namespace\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigSelectors = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A selector string used to query and index target elements within the container.\n         *\n         * By default, the class selector `'.mix'` is used, but this can be changed to an\n         * attribute or element selector to match the style of your project.\n         *\n         * @example <caption>Example 1: Changing the target selector</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     selectors: {\n         *         target: '.portfolio-item'\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Using an attribute selector as a target selector</caption>\n         *\n         * // The mixer will search for any children with the attribute `data-ref=\"mix\"`\n         *\n         * var mixer = mixitup(containerEl, {\n         *     selectors: {\n         *         target: '[data-ref=\"mix\"]'\n         *     }\n         * });\n         *\n         * @name        target\n         * @memberof    mixitup.Config.selectors\n         * @instance\n         * @type        {string}\n         * @default     '.mix'\n         */\n\n        this.target = '.mix';\n\n        /**\n         * A optional selector string used to add further specificity to the querying of control elements,\n         * in addition to their mandatory data attribute (e.g. `data-filter`, `data-toggle`, `data-sort`).\n         *\n         * This can be used if other elements in your document must contain the above attributes\n         * (e.g. for use in third-party scripts), and would otherwise interfere with MixItUp. Adding\n         * an additional `control` selector of your choice allows MixItUp to restrict event handling\n         * to only those elements matching the defined selector.\n         *\n         * @name        control\n         * @memberof    mixitup.Config.selectors\n         * @instance\n         * @type        {string}\n         * @default     ''\n         *\n         * @example <caption>Example 1: Adding a `selectors.control` selector</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     selectors: {\n         *         control: '.mixitup-control'\n         *     }\n         * });\n         *\n         * // Will not be handled:\n         * // <button data-filter=\".category-a\"></button>\n         *\n         * // Will be handled:\n         * // <button class=\"mixitup-control\" data-filter=\".category-a\"></button>\n         */\n\n        this.control = '';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigSelectors);\n\n    mixitup.ConfigSelectors.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigSelectors.prototype.constructor = mixitup.ConfigSelectors;\n\n    /**\n     * A group of optional render functions for creating and updating elements.\n     *\n     * All render functions receive a data object, and should return a valid HTML string.\n     *\n     * @constructor\n     * @memberof    mixitup.Config\n     * @name        render\n     * @namespace\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigRender = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A function returning an HTML string representing a target element, or a reference to a\n         * single DOM element.\n         *\n         * The function is invoked as part of the `.dataset()` API, whenever a new item is added\n         * to the dataset, or an item in the dataset changes (if `dataset.dirtyCheck` is enabled).\n         *\n         * The function receives the relevant dataset item as its first parameter.\n         *\n         * @example <caption>Example 1: Using string concatenation</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     render: {\n         *         target: function(item) {\n         *             return (\n         *                 '&lt;div class=\"mix\"&gt;' +\n         *                     '&lt;h2&gt;' + item.title + '&lt;/h2&gt;' +\n         *                 '&lt;/div&gt;'\n         *             );\n         *         }\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Using an ES2015 template literal</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     render: {\n         *         target: function(item) {\n         *             return (\n         *                 `&lt;div class=\"mix\"&gt;\n         *                     &lt;h2&gt;${item.title}&lt;/h2&gt;\n         *                  &lt;/div&gt;`\n         *             );\n         *         }\n         *     }\n         * });\n         *\n         * @example <caption>Example 3: Using a Handlebars template</caption>\n         *\n         * var targetTemplate = Handlebars.compile('&lt;div class=\"mix\"&gt;&lt;h2&gt;{{title}}&lt;/h2&gt;&lt;/div&gt;');\n         *\n         * var mixer = mixitup(containerEl, {\n         *     render: {\n         *         target: targetTemplate\n         *     }\n         * });\n         *\n         * @example <caption>Example 4: Returning a DOM element</caption>\n         *\n         * var mixer = mixitup(containerEl, {\n         *     render: {\n         *         target: function(item) {\n         *              // Create a single element using your framework's built-in renderer\n         *\n         *              var el = ...\n         *\n         *              return el;\n         *         }\n         *     }\n         * });\n         *\n         * @name        target\n         * @memberof    mixitup.Config.render\n         * @instance\n         * @type        {function}\n         * @default     'null'\n         */\n\n        this.target = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigRender);\n\n    mixitup.ConfigRender.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigRender.prototype.constructor = mixitup.ConfigRender;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.ConfigTemplates = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ConfigTemplates);\n\n    mixitup.ConfigTemplates.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ConfigTemplates.prototype.constructor = mixitup.ConfigTemplates;\n\n    /**\n     * `mixitup.Config` is an interface used for customising the functionality of a\n     * mixer instance. It is organised into several semantically distinct sub-objects,\n     * each one pertaining to a particular aspect of MixItUp functionality.\n     *\n     * An object literal containing any or all of the available properies,\n     * known as the \"configuration object\", can be passed as the second parameter to\n     * the `mixitup` factory function when creating a mixer instance to customise its\n     * functionality as needed.\n     *\n     * If no configuration object is passed, the mixer instance will take on the default\n     * configuration values detailed below.\n     *\n     * @example <caption>Example 1: Creating and passing the configuration object</caption>\n     * // Create a configuration object with desired values\n     *\n     * var config = {\n     *     animation: {\n     *         enable: false\n     *     },\n     *     selectors: {\n     *         target: '.item'\n     *     }\n     * };\n     *\n     * // Pass the configuration object to the mixitup factory function\n     *\n     * var mixer = mixitup(containerEl, config);\n     *\n     * @example <caption>Example 2: Passing the configuration object inline</caption>\n     * // Typically, the configuration object is passed inline for brevity.\n     *\n     * var mixer = mixitup(containerEl, {\n     *     controls: {\n     *         live: true,\n     *         toggleLogic: 'and'\n     *     }\n     * });\n     *\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @namespace\n     * @public\n     * @since       2.0.0\n     */\n\n    mixitup.Config = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.animation          = new mixitup.ConfigAnimation();\n        this.behavior           = new mixitup.ConfigBehavior();\n        this.callbacks          = new mixitup.ConfigCallbacks();\n        this.controls           = new mixitup.ConfigControls();\n        this.classNames         = new mixitup.ConfigClassNames();\n        this.data               = new mixitup.ConfigData();\n        this.debug              = new mixitup.ConfigDebug();\n        this.layout             = new mixitup.ConfigLayout();\n        this.load               = new mixitup.ConfigLoad();\n        this.selectors          = new mixitup.ConfigSelectors();\n        this.render             = new mixitup.ConfigRender();\n        this.templates          = new mixitup.ConfigTemplates();\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Config);\n\n    mixitup.Config.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.Config.prototype.constructor = mixitup.Config;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.MixerDom = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.document               = null;\n        this.body                   = null;\n        this.container              = null;\n        this.parent                 = null;\n        this.targets                = [];\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.MixerDom);\n\n    mixitup.MixerDom.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.MixerDom.prototype.constructor = mixitup.MixerDom;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.UiClassNames = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.base       = '';\n        this.active     = '';\n        this.disabled   = '';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.UiClassNames);\n\n    mixitup.UiClassNames.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.UiClassNames.prototype.constructor = mixitup.UiClassNames;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.dataset()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandDataset = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.dataset = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandDataset);\n\n    mixitup.CommandDataset.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandDataset.prototype.constructor = mixitup.CommandDataset;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.multimix()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandMultimix = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.filter       = null;\n        this.sort         = null;\n        this.insert       = null;\n        this.remove       = null;\n        this.changeLayout = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandMultimix);\n\n    mixitup.CommandMultimix.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandMultimix.prototype.constructor = mixitup.CommandMultimix;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.filter()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandFilter = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.selector   = '';\n        this.collection = null;\n        this.action     = 'show'; // enum: ['show', 'hide']\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandFilter);\n\n    mixitup.CommandFilter.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandFilter.prototype.constructor = mixitup.CommandFilter;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.sort()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandSort = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.sortString = '';\n        this.attribute  = '';\n        this.order      = 'asc';\n        this.collection = null;\n        this.next       = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandSort);\n\n    mixitup.CommandSort.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandSort.prototype.constructor = mixitup.CommandSort;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.insert()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandInsert = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.index      = 0;\n        this.collection = [];\n        this.position   = 'before'; // enum: ['before', 'after']\n        this.sibling    = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandInsert);\n\n    mixitup.CommandInsert.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandInsert.prototype.constructor = mixitup.CommandInsert;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.remove()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandRemove = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.targets    = [];\n        this.collection = [];\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandRemove);\n\n    mixitup.CommandRemove.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandRemove.prototype.constructor = mixitup.CommandRemove;\n\n    /**\n     * An object into which all arbitrary arguments sent to '.changeLayout()' are mapped.\n     *\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.CommandChangeLayout = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.containerClassName = '';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.CommandChangeLayout);\n\n    mixitup.CommandChangeLayout.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.CommandChangeLayout.prototype.constructor = mixitup.CommandChangeLayout;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     * @param       {string}        type\n     * @param       {string}        selector\n     * @param       {boolean}       [live]\n     * @param       {string}        [parent]\n     *     An optional string representing the name of the mixer.dom property containing a reference to a parent element.\n     */\n\n    mixitup.ControlDefinition = function(type, selector, live, parent) {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.type    = type;\n        this.selector  = selector;\n        this.live      = live || false;\n        this.parent    = parent || '';\n\n        this.callActions('afterConstruct');\n\n        h.freeze(this);\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.ControlDefinition);\n\n    mixitup.ControlDefinition.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.ControlDefinition.prototype.constructor = mixitup.ControlDefinition;\n\n    mixitup.controlDefinitions = [];\n\n    mixitup.controlDefinitions.push(new mixitup.ControlDefinition('multimix', '[data-filter][data-sort]'));\n    mixitup.controlDefinitions.push(new mixitup.ControlDefinition('filter', '[data-filter]'));\n    mixitup.controlDefinitions.push(new mixitup.ControlDefinition('sort', '[data-sort]'));\n    mixitup.controlDefinitions.push(new mixitup.ControlDefinition('toggle', '[data-toggle]'));\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Control = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.el         = null;\n        this.selector   = '';\n        this.bound      = [];\n        this.pending    = -1;\n        this.type       = '';\n        this.status     = 'inactive'; // enum: ['inactive', 'active', 'disabled', 'live']\n        this.filter     = '';\n        this.sort       = '';\n        this.canDisable = false;\n        this.handler    = null;\n        this.classNames = new mixitup.UiClassNames();\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Control);\n\n    mixitup.Control.prototype = Object.create(mixitup.Base.prototype);\n\n    h.extend(mixitup.Control.prototype,\n    /** @lends mixitup.Control */\n    {\n        constructor: mixitup.Control,\n\n        /**\n         * @private\n         * @param {HTMLElement} el\n         * @param {string}      type\n         * @param {string}      selector\n         */\n\n        init: function(el, type, selector) {\n            var self = this;\n\n            this.callActions('beforeInit', arguments);\n\n            self.el         = el;\n            self.type       = type;\n            self.selector   = selector;\n\n            if (self.selector) {\n                self.status = 'live';\n            } else {\n                self.canDisable = typeof self.el.disable === 'boolean';\n\n                switch (self.type) {\n                    case 'filter':\n                        self.filter = self.el.getAttribute('data-filter');\n\n                        break;\n                    case 'toggle':\n                        self.filter = self.el.getAttribute('data-toggle');\n\n                        break;\n                    case 'sort':\n                        self.sort   = self.el.getAttribute('data-sort');\n\n                        break;\n                    case 'multimix':\n                        self.filter = self.el.getAttribute('data-filter');\n                        self.sort   = self.el.getAttribute('data-sort');\n\n                        break;\n                }\n            }\n\n            self.bindClick();\n\n            mixitup.controls.push(self);\n\n            this.callActions('afterInit', arguments);\n        },\n\n        /**\n         * @private\n         * @param  {mixitup.Mixer} mixer\n         * @return {boolean}\n         */\n\n        isBound: function(mixer) {\n            var self    = this,\n                isBound = false;\n\n            this.callActions('beforeIsBound', arguments);\n\n            isBound = self.bound.indexOf(mixer) > -1;\n\n            return self.callFilters('afterIsBound', isBound, arguments);\n        },\n\n        /**\n         * @private\n         * @param  {mixitup.Mixer} mixer\n         * @return {void}\n         */\n\n        addBinding: function(mixer) {\n            var self = this;\n\n            this.callActions('beforeAddBinding', arguments);\n\n            if (!self.isBound()) {\n                self.bound.push(mixer);\n            }\n\n            this.callActions('afterAddBinding', arguments);\n        },\n\n        /**\n         * @private\n         * @param  {mixitup.Mixer} mixer\n         * @return {void}\n         */\n\n        removeBinding: function(mixer) {\n            var self        = this,\n                removeIndex = -1;\n\n            this.callActions('beforeRemoveBinding', arguments);\n\n            if ((removeIndex = self.bound.indexOf(mixer)) > -1) {\n                self.bound.splice(removeIndex, 1);\n            }\n\n            if (self.bound.length < 1) {\n                // No bindings exist, unbind event click handlers\n\n                self.unbindClick();\n\n                // Remove from `mixitup.controls` list\n\n                removeIndex = mixitup.controls.indexOf(self);\n\n                mixitup.controls.splice(removeIndex, 1);\n\n                if (self.status === 'active') {\n                    self.renderStatus(self.el, 'inactive');\n                }\n            }\n\n            this.callActions('afterRemoveBinding', arguments);\n        },\n\n        /**\n         * @private\n         * @return {void}\n         */\n\n        bindClick: function() {\n            var self = this;\n\n            this.callActions('beforeBindClick', arguments);\n\n            self.handler = function(e) {\n                self.handleClick(e);\n            };\n\n            h.on(self.el, 'click', self.handler);\n\n            this.callActions('afterBindClick', arguments);\n        },\n\n        /**\n         * @private\n         * @return {void}\n         */\n\n        unbindClick: function() {\n            var self = this;\n\n            this.callActions('beforeUnbindClick', arguments);\n\n            h.off(self.el, 'click', self.handler);\n\n            self.handler = null;\n\n            this.callActions('afterUnbindClick', arguments);\n        },\n\n        /**\n         * @private\n         * @param   {MouseEvent} e\n         * @return  {void}\n         */\n\n        handleClick: function(e) {\n            var self        = this,\n                button      = null,\n                mixer       = null,\n                isActive    = false,\n                returnValue = void(0),\n                command     = {},\n                clone       = null,\n                commands    = [],\n                i           = -1;\n\n            this.callActions('beforeHandleClick', arguments);\n\n            this.pending = 0;\n\n            mixer = self.bound[0];\n\n            if (!self.selector) {\n                button = self.el;\n            } else {\n                button = h.closestParent(e.target, mixer.config.selectors.control + self.selector, true, mixer.dom.document);\n            }\n\n            if (!button) {\n                self.callActions('afterHandleClick', arguments);\n\n                return;\n            }\n\n            switch (self.type) {\n                case 'filter':\n                    command.filter = self.filter || button.getAttribute('data-filter');\n\n                    break;\n                case 'sort':\n                    command.sort = self.sort || button.getAttribute('data-sort');\n\n                    break;\n                case 'multimix':\n                    command.filter  = self.filter || button.getAttribute('data-filter');\n                    command.sort    = self.sort || button.getAttribute('data-sort');\n\n                    break;\n                case 'toggle':\n                    command.filter  = self.filter || button.getAttribute('data-toggle');\n\n                    if (self.status === 'live') {\n                        isActive = h.hasClass(button, self.classNames.active);\n                    } else {\n                        isActive = self.status === 'active';\n                    }\n\n                    break;\n            }\n\n            for (i = 0; i < self.bound.length; i++) {\n                // Create a clone of the command for each bound mixer instance\n\n                clone = new mixitup.CommandMultimix();\n\n                h.extend(clone, command);\n\n                commands.push(clone);\n            }\n\n            commands = self.callFilters('commandsHandleClick', commands, arguments);\n\n            self.pending = self.bound.length;\n\n            for (i = 0; mixer = self.bound[i]; i++) {\n                command = commands[i];\n\n                if (!command) {\n                    // An extension may set a command null to indicate that the click should not be handled\n\n                    continue;\n                }\n\n                if (!mixer.lastClicked) {\n                    mixer.lastClicked = button;\n                }\n\n                mixitup.events.fire('mixClick', mixer.dom.container, {\n                    state: mixer.state,\n                    instance: mixer,\n                    originalEvent: e,\n                    control: mixer.lastClicked\n                }, mixer.dom.document);\n\n                if (typeof mixer.config.callbacks.onMixClick === 'function') {\n                    returnValue = mixer.config.callbacks.onMixClick.call(mixer.lastClicked, mixer.state, e, mixer);\n\n                    if (returnValue === false) {\n                        // User has returned `false` from the callback, so do not handle click\n\n                        continue;\n                    }\n                }\n\n                if (self.type === 'toggle') {\n                    isActive ? mixer.toggleOff(command.filter) : mixer.toggleOn(command.filter);\n                } else {\n                    mixer.multimix(command);\n                }\n            }\n\n            this.callActions('afterHandleClick', arguments);\n        },\n\n        /**\n         * @param   {object}          command\n         * @param   {Array<string>}   toggleArray\n         * @return  {void}\n         */\n\n        update: function(command, toggleArray) {\n            var self    = this,\n                actions = new mixitup.CommandMultimix();\n\n            self.callActions('beforeUpdate', arguments);\n\n            self.pending--;\n\n            self.pending = Math.max(0, self.pending);\n\n            if (self.pending > 0) return;\n\n            if (self.status === 'live') {\n                // Live control (status unknown)\n\n                self.updateLive(command, toggleArray);\n            } else {\n                // Static control\n\n                actions.sort    = self.sort;\n                actions.filter  = self.filter;\n\n                self.callFilters('actionsUpdate', actions, arguments);\n\n                self.parseStatusChange(self.el, command, actions, toggleArray);\n            }\n\n            self.callActions('afterUpdate', arguments);\n        },\n\n        /**\n         * @param   {mixitup.CommandMultimix} command\n         * @param   {Array<string>}           toggleArray\n         * @return  {void}\n         */\n\n        updateLive: function(command, toggleArray) {\n            var self            = this,\n                controlButtons  = null,\n                actions         = null,\n                button          = null,\n                i               = -1;\n\n            self.callActions('beforeUpdateLive', arguments);\n\n            if (!self.el) return;\n\n            controlButtons = self.el.querySelectorAll(self.selector);\n\n            for (i = 0; button = controlButtons[i]; i++) {\n                actions = new mixitup.CommandMultimix();\n\n                switch (self.type) {\n                    case 'filter':\n                        actions.filter = button.getAttribute('data-filter');\n\n                        break;\n                    case 'sort':\n                        actions.sort = button.getAttribute('data-sort');\n\n                        break;\n                    case 'multimix':\n                        actions.filter  = button.getAttribute('data-filter');\n                        actions.sort    = button.getAttribute('data-sort');\n\n                        break;\n                    case 'toggle':\n                        actions.filter  = button.getAttribute('data-toggle');\n\n                        break;\n                }\n\n                actions = self.callFilters('actionsUpdateLive', actions, arguments);\n\n                self.parseStatusChange(button, command, actions, toggleArray);\n            }\n\n            self.callActions('afterUpdateLive', arguments);\n        },\n\n        /**\n         * @param   {HTMLElement}             button\n         * @param   {mixitup.CommandMultimix} command\n         * @param   {mixitup.CommandMultimix} actions\n         * @param   {Array<string>}           toggleArray\n         * @return  {void}\n         */\n\n        parseStatusChange: function(button, command, actions, toggleArray) {\n            var self    = this,\n                alias   = '',\n                toggle  = '',\n                i       = -1;\n\n            self.callActions('beforeParseStatusChange', arguments);\n\n            switch (self.type) {\n                case 'filter':\n                    if (command.filter === actions.filter) {\n                        self.renderStatus(button, 'active');\n                    } else {\n                        self.renderStatus(button, 'inactive');\n                    }\n\n                    break;\n                case 'multimix':\n                    if (command.sort === actions.sort && command.filter === actions.filter) {\n                        self.renderStatus(button, 'active');\n                    } else {\n                        self.renderStatus(button, 'inactive');\n                    }\n\n                    break;\n                case 'sort':\n                    if (command.sort.match(/:asc/g)) {\n                        alias = command.sort.replace(/:asc/g, '');\n                    }\n\n                    if (command.sort === actions.sort || alias === actions.sort) {\n                        self.renderStatus(button, 'active');\n                    } else {\n                        self.renderStatus(button, 'inactive');\n                    }\n\n                    break;\n                case 'toggle':\n                    if (toggleArray.length < 1) self.renderStatus(button, 'inactive');\n\n                    if (command.filter === actions.filter) {\n                        self.renderStatus(button, 'active');\n                    }\n\n                    for (i = 0; i < toggleArray.length; i++) {\n                        toggle = toggleArray[i];\n\n                        if (toggle === actions.filter) {\n                            // Button matches one active toggle\n\n                            self.renderStatus(button, 'active');\n\n                            break;\n                        }\n\n                        self.renderStatus(button, 'inactive');\n                    }\n\n                    break;\n            }\n\n            self.callActions('afterParseStatusChange', arguments);\n        },\n\n        /**\n         * @param   {HTMLElement}   button\n         * @param   {string}        status\n         * @return  {void}\n         */\n\n        renderStatus: function(button, status) {\n            var self = this;\n\n            self.callActions('beforeRenderStatus', arguments);\n\n            switch (status) {\n                case 'active':\n                    h.addClass(button, self.classNames.active);\n                    h.removeClass(button, self.classNames.disabled);\n\n                    if (self.canDisable) self.el.disabled = false;\n\n                    break;\n                case 'inactive':\n                    h.removeClass(button, self.classNames.active);\n                    h.removeClass(button, self.classNames.disabled);\n\n                    if (self.canDisable) self.el.disabled = false;\n\n                    break;\n                case 'disabled':\n                    if (self.canDisable) self.el.disabled = true;\n\n                    h.addClass(button, self.classNames.disabled);\n                    h.removeClass(button, self.classNames.active);\n\n                    break;\n            }\n\n            if (self.status !== 'live') {\n                // Update the control's status propery if not live\n\n                self.status = status;\n            }\n\n            self.callActions('afterRenderStatus', arguments);\n        }\n    });\n\n    mixitup.controls = [];\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.StyleData = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.x              = 0;\n        this.y              = 0;\n        this.top            = 0;\n        this.right          = 0;\n        this.bottom         = 0;\n        this.left           = 0;\n        this.width          = 0;\n        this.height         = 0;\n        this.marginRight    = 0;\n        this.marginBottom   = 0;\n        this.opacity        = 0;\n        this.scale          = new mixitup.TransformData();\n        this.translateX     = new mixitup.TransformData();\n        this.translateY     = new mixitup.TransformData();\n        this.translateZ     = new mixitup.TransformData();\n        this.rotateX        = new mixitup.TransformData();\n        this.rotateY        = new mixitup.TransformData();\n        this.rotateZ        = new mixitup.TransformData();\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.StyleData);\n\n    mixitup.StyleData.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.StyleData.prototype.constructor = mixitup.StyleData;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.TransformData = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.value  = 0;\n        this.unit   = '';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.TransformData);\n\n    mixitup.TransformData.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.TransformData.prototype.constructor = mixitup.TransformData;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.TransformDefaults = function() {\n        mixitup.StyleData.apply(this);\n\n        this.callActions('beforeConstruct');\n\n        this.scale.value        = 0.01;\n        this.scale.unit         = '';\n\n        this.translateX.value   = 20;\n        this.translateX.unit    = 'px';\n\n        this.translateY.value   = 20;\n        this.translateY.unit    = 'px';\n\n        this.translateZ.value   = 20;\n        this.translateZ.unit    = 'px';\n\n        this.rotateX.value      = 90;\n        this.rotateX.unit       = 'deg';\n\n        this.rotateY.value      = 90;\n        this.rotateY.unit       = 'deg';\n\n        this.rotateX.value      = 90;\n        this.rotateX.unit       = 'deg';\n\n        this.rotateZ.value      = 180;\n        this.rotateZ.unit       = 'deg';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.TransformDefaults);\n\n    mixitup.TransformDefaults.prototype = Object.create(mixitup.StyleData.prototype);\n\n    mixitup.TransformDefaults.prototype.constructor = mixitup.TransformDefaults;\n\n    /**\n     * @private\n     * @static\n     * @since   3.0.0\n     * @type    {mixitup.TransformDefaults}\n     */\n\n    mixitup.transformDefaults = new mixitup.TransformDefaults();\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.EventDetail = function() {\n        this.state          = null;\n        this.futureState    = null;\n        this.instance       = null;\n        this.originalEvent  = null;\n    };\n\n    /**\n     * The `mixitup.Events` class contains all custom events dispatched by MixItUp at various\n     * points within the lifecycle of a mixer operation.\n     *\n     * Each event is analogous to the callback function of the same name defined in\n     * the `callbacks` configuration object, and is triggered immediately before it.\n     *\n     * Events are always triggered from the container element on which MixItUp is instantiated\n     * upon.\n     *\n     * As with any event, registered event handlers receive the event object as a parameter\n     * which includes a `detail` property containting references to the current `state`,\n     * the `mixer` instance, and other event-specific properties described below.\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.Events = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * A custom event triggered immediately after any MixItUp operation is requested\n         * and before animations have begun.\n         *\n         * The `mixStart` event also exposes a `futureState` property via the\n         * `event.detail` object, which represents the final state of the mixer once\n         * the requested operation has completed.\n         *\n         * @name        mixStart\n         * @memberof    mixitup.Events\n         * @static\n         * @type        {CustomEvent}\n         */\n\n        this.mixStart = null;\n\n        /**\n         * A custom event triggered when a MixItUp operation is requested while another\n         * operation is in progress, and the animation queue is full, or queueing\n         * is disabled.\n         *\n         * @name        mixBusy\n         * @memberof    mixitup.Events\n         * @static\n         * @type        {CustomEvent}\n         */\n\n        this.mixBusy = null;\n\n        /**\n         * A custom event triggered after any MixItUp operation has completed, and the\n         * state has been updated.\n         *\n         * @name        mixEnd\n         * @memberof    mixitup.Events\n         * @static\n         * @type        {CustomEvent}\n         */\n\n        this.mixEnd = null;\n\n        /**\n         * A custom event triggered whenever a filter operation \"fails\", i.e. no targets\n         * could be found matching the requested filter.\n         *\n         * @name        mixFail\n         * @memberof    mixitup.Events\n         * @static\n         * @type        {CustomEvent}\n         */\n\n        this.mixFail = null;\n\n        /**\n         * A custom event triggered whenever a MixItUp control is clicked, and before its\n         * respective operation is requested.\n         *\n         * This event also exposes an `originalEvent` property via the `event.detail`\n         * object, which holds a reference to the original click event.\n         *\n         * @name        mixClick\n         * @memberof    mixitup.Events\n         * @static\n         * @type        {CustomEvent}\n         */\n\n        this.mixClick = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Events);\n\n    mixitup.Events.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.Events.prototype.constructor = mixitup.Events;\n\n    /**\n     * @private\n     * @param   {string}      eventType\n     * @param   {Element}     el\n     * @param   {object}      detail\n     * @param   {Document}    [doc]\n     */\n\n    mixitup.Events.prototype.fire = function(eventType, el, detail, doc) {\n        var self        = this,\n            event       = null,\n            eventDetail = new mixitup.EventDetail();\n\n        self.callActions('beforeFire', arguments);\n\n        if (typeof self[eventType] === 'undefined') {\n            throw new Error('Event type \"' + eventType + '\" not found.');\n        }\n\n        eventDetail.state = new mixitup.State();\n\n        h.extend(eventDetail.state, detail.state);\n\n        if (detail.futureState) {\n            eventDetail.futureState = new mixitup.State();\n\n            h.extend(eventDetail.futureState, detail.futureState);\n        }\n\n        eventDetail.instance = detail.instance;\n\n        if (detail.originalEvent) {\n            eventDetail.originalEvent = detail.originalEvent;\n        }\n\n        event = h.getCustomEvent(eventType, eventDetail, doc);\n\n        self.callFilters('eventFire', event, arguments);\n\n        el.dispatchEvent(event);\n    };\n\n    // Asign a singleton instance to `mixitup.events`:\n\n    mixitup.events = new mixitup.Events();\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.QueueItem = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.args           = [];\n        this.instruction    = null;\n        this.triggerElement = null;\n        this.deferred       = null;\n        this.isToggling     = false;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.QueueItem);\n\n    mixitup.QueueItem.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.QueueItem.prototype.constructor = mixitup.QueueItem;\n\n    /**\n     * The `mixitup.Mixer` class is used to hold discreet, user-configured\n     * instances of MixItUp on a provided container element.\n     *\n     * Mixer instances are returned whenever the `mixitup()` factory function is called,\n     * which expose a range of methods enabling API-based filtering, sorting,\n     * insertion, removal and more.\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.Mixer = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.config            = new mixitup.Config();\n\n        this.id                = '';\n\n        this.isBusy            = false;\n        this.isToggling        = false;\n        this.incPadding        = true;\n\n        this.controls          = [];\n        this.targets           = [];\n        this.origOrder         = [];\n        this.cache             = {};\n\n        this.toggleArray       = [];\n\n        this.targetsMoved      = 0;\n        this.targetsImmovable  = 0;\n        this.targetsBound      = 0;\n        this.targetsDone       = 0;\n\n        this.staggerDuration   = 0;\n        this.effectsIn         = null;\n        this.effectsOut        = null;\n        this.transformIn       = [];\n        this.transformOut      = [];\n        this.queue             = [];\n\n        this.state             = null;\n        this.lastOperation     = null;\n        this.lastClicked       = null;\n        this.userCallback      = null;\n        this.userDeferred      = null;\n\n        this.dom               = new mixitup.MixerDom();\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Mixer);\n\n    mixitup.Mixer.prototype = Object.create(mixitup.Base.prototype);\n\n    h.extend(mixitup.Mixer.prototype,\n    /** @lends mixitup.Mixer */\n    {\n        constructor: mixitup.Mixer,\n\n        /**\n         * @private\n         * @instance\n         * @since 3.0.0\n         * @param {HTMLElement} container\n         * @param {HTMLElement} document\n         * @param {string}      id\n         * @param {object}      [config]\n         */\n\n        attach: function(container, document, id, config) {\n            var self    = this,\n                target  = null,\n                i       = -1;\n\n            self.callActions('beforeAttach', arguments);\n\n            self.id = id;\n\n            if (config) {\n                h.extend(self.config, config, true, true);\n            }\n\n            self.sanitizeConfig();\n\n            self.cacheDom(container, document);\n\n            if (self.config.layout.containerClassName) {\n                h.addClass(self.dom.container, self.config.layout.containerClassName);\n            }\n\n            if (!mixitup.features.has.transitions) {\n                self.config.animation.enable = false;\n            }\n\n            if (typeof window.console === 'undefined') {\n                self.config.debug.showWarnings = false;\n            }\n\n            if (self.config.data.uidKey) {\n                // If the dataset API is in use, force disable controls\n\n                self.config.controls.enable = false;\n            }\n\n            self.indexTargets();\n\n            self.state = self.getInitialState();\n\n            for (i = 0; target = self.lastOperation.toHide[i]; i++) {\n                target.hide();\n            }\n\n            if (self.config.controls.enable) {\n                self.initControls();\n\n                self.buildToggleArray(null, self.state);\n\n                self.updateControls({\n                    filter: self.state.activeFilter,\n                    sort: self.state.activeSort\n                });\n            }\n\n            self.parseEffects();\n\n            self.callActions('afterAttach', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since 3.0.0\n         * @return {void}\n         */\n\n        sanitizeConfig: function() {\n            var self = this;\n\n            self.callActions('beforeSanitizeConfig', arguments);\n\n            // Sanitize enum/string config options\n\n            self.config.controls.scope          = self.config.controls.scope.toLowerCase().trim();\n            self.config.controls.toggleLogic    = self.config.controls.toggleLogic.toLowerCase().trim();\n            self.config.controls.toggleDefault  = self.config.controls.toggleDefault.toLowerCase().trim();\n\n            self.config.animation.effects       = self.config.animation.effects.trim();\n\n            self.callActions('afterSanitizeConfig', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {mixitup.State}\n         */\n\n        getInitialState: function() {\n            var self        = this,\n                state       = new mixitup.State(),\n                operation   = new mixitup.Operation();\n\n            self.callActions('beforeGetInitialState', arguments);\n\n            // Map initial values into a mock state object in order to construct an operation\n\n            state.activeContainerClassName = self.config.layout.containerClassName;\n\n            if (self.config.load.dataset) {\n                // Dataset API\n\n                if (!self.config.data.uidKey || typeof self.config.data.uidKey !== 'string') {\n                    throw new TypeError(mixitup.messages.errorConfigDataUidKeyNotSet());\n                }\n\n                operation.startDataset = operation.newDataset = state.activeDataset = self.config.load.dataset.slice();\n                operation.startContainerClassName = operation.newContainerClassName = state.activeContainerClassName;\n                operation.show = self.targets.slice();\n\n                state = self.callFilters('stateGetInitialState', state, arguments);\n            } else {\n                // DOM API\n\n                state.activeFilter              = self.parseFilterArgs([self.config.load.filter]).command;\n                state.activeSort                = self.parseSortArgs([self.config.load.sort]).command;\n                state.totalTargets              = self.targets.length;\n\n                state = self.callFilters('stateGetInitialState', state, arguments);\n\n                if (\n                    state.activeSort.collection || state.activeSort.attribute ||\n                    state.activeSort.order === 'random' || state.activeSort.order === 'desc'\n                ) {\n                    // Sorting on load\n\n                    operation.newSort = state.activeSort;\n\n                    self.sortOperation(operation);\n\n                    self.printSort(false, operation);\n\n                    self.targets = operation.newOrder;\n                } else {\n                    operation.startOrder = operation.newOrder = self.targets;\n                }\n\n                operation.startFilter               = operation.newFilter               = state.activeFilter;\n                operation.startSort                 = operation.newSort                 = state.activeSort;\n                operation.startContainerClassName   = operation.newContainerClassName   = state.activeContainerClassName;\n\n                if (operation.newFilter.selector === 'all') {\n                    operation.newFilter.selector = self.config.selectors.target;\n                } else if (operation.newFilter.selector === 'none') {\n                    operation.newFilter.selector = '';\n                }\n            }\n\n            operation = self.callFilters('operationGetInitialState', operation, [state]);\n\n            self.lastOperation = operation;\n\n            if (operation.newFilter) {\n                self.filterOperation(operation);\n            }\n\n            state = self.buildState(operation);\n\n            return state;\n        },\n\n        /**\n         * Caches references of DOM elements neccessary for the mixer's functionality.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {HTMLElement}       el\n         * @param   {HTMLHtmlElement}   document\n         * @return  {void}\n         */\n\n        cacheDom: function(el, document) {\n            var self    = this;\n\n            self.callActions('beforeCacheDom', arguments);\n\n            self.dom.document  = document;\n            self.dom.body      = self.dom.document.querySelector('body');\n            self.dom.container = el;\n            self.dom.parent    = el;\n\n            self.callActions('afterCacheDom', arguments);\n        },\n\n        /**\n         * Indexes all child elements of the mixer matching the `selectors.target`\n         * selector, instantiating a mixitup.Target for each one.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {void}\n         */\n\n        indexTargets: function() {\n            var self            = this,\n                target          = null,\n                el              = null,\n                dataset         = null,\n                i               = -1;\n\n            self.callActions('beforeIndexTargets', arguments);\n\n            self.dom.targets = self.config.layout.allowNestedTargets ?\n                self.dom.container.querySelectorAll(self.config.selectors.target) :\n                h.children(self.dom.container, self.config.selectors.target, self.dom.document);\n\n            self.dom.targets = h.arrayFromList(self.dom.targets);\n\n            self.targets = [];\n\n            if ((dataset = self.config.load.dataset) && dataset.length !== self.dom.targets.length) {\n                throw new Error(mixitup.messages.errorDatasetPrerenderedMismatch());\n            }\n\n            if (self.dom.targets.length) {\n                for (i = 0; el = self.dom.targets[i]; i++) {\n                    target = new mixitup.Target();\n\n                    target.init(el, self, dataset ? dataset[i] : void(0));\n\n                    target.isInDom = true;\n\n                    self.targets.push(target);\n                }\n\n                self.dom.parent = self.dom.targets[0].parentElement === self.dom.container ?\n                    self.dom.container :\n                    self.dom.targets[0].parentElement;\n            }\n\n            self.origOrder = self.targets;\n\n            self.callActions('afterIndexTargets', arguments);\n        },\n\n        initControls: function() {\n            var self                = this,\n                definition          = '',\n                controlElements     = null,\n                el                  = null,\n                parent              = null,\n                delagators          = null,\n                control             = null,\n                i                   = -1,\n                j                   = -1;\n\n            self.callActions('beforeInitControls', arguments);\n\n            switch (self.config.controls.scope) {\n                case 'local':\n                    parent = self.dom.container;\n\n                    break;\n                case 'global':\n                    parent = self.dom.document;\n\n                    break;\n                default:\n                    throw new Error(mixitup.messages.errorConfigInvalidControlsScope());\n            }\n\n            for (i = 0; definition = mixitup.controlDefinitions[i]; i++) {\n                if (self.config.controls.live || definition.live) {\n                    if (definition.parent) {\n                        delagators = self.dom[definition.parent];\n\n                        if (!delagators || delagators.length < 0) continue;\n\n                        if (typeof delagators.length !== 'number') {\n                            delagators = [delagators];\n                        }\n                    } else {\n                        delagators = [parent];\n                    }\n\n                    for (j = 0; (el = delagators[j]); j++) {\n                        control = self.getControl(el,  definition.type, definition.selector);\n\n                        self.controls.push(control);\n                    }\n                } else {\n                    controlElements = parent.querySelectorAll(self.config.selectors.control + definition.selector);\n\n                    for (j = 0; (el = controlElements[j]); j++) {\n                        control = self.getControl(el, definition.type, '');\n\n                        if (!control) continue;\n\n                        self.controls.push(control);\n                    }\n                }\n            }\n\n            self.callActions('afterInitControls', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {HTMLElement} el\n         * @param   {string}      type\n         * @param   {string}      selector\n         * @return  {mixitup.Control|null}\n         */\n\n        getControl: function(el, type, selector) {\n            var self    = this,\n                control = null,\n                i       = -1;\n\n            self.callActions('beforeGetControl', arguments);\n\n            if (!selector) {\n                // Static controls only\n\n                for (i = 0; control = mixitup.controls[i]; i++) {\n                    if (control.el === el && control.isBound(self)) {\n                        // Control already bound to this mixer (as another type).\n\n                        // NB: This prevents duplicate controls from being registered where a selector\n                        // might collide, eg: \"[data-filter]\" and \"[data-filter][data-sort]\"\n\n                        return self.callFilters('controlGetControl', null, arguments);\n                    } else if (control.el === el && control.type === type && control.selector === selector) {\n                        // Another mixer is already using this control, add this mixer as a binding\n\n                        control.addBinding(self);\n\n                        return self.callFilters('controlGetControl', control, arguments);\n                    }\n                }\n            }\n\n            // Create new control\n\n            control = new mixitup.Control();\n\n            control.init(el, type, selector);\n\n            control.classNames.base     = h.getClassname(self.config.classNames, type);\n            control.classNames.active   = h.getClassname(self.config.classNames, type, self.config.classNames.modifierActive);\n            control.classNames.disabled = h.getClassname(self.config.classNames, type, self.config.classNames.modifierDisabled);\n\n            // Add a reference to this mixer as a binding\n\n            control.addBinding(self);\n\n            return self.callFilters('controlGetControl', control, arguments);\n        },\n\n        /**\n         * Creates a compound selector by joining the `toggleArray` value as per the\n         * defined toggle logic.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {string}\n         */\n\n        getToggleSelector: function() {\n            var self            = this,\n                delineator      = self.config.controls.toggleLogic === 'or' ? ', ' : '',\n                toggleSelector  = '';\n\n            self.callActions('beforeGetToggleSelector', arguments);\n\n            self.toggleArray = h.clean(self.toggleArray);\n\n            toggleSelector = self.toggleArray.join(delineator);\n\n            if (toggleSelector === '') {\n                toggleSelector = self.config.controls.toggleDefault;\n            }\n\n            return self.callFilters('selectorGetToggleSelector', toggleSelector, arguments);\n        },\n\n        /**\n         * Breaks compound selector strings in an array of discreet selectors,\n         * as per the active `controls.toggleLogic` configuration option. Accepts\n         * either a dynamic command object, or a state object.\n         *\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {object}        [command]\n         * @param   {mixitup.State} [state]\n         * @return  {void}\n         */\n\n        buildToggleArray: function(command, state) {\n            var self                    = this,\n                activeFilterSelector    = '';\n\n            self.callActions('beforeBuildToggleArray', arguments);\n\n            if (command && command.filter) {\n                activeFilterSelector = command.filter.selector.replace(/\\s/g, '');\n            } else if (state) {\n                activeFilterSelector = state.activeFilter.selector.replace(/\\s/g, '');\n            } else {\n                return;\n            }\n\n            if (activeFilterSelector === self.config.selectors.target || activeFilterSelector === 'all') {\n                activeFilterSelector = '';\n            }\n\n            if (self.config.controls.toggleLogic === 'or') {\n                self.toggleArray = activeFilterSelector.split(',');\n            } else {\n                self.toggleArray = self.splitCompoundSelector(activeFilterSelector);\n            }\n\n            self.toggleArray = h.clean(self.toggleArray);\n\n            self.callActions('afterBuildToggleArray', arguments);\n        },\n\n        /**\n         * Takes a compound selector (e.g. `.cat-1.cat-2`, `[data-cat=\"1\"][data-cat=\"2\"]`)\n         * and breaks into its individual selectors.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {string} compoundSelector\n         * @return  {string[]}\n         */\n\n        splitCompoundSelector: function(compoundSelector) {\n            // Break at a `.` or `[`, capturing the delineator\n\n            var partials    = compoundSelector.split(/([\\.\\[])/g),\n                toggleArray = [],\n                selector    = '',\n                i           = -1;\n\n            if (partials[0] === '') {\n                partials.shift();\n            }\n\n            for (i = 0; i < partials.length; i++) {\n                if (i % 2 === 0) {\n                    selector = '';\n                }\n\n                selector += partials[i];\n\n                if (i % 2 !== 0) {\n                    toggleArray.push(selector);\n                }\n            }\n\n            return toggleArray;\n        },\n\n        /**\n         * Updates controls to their active/inactive state based on the command or\n         * current state of the mixer.\n         *\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {object} command\n         * @return  {void}\n         */\n\n        updateControls: function(command) {\n            var self    = this,\n                control = null,\n                output  = new mixitup.CommandMultimix(),\n                i       = -1;\n\n            self.callActions('beforeUpdateControls', arguments);\n\n            // Sanitise to defaults\n\n            if (command.filter) {\n                output.filter = command.filter.selector;\n            } else {\n                output.filter = self.state.activeFilter.selector;\n            }\n\n            if (command.sort) {\n                output.sort = self.buildSortString(command.sort);\n            } else {\n                output.sort = self.buildSortString(self.state.activeSort);\n            }\n\n            if (output.filter === self.config.selectors.target) {\n                output.filter = 'all';\n            }\n\n            if (output.filter === '') {\n                output.filter = 'none';\n            }\n\n            h.freeze(output);\n\n            for (i = 0; control = self.controls[i]; i++) {\n                control.update(output, self.toggleArray);\n            }\n\n            self.callActions('afterUpdateControls', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {mixitup.CommandSort}   command\n         * @return  {string}\n         */\n\n        buildSortString: function(command) {\n            var self    = this;\n            var output  = '';\n\n            output += command.sortString;\n\n            if (command.next) {\n                output += ' ' + self.buildSortString(command.next);\n            }\n\n            return output;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {object}        command\n         * @param   {Operation}     operation\n         * @return  {Promise.<mixitup.State>}\n         */\n\n        insertTargets: function(command, operation) {\n            var self            = this,\n                nextSibling     = null,\n                insertionIndex  = -1,\n                frag            = null,\n                target          = null,\n                el              = null,\n                i               = -1;\n\n            self.callActions('beforeInsertTargets', arguments);\n\n            if (typeof command.index === 'undefined') command.index = 0;\n\n            nextSibling = self.getNextSibling(command.index, command.sibling, command.position);\n            frag        = self.dom.document.createDocumentFragment();\n\n            if (nextSibling) {\n                insertionIndex = h.index(nextSibling, self.config.selectors.target);\n            } else {\n                insertionIndex = self.targets.length;\n            }\n\n            if (command.collection) {\n                for (i = 0; el = command.collection[i]; i++) {\n                    if (self.dom.targets.indexOf(el) > -1) {\n                        throw new Error(mixitup.messages.errorInsertPreexistingElement());\n                    }\n\n                    // Ensure elements are hidden when they are added to the DOM, so they can\n                    // be animated in gracefully\n\n                    el.style.display = 'none';\n\n                    frag.appendChild(el);\n                    frag.appendChild(self.dom.document.createTextNode(' '));\n\n                    if (!h.isElement(el, self.dom.document) || !el.matches(self.config.selectors.target)) continue;\n\n                    target = new mixitup.Target();\n\n                    target.init(el, self);\n\n                    target.isInDom = true;\n\n                    self.targets.splice(insertionIndex, 0, target);\n\n                    insertionIndex++;\n                }\n\n                self.dom.parent.insertBefore(frag, nextSibling);\n            }\n\n            // Since targets have been added, the original order must be updated\n\n            operation.startOrder = self.origOrder = self.targets;\n\n            self.callActions('afterInsertTargets', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Number}      [index]\n         * @param   {Element}     [sibling]\n         * @param   {string}      [position]\n         * @return  {Element}\n         */\n\n        getNextSibling: function(index, sibling, position) {\n            var self    = this,\n                element = null;\n\n            index = Math.max(index, 0);\n\n            if (sibling && position === 'before') {\n                // Explicit sibling\n\n                element = sibling;\n            } else if (sibling && position === 'after') {\n                // Explicit sibling\n\n                element = sibling.nextElementSibling || null;\n            } else if (self.targets.length > 0 && typeof index !== 'undefined') {\n                // Index and targets exist\n\n                element = (index < self.targets.length || !self.targets.length) ?\n                    self.targets[index].dom.el :\n                    self.targets[self.targets.length - 1].dom.el.nextElementSibling;\n            } else if (self.targets.length === 0 && self.dom.parent.children.length > 0) {\n                // No targets but other siblings\n\n                if (self.config.layout.siblingAfter) {\n                    element = self.config.layout.siblingAfter;\n                } else if (self.config.layout.siblingBefore) {\n                    element = self.config.layout.siblingBefore.nextElementSibling;\n                } else {\n                    self.dom.parent.children[0];\n                }\n            } else {\n                element === null;\n            }\n\n            return self.callFilters('elementGetNextSibling', element, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        filterOperation: function(operation) {\n            var self        = this,\n                testResult  = false,\n                index       = -1,\n                action      = '',\n                target      = null,\n                i           = -1;\n\n            self.callActions('beforeFilterOperation', arguments);\n\n            action = operation.newFilter.action;\n\n            for (i = 0; target = operation.newOrder[i]; i++) {\n                if (operation.newFilter.collection) {\n                    // show via collection\n\n                    testResult = operation.newFilter.collection.indexOf(target.dom.el) > -1;\n                } else {\n                    // show via selector\n\n                    if (operation.newFilter.selector === '') {\n                        testResult = false;\n                    } else {\n                        testResult = target.dom.el.matches(operation.newFilter.selector);\n                    }\n                }\n\n                self.evaluateHideShow(testResult, target, action, operation);\n            }\n\n            if (operation.toRemove.length) {\n                for (i = 0; target = operation.show[i]; i++) {\n                    if (operation.toRemove.indexOf(target) > -1) {\n                        // If any shown targets should be removed, move them into the toHide array\n\n                        operation.show.splice(i, 1);\n\n                        if ((index = operation.toShow.indexOf(target)) > -1) {\n                            operation.toShow.splice(index, 1);\n                        }\n\n                        operation.toHide.push(target);\n                        operation.hide.push(target);\n\n                        i--;\n                    }\n                }\n            }\n\n            operation.matching = operation.show.slice();\n\n            if (operation.show.length === 0 && operation.newFilter.selector !== '' && self.targets.length !== 0) {\n                operation.hasFailed = true;\n            }\n\n            self.callActions('afterFilterOperation', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {boolean}   testResult\n         * @param   {Element}   target\n         * @param   {string}    action\n         * @param   {Operation} operation\n         * @return  {void}\n         */\n\n        evaluateHideShow: function(testResult, target, action, operation) {\n            var self = this,\n                filteredTestResult = false,\n                args = Array.prototype.slice.call(arguments, 1);\n\n            filteredTestResult = self.callFilters('testResultEvaluateHideShow', testResult, args);\n\n            self.callActions('beforeEvaluateHideShow', arguments);\n\n            if (\n                filteredTestResult === true && action === 'show' ||\n                filteredTestResult === false && action === 'hide'\n            ) {\n                operation.show.push(target);\n\n                !target.isShown && operation.toShow.push(target);\n            } else {\n                operation.hide.push(target);\n\n                target.isShown && operation.toHide.push(target);\n            }\n\n            self.callActions('afterEvaluateHideShow', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        sortOperation: function(operation) {\n            var self     = this,\n                newOrder = [],\n                target   = null,\n                el       = null,\n                i        = -1;\n\n            self.callActions('beforeSortOperation', arguments);\n\n            operation.startOrder = self.targets;\n\n            if (operation.newSort.collection) {\n                // Sort by collection\n\n                newOrder = [];\n\n                for (i = 0; (el = operation.newSort.collection[i]); i++) {\n                    if (self.dom.targets.indexOf(el) < 0) {\n                        throw new Error(mixitup.messages.errorSortNonExistentElement());\n                    }\n\n                    target = new mixitup.Target();\n\n                    target.init(el, self);\n\n                    target.isInDom = true;\n\n                    newOrder.push(target);\n                }\n\n                operation.newOrder = newOrder;\n            } else if (operation.newSort.order === 'random') {\n                // Sort random\n\n                operation.newOrder = h.arrayShuffle(operation.startOrder);\n            } else if (operation.newSort.attribute === '') {\n                // Sort by default\n\n                operation.newOrder = self.origOrder.slice();\n\n                if (operation.newSort.order === 'desc') {\n                    operation.newOrder.reverse();\n                }\n            } else {\n                // Sort by attribute\n\n                operation.newOrder = operation.startOrder.slice();\n\n                operation.newOrder.sort(function(a, b) {\n                    return self.compare(a, b, operation.newSort);\n                });\n            }\n\n            if (h.isEqualArray(operation.newOrder, operation.startOrder)) {\n                operation.willSort = false;\n            }\n\n            self.callActions('afterSortOperation', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {mixitup.Target}        a\n         * @param   {mixitup.Target}        b\n         * @param   {mixitup.CommandSort}   command\n         * @return  {Number}\n         */\n\n        compare: function(a, b, command) {\n            var self        = this,\n                order       = command.order,\n                attrA       = self.getAttributeValue(a, command.attribute),\n                attrB       = self.getAttributeValue(b, command.attribute);\n\n            if (isNaN(attrA * 1) || isNaN(attrB * 1)) {\n                attrA = attrA.toLowerCase();\n                attrB = attrB.toLowerCase();\n            } else {\n                attrA = attrA * 1;\n                attrB = attrB * 1;\n            }\n\n            if (attrA < attrB) {\n                return order === 'asc' ? -1 : 1;\n            }\n\n            if (attrA > attrB) {\n                return order === 'asc' ? 1 : -1;\n            }\n\n            if (attrA === attrB && command.next) {\n                return self.compare(a, b, command.next);\n            }\n\n            return 0;\n        },\n\n        /**\n         * Reads the values of any data attributes present the provided target element\n         * which match the current sort command.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {mixitup.Target}    target\n         * @param   {string}            [attribute]\n         * @return  {(String|Number)}\n         */\n\n        getAttributeValue: function(target, attribute) {\n            var self    = this,\n                value   = '';\n\n            value = target.dom.el.getAttribute('data-' + attribute);\n\n            if (value === null) {\n                if (self.config.debug.showWarnings) {\n                    // Encourage users to assign values to all targets to avoid erroneous sorting\n                    // when types are mixed\n\n                    console.warn(mixitup.messages.warningInconsistentSortingAttributes({\n                        attribute: 'data-' + attribute\n                    }));\n                }\n            }\n\n            // If an attribute is not present, return 0 as a safety value\n\n            return self.callFilters('valueGetAttributeValue', value || 0, arguments);\n        },\n\n        /**\n         * Inserts elements into the DOM in the appropriate\n         * order using a document fragment for minimal\n         * DOM thrashing\n         *\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {boolean}   isResetting\n         * @param   {Operation} operation\n         * @return  {void}\n         */\n\n        printSort: function(isResetting, operation) {\n            var self        = this,\n                startOrder  = isResetting ? operation.newOrder : operation.startOrder,\n                newOrder    = isResetting ? operation.startOrder : operation.newOrder,\n                nextSibling = startOrder.length ? startOrder[startOrder.length - 1].dom.el.nextElementSibling : null,\n                frag        = window.document.createDocumentFragment(),\n                whitespace  = null,\n                target      = null,\n                el          = null,\n                i           = -1;\n\n            self.callActions('beforePrintSort', arguments);\n\n            // Empty the container\n\n            for (i = 0; target = startOrder[i]; i++) {\n                el = target.dom.el;\n\n                if (el.style.position === 'absolute') continue;\n\n                h.removeWhitespace(el.previousSibling);\n\n                el.parentElement.removeChild(el);\n            }\n\n            whitespace = nextSibling ? nextSibling.previousSibling : self.dom.parent.lastChild;\n\n            if (whitespace && whitespace.nodeName === '#text') {\n                h.removeWhitespace(whitespace);\n            }\n\n            for (i = 0; target = newOrder[i]; i++) {\n                // Add targets into a document fragment\n\n                el = target.dom.el;\n\n                if (h.isElement(frag.lastChild)) {\n                    frag.appendChild(window.document.createTextNode(' '));\n                }\n\n                frag.appendChild(el);\n            }\n\n            // Insert the document fragment into the container\n            // before any other non-target elements\n\n            if (self.dom.parent.firstChild && self.dom.parent.firstChild !== nextSibling) {\n                frag.insertBefore(window.document.createTextNode(' '), frag.childNodes[0]);\n            }\n\n            if (nextSibling) {\n                frag.appendChild(window.document.createTextNode(' '));\n\n                self.dom.parent.insertBefore(frag, nextSibling);\n            } else {\n                self.dom.parent.appendChild(frag);\n            }\n\n            self.callActions('afterPrintSort', arguments);\n        },\n\n        /**\n         * Parses user-defined sort strings (i.e. `default:asc`) into sort commands objects.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {string}                sortString\n         * @param   {mixitup.CommandSort}   command\n         * @return  {mixitup.CommandSort}\n         */\n\n        parseSortString: function(sortString, command) {\n            var self        = this,\n                rules       = sortString.split(' '),\n                current     = command,\n                rule        = [],\n                i           = -1;\n\n            // command.sortString = sortString;\n\n            for (i = 0; i < rules.length; i++) {\n                rule = rules[i].split(':');\n\n                current.sortString  = rules[i];\n                current.attribute   = h.dashCase(rule[0]);\n                current.order       = rule[1] || 'asc';\n\n                switch (current.attribute) {\n                    case 'default':\n                        // treat \"default\" as sorting by no attribute\n\n                        current.attribute = '';\n\n                        break;\n                    case 'random':\n                        // treat \"random\" as an order not an attribute\n\n                        current.attribute   = '';\n                        current.order       = 'random';\n\n                        break;\n                }\n\n                if (!current.attribute || current.order === 'random') break;\n\n                if (i < rules.length - 1) {\n                    // Embed reference to the next command\n\n                    current.next = new mixitup.CommandSort();\n\n                    h.freeze(current);\n\n                    current = current.next;\n                }\n            }\n\n            return self.callFilters('commandsParseSort', command, arguments);\n        },\n\n        /**\n         * Parses all effects out of the user-defined `animation.effects` string into\n         * their respective properties and units.\n         *\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @return  {void}\n         */\n\n        parseEffects: function() {\n            var self            = this,\n                transformName   = '',\n                effectsIn       = self.config.animation.effectsIn || self.config.animation.effects,\n                effectsOut      = self.config.animation.effectsOut || self.config.animation.effects;\n\n            self.callActions('beforeParseEffects', arguments);\n\n            self.effectsIn      = new mixitup.StyleData();\n            self.effectsOut     = new mixitup.StyleData();\n            self.transformIn    = [];\n            self.transformOut   = [];\n\n            self.effectsIn.opacity = self.effectsOut.opacity = 1;\n\n            self.parseEffect('fade', effectsIn, self.effectsIn, self.transformIn);\n            self.parseEffect('fade', effectsOut, self.effectsOut, self.transformOut, true);\n\n            for (transformName in mixitup.transformDefaults) {\n                if (!(mixitup.transformDefaults[transformName] instanceof mixitup.TransformData)) {\n                    continue;\n                }\n\n                self.parseEffect(transformName, effectsIn, self.effectsIn, self.transformIn);\n                self.parseEffect(transformName, effectsOut, self.effectsOut, self.transformOut, true);\n            }\n\n            self.parseEffect('stagger', effectsIn, self.effectsIn, self.transformIn);\n            self.parseEffect('stagger', effectsOut, self.effectsOut, self.transformOut, true);\n\n            self.callActions('afterParseEffects', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {string}    effectName\n         * @param   {string}    effectString\n         * @param   {StyleData} effects\n         * @param   {String[]}  transform\n         * @param   {boolean}   [isOut]\n         */\n\n        parseEffect: function(effectName, effectString, effects, transform, isOut) {\n            var self        = this,\n                re          = /\\(([^)]+)\\)/,\n                propIndex   = -1,\n                str         = '',\n                match       = [],\n                val         = '',\n                units       = ['%', 'px', 'em', 'rem', 'vh', 'vw', 'deg'],\n                unit        = '',\n                i           = -1;\n\n            self.callActions('beforeParseEffect', arguments);\n\n            if (typeof effectString !== 'string') {\n                throw new TypeError(mixitup.messages.errorConfigInvalidAnimationEffects());\n            }\n\n            if (effectString.indexOf(effectName) < 0) {\n                // The effect is not present in the effects string\n\n                if (effectName === 'stagger') {\n                    // Reset stagger to 0\n\n                    self.staggerDuration = 0;\n                }\n\n                return;\n            }\n\n            // The effect is present\n\n            propIndex = effectString.indexOf(effectName + '(');\n\n            if (propIndex > -1) {\n                // The effect has a user defined value in parentheses\n\n                // Extract from the first parenthesis to the end of string\n\n                str = effectString.substring(propIndex);\n\n                // Match any number of characters between \"(\" and \")\"\n\n                match = re.exec(str);\n\n                val = match[1];\n            }\n\n            switch (effectName) {\n                case 'fade':\n                    effects.opacity = val ? parseFloat(val) : 0;\n\n                    break;\n                case 'stagger':\n                    self.staggerDuration = val ? parseFloat(val) : 100;\n\n                    // TODO: Currently stagger must be applied globally, but\n                    // if seperate values are specified for in/out, this should\n                    // be respected\n\n                    break;\n                default:\n                    // All other effects are transforms following the same structure\n\n                    if (isOut && self.config.animation.reverseOut && effectName !== 'scale') {\n                        effects[effectName].value =\n                            (val ? parseFloat(val) : mixitup.transformDefaults[effectName].value) * -1;\n                    } else {\n                        effects[effectName].value =\n                            (val ? parseFloat(val) : mixitup.transformDefaults[effectName].value);\n                    }\n\n                    if (val) {\n                        for (i = 0; unit = units[i]; i++) {\n                            if (val.indexOf(unit) > -1) {\n                                effects[effectName].unit = unit;\n\n                                break;\n                            }\n                        }\n                    } else {\n                        effects[effectName].unit = mixitup.transformDefaults[effectName].unit;\n                    }\n\n                    transform.push(\n                        effectName +\n                        '(' +\n                        effects[effectName].value +\n                        effects[effectName].unit +\n                        ')'\n                    );\n            }\n\n            self.callActions('afterParseEffect', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {State}\n         */\n\n        buildState: function(operation) {\n            var self        = this,\n                state       = new mixitup.State(),\n                target      = null,\n                i           = -1;\n\n            self.callActions('beforeBuildState', arguments);\n\n            // Map target elements into state arrays.\n            // the real target objects should never be exposed\n\n            for (i = 0; target = self.targets[i]; i++) {\n                if (!operation.toRemove.length || operation.toRemove.indexOf(target) < 0) {\n                    state.targets.push(target.dom.el);\n                }\n            }\n\n            for (i = 0; target = operation.matching[i]; i++) {\n                state.matching.push(target.dom.el);\n            }\n\n            for (i = 0; target = operation.show[i]; i++) {\n                state.show.push(target.dom.el);\n            }\n\n            for (i = 0; target = operation.hide[i]; i++) {\n                if (!operation.toRemove.length || operation.toRemove.indexOf(target) < 0) {\n                    state.hide.push(target.dom.el);\n                }\n            }\n\n            state.id                        = self.id;\n            state.container                 = self.dom.container;\n            state.activeFilter              = operation.newFilter;\n            state.activeSort                = operation.newSort;\n            state.activeDataset             = operation.newDataset;\n            state.activeContainerClassName  = operation.newContainerClassName;\n            state.hasFailed                 = operation.hasFailed;\n            state.totalTargets              = self.targets.length;\n            state.totalShow                 = operation.show.length;\n            state.totalHide                 = operation.hide.length;\n            state.totalMatching             = operation.matching.length;\n            state.triggerElement            = operation.triggerElement;\n\n            return self.callFilters('stateBuildState', state, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {boolean}   shouldAnimate\n         * @param   {Operation} operation\n         * @return  {void}\n         */\n\n        goMix: function(shouldAnimate, operation) {\n            var self        = this,\n                deferred    = null;\n\n            self.callActions('beforeGoMix', arguments);\n\n            // If the animation duration is set to 0ms,\n            // or no effects specified,\n            // or the container is hidden\n            // then abort animation\n\n            if (\n                !self.config.animation.duration || !self.config.animation.effects || !h.isVisible(self.dom.container)\n            ) {\n                shouldAnimate = false;\n            }\n\n            if (\n                !operation.toShow.length &&\n                !operation.toHide.length &&\n                !operation.willSort &&\n                !operation.willChangeLayout\n            ) {\n                // If nothing to show or hide, and not sorting or\n                // changing layout\n\n                shouldAnimate = false;\n            }\n\n            if (\n                !operation.startState.show.length &&\n                !operation.show.length\n            ) {\n                // If nothing currently shown, nothing to show\n\n                shouldAnimate = false;\n            }\n\n            mixitup.events.fire('mixStart', self.dom.container, {\n                state: operation.startState,\n                futureState: operation.newState,\n                instance: self\n            }, self.dom.document);\n\n            if (typeof self.config.callbacks.onMixStart === 'function') {\n                self.config.callbacks.onMixStart.call(\n                    self.dom.container,\n                    operation.startState,\n                    operation.newState,\n                    self\n                );\n            }\n\n            h.removeClass(self.dom.container, h.getClassname(self.config.classNames, 'container', self.config.classNames.modifierFailed));\n\n            if (!self.userDeferred) {\n                // Queue empty, no pending operations\n\n                deferred = self.userDeferred = h.defer(mixitup.libraries);\n            } else {\n                // Use existing deferred\n\n                deferred = self.userDeferred;\n            }\n\n            self.isBusy = true;\n\n            if (!shouldAnimate || !mixitup.features.has.transitions) {\n                // Abort\n\n                if (self.config.debug.fauxAsync) {\n                    setTimeout(function() {\n                        self.cleanUp(operation);\n                    }, self.config.animation.duration);\n                } else {\n                    self.cleanUp(operation);\n                }\n\n                return self.callFilters('promiseGoMix', deferred.promise, arguments);\n            }\n\n            // If we should animate and the platform supports transitions, go for it\n\n            if (window.pageYOffset !== operation.docState.scrollTop) {\n                window.scrollTo(operation.docState.scrollLeft, operation.docState.scrollTop);\n            }\n\n            if (self.config.animation.applyPerspective) {\n                self.dom.parent.style[mixitup.features.perspectiveProp] =\n                    self.config.animation.perspectiveDistance;\n\n                self.dom.parent.style[mixitup.features.perspectiveOriginProp] =\n                    self.config.animation.perspectiveOrigin;\n            }\n\n            if (\n                self.config.animation.animateResizeContainer &&\n                operation.startHeight !== operation.newHeight &&\n                operation.viewportDeltaY !== operation.startHeight - operation.newHeight\n            ) {\n                self.dom.parent.style.height = operation.startHeight + 'px';\n            }\n\n            if (\n                self.config.animation.animateResizeContainer &&\n                operation.startWidth !== operation.newWidth &&\n                operation.viewportDeltaX !== operation.startWidth - operation.newWidth\n            ) {\n                self.dom.parent.style.width = operation.startWidth + 'px';\n            }\n\n            if (operation.startHeight === operation.newHeight) {\n                self.dom.parent.style.height = operation.startHeight + 'px';\n            }\n\n            if (operation.startWidth === operation.newWidth) {\n                self.dom.parent.style.width = operation.startWidth + 'px';\n            }\n\n            if (operation.startHeight === operation.newHeight && operation.startWidth === operation.newWidth) {\n                self.dom.parent.style.overflow = 'hidden';\n            }\n\n            requestAnimationFrame(function() {\n                self.moveTargets(operation);\n            });\n\n            return self.callFilters('promiseGoMix', deferred.promise, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        getStartMixData: function(operation) {\n            var self        = this,\n                parentStyle = window.getComputedStyle(self.dom.parent),\n                parentRect  = self.dom.parent.getBoundingClientRect(),\n                target      = null,\n                data        = {},\n                i           = -1,\n                boxSizing   = parentStyle[mixitup.features.boxSizingProp];\n\n            self.incPadding = (boxSizing === 'border-box');\n\n            self.callActions('beforeGetStartMixData', arguments);\n\n            for (i = 0; target = operation.show[i]; i++) {\n                data = target.getPosData();\n\n                operation.showPosData[i] = {\n                    startPosData: data\n                };\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                data = target.getPosData();\n\n                operation.toHidePosData[i] = {\n                    startPosData: data\n                };\n            }\n\n            operation.startX = parentRect.left;\n            operation.startY = parentRect.top;\n\n            operation.startHeight = self.incPadding ?\n                parentRect.height :\n                parentRect.height -\n                    parseFloat(parentStyle.paddingTop) -\n                    parseFloat(parentStyle.paddingBottom) -\n                    parseFloat(parentStyle.borderTop) -\n                    parseFloat(parentStyle.borderBottom);\n\n            operation.startWidth = self.incPadding ?\n                parentRect.width :\n                parentRect.width -\n                    parseFloat(parentStyle.paddingLeft) -\n                    parseFloat(parentStyle.paddingRight) -\n                    parseFloat(parentStyle.borderLeft) -\n                    parseFloat(parentStyle.borderRight);\n\n            self.callActions('afterGetStartMixData', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        setInter: function(operation) {\n            var self    = this,\n                target  = null,\n                i       = -1;\n\n            self.callActions('beforeSetInter', arguments);\n\n            // Prevent scrollbar flicker on non-inertial scroll platforms by clamping height/width\n\n            if (self.config.animation.clampHeight) {\n                self.dom.parent.style.height    = operation.startHeight + 'px';\n                self.dom.parent.style.overflow  = 'hidden';\n            }\n\n            if (self.config.animation.clampWidth) {\n                self.dom.parent.style.width     = operation.startWidth + 'px';\n                self.dom.parent.style.overflow  = 'hidden';\n            }\n\n            for (i = 0; target = operation.toShow[i]; i++) {\n                target.show();\n            }\n\n            if (operation.willChangeLayout) {\n                h.removeClass(self.dom.container, operation.startContainerClassName);\n                h.addClass(self.dom.container, operation.newContainerClassName);\n            }\n\n            self.callActions('afterSetInter', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        getInterMixData: function(operation) {\n            var self    = this,\n                target  = null,\n                i       = -1;\n\n            self.callActions('beforeGetInterMixData', arguments);\n\n            for (i = 0; target = operation.show[i]; i++) {\n                operation.showPosData[i].interPosData = target.getPosData();\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                operation.toHidePosData[i].interPosData = target.getPosData();\n            }\n\n            self.callActions('afterGetInterMixData', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        setFinal: function(operation) {\n            var self    = this,\n                target  = null,\n                i       = -1;\n\n            self.callActions('beforeSetFinal', arguments);\n\n            operation.willSort && self.printSort(false, operation);\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                target.hide();\n            }\n\n            self.callActions('afterSetFinal', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        getFinalMixData: function(operation) {\n            var self        = this,\n                parentStyle = null,\n                parentRect  = null,\n                target      = null,\n                i           = -1;\n\n            self.callActions('beforeGetFinalMixData', arguments);\n\n            for (i = 0; target = operation.show[i]; i++) {\n                operation.showPosData[i].finalPosData = target.getPosData();\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                operation.toHidePosData[i].finalPosData = target.getPosData();\n            }\n\n            // Remove clamping\n\n            if (self.config.animation.clampHeight || self.config.animation.clampWidth) {\n                self.dom.parent.style.height    =\n                self.dom.parent.style.width     =\n                self.dom.parent.style.overflow  = '';\n            }\n\n            if (!self.incPadding) {\n                parentStyle = window.getComputedStyle(self.dom.parent);\n            }\n\n            parentRect  = self.dom.parent.getBoundingClientRect();\n\n            operation.newX = parentRect.left;\n            operation.newY = parentRect.top;\n\n            operation.newHeight = self.incPadding ?\n                parentRect.height :\n                parentRect.height -\n                    parseFloat(parentStyle.paddingTop) -\n                    parseFloat(parentStyle.paddingBottom) -\n                    parseFloat(parentStyle.borderTop) -\n                    parseFloat(parentStyle.borderBottom);\n\n            operation.newWidth = self.incPadding ?\n                parentRect.width :\n                parentRect.width -\n                    parseFloat(parentStyle.paddingLeft) -\n                    parseFloat(parentStyle.paddingRight) -\n                    parseFloat(parentStyle.borderLeft) -\n                    parseFloat(parentStyle.borderRight);\n\n            operation.viewportDeltaX = operation.docState.viewportWidth - this.dom.document.documentElement.clientWidth;\n            operation.viewportDeltaY = operation.docState.viewportHeight - this.dom.document.documentElement.clientHeight;\n\n            if (operation.willSort) {\n                self.printSort(true, operation);\n            }\n\n            for (i = 0; target = operation.toShow[i]; i++) {\n                target.hide();\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                target.show();\n            }\n\n            if (operation.willChangeLayout) {\n                h.removeClass(self.dom.container, operation.newContainerClassName);\n                h.addClass(self.dom.container, self.config.layout.containerClassName);\n            }\n\n            self.callActions('afterGetFinalMixData', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since    3.0.0\n         * @param    {Operation}     operation\n         */\n\n        getTweenData: function(operation) {\n            var self            = this,\n                target          = null,\n                posData         = null,\n                effectNames     = Object.getOwnPropertyNames(self.effectsIn),\n                effectName      = '',\n                effect          = null,\n                widthChange     = -1,\n                heightChange    = -1,\n                i               = -1,\n                j               = -1;\n\n            self.callActions('beforeGetTweenData', arguments);\n\n            for (i = 0; target = operation.show[i]; i++) {\n                posData             = operation.showPosData[i];\n                posData.posIn       = new mixitup.StyleData();\n                posData.posOut      = new mixitup.StyleData();\n                posData.tweenData   = new mixitup.StyleData();\n\n                // Process x and y\n\n                if (target.isShown) {\n                    posData.posIn.x = posData.startPosData.x - posData.interPosData.x;\n                    posData.posIn.y = posData.startPosData.y - posData.interPosData.y;\n                } else {\n                    posData.posIn.x = posData.posIn.y = 0;\n                }\n\n                posData.posOut.x = posData.finalPosData.x - posData.interPosData.x;\n                posData.posOut.y = posData.finalPosData.y - posData.interPosData.y;\n\n                // Process opacity\n\n                posData.posIn.opacity       = target.isShown ? 1 : self.effectsIn.opacity;\n                posData.posOut.opacity      = 1;\n                posData.tweenData.opacity   = posData.posOut.opacity - posData.posIn.opacity;\n\n                // Adjust x and y if not nudging\n\n                if (!target.isShown && !self.config.animation.nudge) {\n                    posData.posIn.x = posData.posOut.x;\n                    posData.posIn.y = posData.posOut.y;\n                }\n\n                posData.tweenData.x = posData.posOut.x - posData.posIn.x;\n                posData.tweenData.y = posData.posOut.y - posData.posIn.y;\n\n                // Process width, height, and margins\n\n                if (self.config.animation.animateResizeTargets) {\n                    posData.posIn.width     = posData.startPosData.width;\n                    posData.posIn.height    = posData.startPosData.height;\n\n                    // \"||\" Prevents width/height change from including 0 width/height if hiding or showing\n\n                    widthChange = (posData.startPosData.width || posData.finalPosData.width) - posData.interPosData.width;\n\n                    posData.posIn.marginRight = posData.startPosData.marginRight - widthChange;\n\n                    heightChange = (posData.startPosData.height || posData.finalPosData.height) - posData.interPosData.height;\n\n                    posData.posIn.marginBottom = posData.startPosData.marginBottom - heightChange;\n\n                    posData.posOut.width    = posData.finalPosData.width;\n                    posData.posOut.height   = posData.finalPosData.height;\n\n                    widthChange = (posData.finalPosData.width || posData.startPosData.width) - posData.interPosData.width;\n\n                    posData.posOut.marginRight = posData.finalPosData.marginRight - widthChange;\n\n                    heightChange = (posData.finalPosData.height || posData.startPosData.height) - posData.interPosData.height;\n\n                    posData.posOut.marginBottom = posData.finalPosData.marginBottom - heightChange;\n\n                    posData.tweenData.width         = posData.posOut.width - posData.posIn.width;\n                    posData.tweenData.height        = posData.posOut.height - posData.posIn.height;\n                    posData.tweenData.marginRight   = posData.posOut.marginRight - posData.posIn.marginRight;\n                    posData.tweenData.marginBottom  = posData.posOut.marginBottom - posData.posIn.marginBottom;\n                }\n\n                // Process transforms\n\n                for (j = 0; effectName = effectNames[j]; j++) {\n                    effect = self.effectsIn[effectName];\n\n                    if (!(effect instanceof mixitup.TransformData) || !effect.value) continue;\n\n                    posData.posIn[effectName].value     = effect.value;\n                    posData.posOut[effectName].value    = 0;\n\n                    posData.tweenData[effectName].value =\n                        posData.posOut[effectName].value - posData.posIn[effectName].value;\n\n                    posData.posIn[effectName].unit =\n                        posData.posOut[effectName].unit =\n                        posData.tweenData[effectName].unit =\n                        effect.unit;\n                }\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                posData             = operation.toHidePosData[i];\n                posData.posIn       = new mixitup.StyleData();\n                posData.posOut      = new mixitup.StyleData();\n                posData.tweenData   = new mixitup.StyleData();\n\n                // Process x and y\n\n                posData.posIn.x     = target.isShown ? posData.startPosData.x - posData.interPosData.x : 0;\n                posData.posIn.y     = target.isShown ? posData.startPosData.y - posData.interPosData.y : 0;\n                posData.posOut.x    = self.config.animation.nudge ? 0 : posData.posIn.x;\n                posData.posOut.y    = self.config.animation.nudge ? 0 : posData.posIn.y;\n                posData.tweenData.x = posData.posOut.x - posData.posIn.x;\n                posData.tweenData.y = posData.posOut.y - posData.posIn.y;\n\n                // Process width, height, and margins\n\n                if (self.config.animation.animateResizeTargets) {\n                    posData.posIn.width         = posData.startPosData.width;\n                    posData.posIn.height        = posData.startPosData.height;\n\n                    widthChange = posData.startPosData.width - posData.interPosData.width;\n\n                    posData.posIn.marginRight = posData.startPosData.marginRight - widthChange;\n\n                    heightChange = posData.startPosData.height - posData.interPosData.height;\n\n                    posData.posIn.marginBottom = posData.startPosData.marginBottom - heightChange;\n                }\n\n                // Process opacity\n\n                posData.posIn.opacity       = 1;\n                posData.posOut.opacity      = self.effectsOut.opacity;\n                posData.tweenData.opacity   = posData.posOut.opacity - posData.posIn.opacity;\n\n                // Process transforms\n\n                for (j = 0; effectName = effectNames[j]; j++) {\n                    effect = self.effectsOut[effectName];\n\n                    if (!(effect instanceof mixitup.TransformData) || !effect.value) continue;\n\n                    posData.posIn[effectName].value     = 0;\n                    posData.posOut[effectName].value    = effect.value;\n\n                    posData.tweenData[effectName].value =\n                        posData.posOut[effectName].value - posData.posIn[effectName].value;\n\n                    posData.posIn[effectName].unit =\n                        posData.posOut[effectName].unit =\n                        posData.tweenData[effectName].unit =\n                        effect.unit;\n                }\n            }\n\n            self.callActions('afterGetTweenData', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        moveTargets: function(operation) {\n            var self            = this,\n                target          = null,\n                moveData        = null,\n                posData         = null,\n                statusChange    = '',\n                willTransition  = false,\n                staggerIndex    = -1,\n                i               = -1,\n                checkProgress   = self.checkProgress.bind(self);\n\n            self.callActions('beforeMoveTargets', arguments);\n\n            // TODO: this is an extra loop in addition to the calcs\n            // done in getOperation, could some of this be done there?\n\n            for (i = 0; target = operation.show[i]; i++) {\n                moveData    = new mixitup.IMoveData();\n                posData     = operation.showPosData[i];\n\n                statusChange = target.isShown ? 'none' : 'show';\n\n                willTransition = self.willTransition(\n                    statusChange,\n                    operation.hasEffect,\n                    posData.posIn,\n                    posData.posOut\n                );\n\n                if (willTransition) {\n                    // Prevent non-transitioning targets from incrementing the staggerIndex\n\n                    staggerIndex++;\n                }\n\n                target.show();\n\n                moveData.posIn          = posData.posIn;\n                moveData.posOut         = posData.posOut;\n                moveData.statusChange   = statusChange;\n                moveData.staggerIndex   = staggerIndex;\n                moveData.operation      = operation;\n                moveData.callback       = willTransition ? checkProgress : null;\n\n                target.move(moveData);\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                posData  = operation.toHidePosData[i];\n                moveData = new mixitup.IMoveData();\n\n                statusChange = 'hide';\n\n                willTransition = self.willTransition(statusChange, posData.posIn, posData.posOut);\n\n                moveData.posIn          = posData.posIn;\n                moveData.posOut         = posData.posOut;\n                moveData.statusChange   = statusChange;\n                moveData.staggerIndex   = i;\n                moveData.operation      = operation;\n                moveData.callback       = willTransition ? checkProgress : null;\n\n                target.move(moveData);\n            }\n\n            if (self.config.animation.animateResizeContainer) {\n                self.dom.parent.style[mixitup.features.transitionProp] =\n                    'height ' + self.config.animation.duration + 'ms ease, ' +\n                    'width ' + self.config.animation.duration + 'ms ease ';\n\n                requestAnimationFrame(function() {\n                    if (\n                        operation.startHeight !== operation.newHeight &&\n                        operation.viewportDeltaY !== operation.startHeight - operation.newHeight\n                    ) {\n                        self.dom.parent.style.height = operation.newHeight + 'px';\n                    }\n\n                    if (\n                        operation.startWidth !== operation.newWidth &&\n                        operation.viewportDeltaX !== operation.startWidth - operation.newWidth\n                    ) {\n                        self.dom.parent.style.width = operation.newWidth + 'px';\n                    }\n                });\n            }\n\n            if (operation.willChangeLayout) {\n                h.removeClass(self.dom.container, self.config.layout.ContainerClassName);\n                h.addClass(self.dom.container, operation.newContainerClassName);\n            }\n\n            self.callActions('afterMoveTargets', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @return  {boolean}\n         */\n\n        hasEffect: function() {\n            var self        = this,\n                EFFECTABLES = [\n                    'scale',\n                    'translateX', 'translateY', 'translateZ',\n                    'rotateX', 'rotateY', 'rotateZ'\n                ],\n                effectName  = '',\n                effect      = null,\n                result      = false,\n                value       = -1,\n                i           = -1;\n\n            if (self.effectsIn.opacity !== 1) {\n                return self.callFilters('resultHasEffect', true, arguments);\n            }\n\n            for (i = 0; effectName = EFFECTABLES[i]; i++) {\n                effect  = self.effectsIn[effectName];\n                value   = (typeof effect && effect.value !== 'undefined') ?\n                    effect.value : effect;\n\n                if (value !== 0) {\n                    result = true;\n\n                    break;\n                }\n            }\n\n            return self.callFilters('resultHasEffect', result, arguments);\n        },\n\n        /**\n         * Determines if a target element will transition in\n         * some fasion and therefore requires binding of\n         * transitionEnd\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {string}        statusChange\n         * @param   {boolean}       hasEffect\n         * @param   {StyleData}     posIn\n         * @param   {StyleData}     posOut\n         * @return  {boolean}\n         */\n\n        willTransition: function(statusChange, hasEffect, posIn, posOut) {\n            var self    = this,\n                result  = false;\n\n            if (!h.isVisible(self.dom.container)) {\n                // If the container is not visible, the transitionEnd\n                // event will not occur and MixItUp will hang\n\n                result = false;\n            } else if (\n                (statusChange !== 'none' && hasEffect) ||\n                posIn.x !== posOut.x ||\n                posIn.y !== posOut.y\n            ) {\n                // If opacity and/or translate will change\n\n                result = true;\n            } else if (self.config.animation.animateResizeTargets) {\n                // Check if width, height or margins will change\n\n                result = (\n                    posIn.width !== posOut.width ||\n                    posIn.height !== posOut.height ||\n                    posIn.marginRight !== posOut.marginRight ||\n                    posIn.marginTop !== posOut.marginTop\n                );\n            } else {\n                result = false;\n            }\n\n            return self.callFilters('resultWillTransition', result, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        checkProgress: function(operation) {\n            var self = this;\n\n            self.targetsDone++;\n\n            if (self.targetsBound === self.targetsDone) {\n                self.cleanUp(operation);\n            }\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Operation}     operation\n         * @return  {void}\n         */\n\n        cleanUp: function(operation) {\n            var self                = this,\n                target              = null,\n                whitespaceBefore    = null,\n                whitespaceAfter     = null,\n                nextInQueue         = null,\n                i                   = -1;\n\n            self.callActions('beforeCleanUp', arguments);\n\n            self.targetsMoved          =\n                self.targetsImmovable  =\n                self.targetsBound      =\n                self.targetsDone       = 0;\n\n            for (i = 0; target = operation.show[i]; i++) {\n                target.cleanUp();\n\n                target.show();\n            }\n\n            for (i = 0; target = operation.toHide[i]; i++) {\n                target.cleanUp();\n\n                target.hide();\n            }\n\n            if (operation.willSort) {\n                self.printSort(false, operation);\n            }\n\n            // Remove any styles applied to the parent container\n\n            self.dom.parent.style[mixitup.features.transitionProp]             =\n                self.dom.parent.style.height                                   =\n                self.dom.parent.style.width                                    =\n                self.dom.parent.style.overflow                                 =\n                self.dom.parent.style[mixitup.features.perspectiveProp]        =\n                self.dom.parent.style[mixitup.features.perspectiveOriginProp]  = '';\n\n            if (operation.willChangeLayout) {\n                h.removeClass(self.dom.container, operation.startContainerClassName);\n                h.addClass(self.dom.container, operation.newContainerClassName);\n            }\n\n            if (operation.toRemove.length) {\n                for (i = 0; target = self.targets[i]; i++) {\n                    if (operation.toRemove.indexOf(target) > -1) {\n                        if (\n                            (whitespaceBefore = target.dom.el.previousSibling) && whitespaceBefore.nodeName === '#text' &&\n                            (whitespaceAfter = target.dom.el.nextSibling) && whitespaceAfter.nodeName === '#text'\n                        ) {\n                            h.removeWhitespace(whitespaceBefore);\n                        }\n\n                        if (!operation.willSort) {\n                            // NB: Sorting will remove targets as a bi-product of `printSort()`\n\n                            self.dom.parent.removeChild(target.dom.el);\n                        }\n\n                        self.targets.splice(i, 1);\n\n                        target.isInDom = false;\n\n                        i--;\n                    }\n                }\n\n                // Since targets have been removed, the original order must be updated\n\n                self.origOrder = self.targets;\n            }\n\n            if (operation.willSort) {\n                self.targets = operation.newOrder;\n            }\n\n            self.state = operation.newState;\n            self.lastOperation = operation;\n\n            self.dom.targets = self.state.targets;\n\n            // mixEnd\n\n            mixitup.events.fire('mixEnd', self.dom.container, {\n                state: self.state,\n                instance: self\n            }, self.dom.document);\n\n            if (typeof self.config.callbacks.onMixEnd === 'function') {\n                self.config.callbacks.onMixEnd.call(self.dom.container, self.state, self);\n            }\n\n            if (operation.hasFailed) {\n                // mixFail\n\n                mixitup.events.fire('mixFail', self.dom.container, {\n                    state: self.state,\n                    instance: self\n                }, self.dom.document);\n\n                if (typeof self.config.callbacks.onMixFail === 'function') {\n                    self.config.callbacks.onMixFail.call(self.dom.container, self.state, self);\n                }\n\n                h.addClass(self.dom.container, h.getClassname(self.config.classNames, 'container', self.config.classNames.modifierFailed));\n            }\n\n            // User-defined callback function\n\n            if (typeof self.userCallback === 'function') {\n                self.userCallback.call(self.dom.container, self.state, self);\n            }\n\n            if (typeof self.userDeferred.resolve === 'function') {\n                self.userDeferred.resolve(self.state);\n            }\n\n            self.userCallback  = null;\n            self.userDeferred  = null;\n            self.lastClicked   = null;\n            self.isToggling    = false;\n            self.isBusy        = false;\n\n            if (self.queue.length) {\n                self.callActions('beforeReadQueueCleanUp', arguments);\n\n                nextInQueue = self.queue.shift();\n\n                // Update non-public API properties stored in queue\n\n                self.userDeferred  = nextInQueue.deferred;\n                self.isToggling    = nextInQueue.isToggling;\n                self.lastClicked   = nextInQueue.triggerElement;\n\n                if (nextInQueue.instruction.command instanceof mixitup.CommandMultimix) {\n                    self.multimix.apply(self, nextInQueue.args);\n                } else {\n                    self.dataset.apply(self, nextInQueue.args);\n                }\n            }\n\n            self.callActions('afterCleanUp', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Array<*>}  args\n         * @return  {mixitup.UserInstruction}\n         */\n\n        parseMultimixArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                arg         = null,\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandMultimix();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (arg === null) continue;\n\n                if (typeof arg === 'object') {\n                    h.extend(instruction.command, arg);\n                } else if (typeof arg === 'boolean') {\n                    instruction.animate = arg;\n                } else if (typeof arg === 'function') {\n                    instruction.callback = arg;\n                }\n            }\n\n            // Coerce arbitrary command arguments into typed command objects\n\n            if (instruction.command.insert && !(instruction.command.insert instanceof mixitup.CommandInsert)) {\n                instruction.command.insert = self.parseInsertArgs([instruction.command.insert]).command;\n            }\n\n            if (instruction.command.remove && !(instruction.command.remove instanceof mixitup.CommandRemove)) {\n                instruction.command.remove = self.parseRemoveArgs([instruction.command.remove]).command;\n            }\n\n            if (instruction.command.filter && !(instruction.command.filter instanceof mixitup.CommandFilter)) {\n                instruction.command.filter = self.parseFilterArgs([instruction.command.filter]).command;\n            }\n\n            if (instruction.command.sort && !(instruction.command.sort instanceof mixitup.CommandSort)) {\n                instruction.command.sort = self.parseSortArgs([instruction.command.sort]).command;\n            }\n\n            if (instruction.command.changeLayout && !(instruction.command.changeLayout instanceof mixitup.CommandChangeLayout)) {\n                instruction.command.changeLayout = self.parseChangeLayoutArgs([instruction.command.changeLayout]).command;\n            }\n\n            instruction = self.callFilters('instructionParseMultimixArgs', instruction, arguments);\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Array<*>}  args\n         * @return  {mixitup.UserInstruction}\n         */\n\n        parseFilterArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                arg         = null,\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandFilter();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (typeof arg === 'string') {\n                    // Selector\n\n                    instruction.command.selector = arg;\n                } else if (arg === null) {\n                    instruction.command.collection = [];\n                } else if (typeof arg === 'object' && h.isElement(arg, self.dom.document)) {\n                    // Single element\n\n                    instruction.command.collection = [arg];\n                } else if (typeof arg === 'object' && typeof arg.length !== 'undefined') {\n                    // Multiple elements in array, NodeList or jQuery collection\n\n                    instruction.command.collection = h.arrayFromList(arg);\n                } else if (typeof arg === 'object') {\n                    // Filter command\n\n                    h.extend(instruction.command, arg);\n                } else if (typeof arg === 'boolean') {\n                    instruction.animate = arg;\n                } else if (typeof arg === 'function') {\n                    instruction.callback = arg;\n                }\n            }\n\n            if (instruction.command.selector && instruction.command.collection) {\n                throw new Error(mixitup.messages.errorFilterInvalidArguments());\n            }\n\n            instruction = self.callFilters('instructionParseFilterArgs', instruction, arguments);\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        parseSortArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                arg         = null,\n                sortString  = '',\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandSort();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (arg === null) continue;\n\n                switch (typeof arg) {\n                    case 'string':\n                        // Sort string\n\n                        sortString = arg;\n\n                        break;\n                    case 'object':\n                        // Array of element references\n\n                        if (arg.length) {\n                            instruction.command.collection = h.arrayFromList(arg);\n                        }\n\n                        break;\n                    case 'boolean':\n                        instruction.animate = arg;\n\n                        break;\n                    case 'function':\n                        instruction.callback = arg;\n\n                        break;\n                }\n            }\n\n            if (sortString) {\n                instruction.command = self.parseSortString(sortString, instruction.command);\n            }\n\n            instruction = self.callFilters('instructionParseSortArgs', instruction, arguments);\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {Array<*>}  args\n         * @return  {mixitup.UserInstruction}\n         */\n\n        parseInsertArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                arg         = null,\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandInsert();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (arg === null) continue;\n\n                if (typeof arg === 'number') {\n                    // Insert index\n\n                    instruction.command.index = arg;\n                } else if (typeof arg === 'string' && ['before', 'after'].indexOf(arg) > -1) {\n                    // 'before'/'after'\n\n                    instruction.command.position = arg;\n                } else if (typeof arg === 'string') {\n                    // Markup\n\n                    instruction.command.collection =\n                        h.arrayFromList(h.createElement(arg).childNodes);\n                } else if (typeof arg === 'object' && h.isElement(arg, self.dom.document)) {\n                    // Single element\n\n                    !instruction.command.collection.length ?\n                        (instruction.command.collection = [arg]) :\n                        (instruction.command.sibling = arg);\n                } else if (typeof arg === 'object' && arg.length) {\n                    // Multiple elements in array or jQuery collection\n\n                    !instruction.command.collection.length ?\n                        (instruction.command.collection = arg) :\n                        instruction.command.sibling = arg[0];\n                } else if (typeof arg === 'object' && arg.childNodes && arg.childNodes.length) {\n                    // Document fragment\n\n                    !instruction.command.collection.length ?\n                        instruction.command.collection = h.arrayFromList(arg.childNodes) :\n                        instruction.command.sibling = arg.childNodes[0];\n                } else if (typeof arg === 'object') {\n                    // Insert command\n\n                    h.extend(instruction.command, arg);\n                } else if (typeof arg === 'boolean') {\n                    instruction.animate = arg;\n                } else if (typeof arg === 'function') {\n                    instruction.callback = arg;\n                }\n            }\n\n            if (instruction.command.index && instruction.command.sibling) {\n                throw new Error(mixitup.messages.errorInsertInvalidArguments());\n            }\n\n            if (!instruction.command.collection.length && self.config.debug.showWarnings) {\n                console.warn(mixitup.messages.warningInsertNoElements());\n            }\n\n            instruction = self.callFilters('instructionParseInsertArgs', instruction, arguments);\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Array<*>}  args\n         * @return  {mixitup.UserInstruction}\n         */\n\n        parseRemoveArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                target      = null,\n                arg         = null,\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandRemove();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (arg === null) continue;\n\n                switch (typeof arg) {\n                    case 'number':\n                        if (self.targets[arg]) {\n                            instruction.command.targets[0] = self.targets[arg];\n                        }\n\n                        break;\n                    case 'string':\n                        instruction.command.collection = h.arrayFromList(self.dom.parent.querySelectorAll(arg));\n\n                        break;\n                    case 'object':\n                        if (arg && arg.length) {\n                            instruction.command.collection = arg;\n                        } else if (h.isElement(arg, self.dom.document)) {\n                            instruction.command.collection = [arg];\n                        } else {\n                            // Remove command\n\n                            h.extend(instruction.command, arg);\n                        }\n\n                        break;\n                    case 'boolean':\n                        instruction.animate = arg;\n\n                        break;\n                    case 'function':\n                        instruction.callback = arg;\n\n                        break;\n                }\n            }\n\n            if (instruction.command.collection.length) {\n                for (i = 0; target = self.targets[i]; i++) {\n                    if (instruction.command.collection.indexOf(target.dom.el) > -1) {\n                        instruction.command.targets.push(target);\n                    }\n                }\n            }\n\n            if (!instruction.command.targets.length && self.config.debug.showWarnings) {\n                console.warn(mixitup.messages.warningRemoveNoElements());\n            }\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Array<*>}  args\n         * @return  {mixitup.UserInstruction}\n         */\n\n        parseDatasetArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                arg         = null,\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandDataset();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (arg === null) continue;\n\n                switch (typeof arg) {\n                    case 'object':\n                        if (Array.isArray(arg) || typeof arg.length === 'number') {\n                            instruction.command.dataset = arg;\n                        } else {\n                            // Change layout command\n\n                            h.extend(instruction.command, arg);\n                        }\n\n                        break;\n                    case 'boolean':\n                        instruction.animate = arg;\n\n                        break;\n                    case 'function':\n                        instruction.callback = arg;\n\n                        break;\n                }\n            }\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Array<*>}  args\n         * @return  {mixitup.UserInstruction}\n         */\n\n        parseChangeLayoutArgs: function(args) {\n            var self        = this,\n                instruction = new mixitup.UserInstruction(),\n                arg         = null,\n                i           = -1;\n\n            instruction.animate = self.config.animation.enable;\n            instruction.command = new mixitup.CommandChangeLayout();\n\n            for (i = 0; i < args.length; i++) {\n                arg = args[i];\n\n                if (arg === null) continue;\n\n                switch (typeof arg) {\n                    case 'string':\n                        instruction.command.containerClassName = arg;\n\n                        break;\n                    case 'object':\n                        // Change layout command\n\n                        h.extend(instruction.command, arg);\n\n                        break;\n                    case 'boolean':\n                        instruction.animate = arg;\n\n                        break;\n                    case 'function':\n                        instruction.callback = arg;\n\n                        break;\n                }\n            }\n\n            h.freeze(instruction);\n\n            return instruction;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since       3.0.0\n         * @param       {mixitup.QueueItem}         queueItem\n         * @return      {Promise.<mixitup.State>}\n         */\n\n        queueMix: function(queueItem) {\n            var self            = this,\n                deferred        = null,\n                toggleSelector  = '';\n\n            self.callActions('beforeQueueMix', arguments);\n\n            deferred = h.defer(mixitup.libraries);\n\n            if (self.config.animation.queue && self.queue.length < self.config.animation.queueLimit) {\n                queueItem.deferred = deferred;\n\n                self.queue.push(queueItem);\n\n                // Keep controls in sync with user interactions. Mixer will catch up as it drains the queue.\n\n                if (self.config.controls.enable) {\n                    if (self.isToggling) {\n                        self.buildToggleArray(queueItem.instruction.command);\n\n                        toggleSelector = self.getToggleSelector();\n\n                        self.updateControls({\n                            filter: {\n                                selector: toggleSelector\n                            }\n                        });\n                    } else {\n                        self.updateControls(queueItem.instruction.command);\n                    }\n                }\n            } else {\n                if (self.config.debug.showWarnings) {\n                    console.warn(mixitup.messages.warningMultimixInstanceQueueFull());\n                }\n\n                deferred.resolve(self.state);\n\n                mixitup.events.fire('mixBusy', self.dom.container, {\n                    state: self.state,\n                    instance: self\n                }, self.dom.document);\n\n                if (typeof self.config.callbacks.onMixBusy === 'function') {\n                    self.config.callbacks.onMixBusy.call(self.dom.container, self.state, self);\n                }\n            }\n\n            return self.callFilters('promiseQueueMix', deferred.promise, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Array.<object>}    newDataset\n         * @return  {Operation}\n         */\n\n        getDataOperation: function(newDataset) {\n            var self                = this,\n                operation           = new mixitup.Operation(),\n                startDataset        = [];\n\n            operation = self.callFilters('operationUnmappedGetDataOperation', operation, arguments);\n\n            if (self.dom.targets.length && !(startDataset = (self.state.activeDataset || [])).length) {\n                throw new Error(mixitup.messages.errorDatasetNotSet());\n            }\n\n            operation.id            = h.randomHex();\n            operation.startState    = self.state;\n            operation.startDataset  = startDataset;\n            operation.newDataset    = newDataset.slice();\n\n            self.diffDatasets(operation);\n\n            operation.startOrder = self.targets;\n            operation.newOrder = operation.show;\n\n            if (self.config.animation.enable) {\n                self.getStartMixData(operation);\n                self.setInter(operation);\n\n                operation.docState = h.getDocumentState(self.dom.document);\n\n                self.getInterMixData(operation);\n                self.setFinal(operation);\n                self.getFinalMixData(operation);\n\n                self.parseEffects();\n\n                operation.hasEffect = self.hasEffect();\n\n                self.getTweenData(operation);\n            }\n\n            self.targets = operation.show.slice();\n\n            operation.newState = self.buildState(operation);\n\n            // NB: Targets to be removed must be included in `self.targets` for removal during clean up,\n            // but are added after state is built so that state is accurate\n\n            Array.prototype.push.apply(self.targets, operation.toRemove);\n\n            operation = self.callFilters('operationMappedGetDataOperation', operation, arguments);\n\n            return operation;\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {mixitup.Operation} operation\n         * @return  {void}\n         */\n\n        diffDatasets: function(operation) {\n            var self                = this,\n                persistantStartIds  = [],\n                persistantNewIds    = [],\n                insertedTargets     = [],\n                data                = null,\n                target              = null,\n                el                  = null,\n                frag                = null,\n                nextEl              = null,\n                uids                = {},\n                id                  = '',\n                i                   = -1;\n\n            self.callActions('beforeDiffDatasets', arguments);\n\n            for (i = 0; data = operation.newDataset[i]; i++) {\n                if (typeof (id = data[self.config.data.uidKey]) === 'undefined' || id.toString().length < 1) {\n                    throw new TypeError(mixitup.messages.errorDatasetInvalidUidKey({\n                        uidKey: self.config.data.uidKey\n                    }));\n                }\n\n                if (!uids[id]) {\n                    uids[id] = true;\n                } else {\n                    throw new Error(mixitup.messages.errorDatasetDuplicateUid({\n                        uid: id\n                    }));\n                }\n\n                if ((target = self.cache[id]) instanceof mixitup.Target) {\n                    // Already in cache\n\n                    if (self.config.data.dirtyCheck && !h.deepEquals(data, target.data)) {\n                        // change detected\n\n                        el = target.render(data);\n\n                        target.data = data;\n\n                        if (el !== target.dom.el) {\n                            // Update target element reference\n\n                            if (target.isInDom) {\n                                target.unbindEvents();\n\n                                self.dom.parent.replaceChild(el, target.dom.el);\n                            }\n\n                            if (!target.isShown) {\n                                el.style.display = 'none';\n                            }\n\n                            target.dom.el = el;\n\n                            if (target.isInDom) {\n                                target.bindEvents();\n                            }\n                        }\n                    }\n\n                    el = target.dom.el;\n                } else {\n                    // New target\n\n                    target = new mixitup.Target();\n\n                    target.init(null, self, data);\n\n                    target.hide();\n                }\n\n                if (!target.isInDom) {\n                    // Adding to DOM\n\n                    if (!frag) {\n                        // Open frag\n\n                        frag = self.dom.document.createDocumentFragment();\n                    }\n\n                    if (frag.lastElementChild) {\n                        frag.appendChild(self.dom.document.createTextNode(' '));\n                    }\n\n                    frag.appendChild(target.dom.el);\n\n                    target.isInDom = true;\n\n                    target.unbindEvents();\n                    target.bindEvents();\n                    target.hide();\n\n                    operation.toShow.push(target);\n\n                    insertedTargets.push(target);\n                } else {\n                    // Already in DOM\n\n                    nextEl = target.dom.el.nextElementSibling;\n\n                    persistantNewIds.push(id);\n\n                    if (frag) {\n                        // Close and insert previously opened frag\n\n                        if (frag.lastElementChild) {\n                            frag.appendChild(self.dom.document.createTextNode(' '));\n                        }\n\n                        self.insertDatasetFrag(frag, target.dom.el, insertedTargets);\n\n                        frag = null;\n                    }\n                }\n\n                operation.show.push(target);\n            }\n\n            if (frag) {\n                // Unclosed frag remaining\n\n                nextEl = nextEl || self.config.layout.siblingAfter;\n\n                if (nextEl) {\n                    frag.appendChild(self.dom.document.createTextNode(' '));\n                }\n\n                self.insertDatasetFrag(frag, nextEl, insertedTargets);\n            }\n\n            for (i = 0; data = operation.startDataset[i]; i++) {\n                id = data[self.config.data.uidKey];\n\n                target = self.cache[id];\n\n                if (operation.show.indexOf(target) < 0) {\n                    // Previously shown but now absent\n\n                    operation.hide.push(target);\n                    operation.toHide.push(target);\n                    operation.toRemove.push(target);\n                } else {\n                    persistantStartIds.push(id);\n                }\n            }\n\n            if (!h.isEqualArray(persistantStartIds, persistantNewIds)) {\n                operation.willSort = true;\n            }\n\n            self.callActions('afterDiffDatasets', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.1.5\n         * @param   {DocumentFragment}          frag\n         * @param   {(HTMLElement|null)}        nextEl\n         * @param   {Array.<mixitup.Target>}    targets\n         * @return  {void}\n         */\n\n        insertDatasetFrag: function(frag, nextEl, targets) {\n            var self = this;\n            var insertAt = nextEl ? h.arrayFromList(self.dom.parent.children).indexOf(nextEl) : self.targets.length;\n\n            self.dom.parent.insertBefore(frag, nextEl);\n\n            while (targets.length) {\n                self.targets.splice(insertAt, 0, targets.shift());\n\n                insertAt++;\n            }\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {mixitup.CommandSort} sortCommandA\n         * @param   {mixitup.CommandSort} sortCommandB\n         * @return  {boolean}\n         */\n\n        willSort: function(sortCommandA, sortCommandB) {\n            var self    = this,\n                result  = false;\n\n            if (\n                self.config.behavior.liveSort ||\n                sortCommandA.order       === 'random' ||\n                sortCommandA.attribute   !== sortCommandB.attribute ||\n                sortCommandA.order       !== sortCommandB.order ||\n                sortCommandA.collection  !== sortCommandB.collection ||\n                (sortCommandA.next === null && sortCommandB.next) ||\n                (sortCommandA.next && sortCommandB.next === null)\n            ) {\n                result = true;\n            } else if (sortCommandA.next && sortCommandB.next) {\n                result = self.willSort(sortCommandA.next, sortCommandB.next);\n            } else {\n                result = false;\n            }\n\n            return self.callFilters('resultWillSort', result, arguments);\n        },\n\n        /**\n         * A shorthand method for `.filter('all')`. Shows all targets in the container.\n         *\n         * @example\n         *\n         * .show()\n         *\n         * @example <caption>Example: Showing all targets</caption>\n         *\n         * mixer.show()\n         *     .then(function(state) {\n         *         console.log(state.totalShow === state.totalTargets); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @return      {Promise.<mixitup.State>}\n         */\n\n        show: function() {\n            var self = this;\n\n            return self.filter('all');\n        },\n\n        /**\n         * A shorthand method for `.filter('none')`. Hides all targets in the container.\n         *\n         * @example\n         *\n         * .hide()\n         *\n         * @example <caption>Example: Hiding all targets</caption>\n         *\n         * mixer.hide()\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 0); // true\n         *         console.log(state.totalHide === state.totalTargets); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @return      {Promise.<mixitup.State>}\n         */\n\n        hide: function() {\n            var self = this;\n\n            return self.filter('none');\n        },\n\n        /**\n         * Returns a boolean indicating whether or not a MixItUp operation is\n         * currently in progress.\n         *\n         * @example\n         *\n         * .isMixing()\n         *\n         * @example <caption>Example: Checking the status of a mixer</caption>\n         *\n         * mixer.sort('random', function() {\n         *     console.log(mixer.isMixing()) // false\n         * });\n         *\n         * console.log(mixer.isMixing()) // true\n         *\n         * @public\n         * @instance\n         * @since   2.0.0\n         * @return  {boolean}\n         */\n\n        isMixing: function() {\n            var self = this;\n\n            return self.isBusy;\n        },\n\n        /**\n         * Filters all targets in the container by a provided selector string, or the values `'all'`\n         * or `'none'`. Only targets matching the selector will be shown.\n         *\n         * @example\n         *\n         * .filter(selector [, animate] [, callback])\n         *\n         * @example <caption>Example 1: Filtering targets by a class selector</caption>\n         *\n         * mixer.filter('.category-a')\n         *     .then(function(state) {\n         *         console.log(state.totalShow === containerEl.querySelectorAll('.category-a').length); // true\n         *     });\n         *\n         * @example <caption>Example 2: Filtering targets by an attribute selector</caption>\n         *\n         * mixer.filter('[data-category~=\"a\"]')\n         *     .then(function(state) {\n         *         console.log(state.totalShow === containerEl.querySelectorAll('[data-category~=\"a\"]').length); // true\n         *     });\n         *\n         * @example <caption>Example 3: Filtering targets by a compound selector</caption>\n         *\n         * // Show only those targets with the classes 'category-a' AND 'category-b'\n         *\n         * mixer.filter('.category-a.category-c')\n         *     .then(function(state) {\n         *         console.log(state.totalShow === containerEl.querySelectorAll('.category-a.category-c').length); // true\n         *     });\n         *\n         * @example <caption>Example 4: Filtering via an element collection</caption>\n         *\n         * var collection = Array.from(container.querySelectorAll('.mix'));\n         *\n         * console.log(collection.length); // 34\n         *\n         * // Filter the collection manually using Array.prototype.filter\n         *\n         * var filtered = collection.filter(function(target) {\n         *    return parseInt(target.getAttribute('data-price')) > 10;\n         * });\n         *\n         * console.log(filtered.length); // 22\n         *\n         * // Pass the filtered collection to MixItUp\n         *\n         * mixer.filter(filtered)\n         *    .then(function(state) {\n         *        console.log(state.activeFilter.collection.length === 22); // true\n         *    });\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @param       {(string|HTMLElement|Array.<HTMLElement>)} selector\n         *      Any valid CSS selector (i.e. `'.category-a'`), or the values `'all'` or `'none'`. The filter method also accepts a reference to single target element or a collection of target elements to show.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        filter: function() {\n            var self        = this,\n                instruction = self.parseFilterArgs(arguments);\n\n            return self.multimix({\n                filter: instruction.command\n            }, instruction.animate, instruction.callback);\n        },\n\n        /**\n         * Adds an additional selector to the currently active filter selector, concatenating\n         * as per the logic defined in `controls.toggleLogic`.\n         *\n         * @example\n         *\n         * .toggleOn(selector [, animate] [, callback])\n         *\n         * @example <caption>Example: Toggling on a filter selector</caption>\n         *\n         * console.log(mixer.getState().activeFilter.selector); // '.category-a'\n         *\n         * mixer.toggleOn('.category-b')\n         *     .then(function(state) {\n         *         console.log(state.activeFilter.selector); // '.category-a, .category-b'\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {string}    selector\n         *      Any valid CSS selector (i.e. `'.category-a'`)\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        toggleOn: function() {\n            var self            = this,\n                instruction     = self.parseFilterArgs(arguments),\n                selector        = instruction.command.selector,\n                toggleSelector  = '';\n\n            self.isToggling = true;\n\n            if (self.toggleArray.indexOf(selector) < 0) {\n                self.toggleArray.push(selector);\n            }\n\n            toggleSelector = self.getToggleSelector();\n\n            return self.multimix({\n                filter: toggleSelector\n            }, instruction.animate, instruction.callback);\n        },\n\n        /**\n         * Removes a selector from the active filter selector.\n         *\n         * @example\n         *\n         * .toggleOff(selector [, animate] [, callback])\n         *\n         * @example <caption>Example: Toggling off a filter selector</caption>\n         *\n         * console.log(mixer.getState().activeFilter.selector); // '.category-a, .category-b'\n         *\n         * mixer.toggleOff('.category-b')\n         *     .then(function(state) {\n         *         console.log(state.activeFilter.selector); // '.category-a'\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {string}    selector\n         *      Any valid CSS selector (i.e. `'.category-a'`)\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        toggleOff: function() {\n            var self            = this,\n                instruction     = self.parseFilterArgs(arguments),\n                selector        = instruction.command.selector,\n                selectorIndex   = self.toggleArray.indexOf(selector),\n                toggleSelector  = '';\n\n            self.isToggling = true;\n\n            if (selectorIndex > -1) {\n                self.toggleArray.splice(selectorIndex, 1);\n            }\n\n            toggleSelector = self.getToggleSelector();\n\n            return self.multimix({\n                filter: toggleSelector\n            }, instruction.animate, instruction.callback);\n        },\n\n        /**\n         * Sorts all targets in the container according to a provided sort string.\n         *\n         * @example\n         *\n         * .sort(sortString [, animate] [, callback])\n         *\n         * @example <caption>Example 1: Sorting by the default DOM order</caption>\n         *\n         * // Reverse the default order of the targets\n         *\n         * mixer.sort('default:desc')\n         *     .then(function(state) {\n         *         console.log(state.activeSort.attribute === 'default'); // true\n         *         console.log(state.activeSort.order === 'desc'); // true\n         *     });\n         *\n         * @example <caption>Example 2: Sorting by a custom data-attribute</caption>\n         *\n         * // Sort the targets by the value of a `data-published-date` attribute\n         *\n         * mixer.sort('published-date:asc')\n         *     .then(function(state) {\n         *         console.log(state.activeSort.attribute === 'published-date'); // true\n         *         console.log(state.activeSort.order === 'asc'); // true\n         *     });\n         *\n         * @example <caption>Example 3: Sorting by multiple attributes</caption>\n         *\n         * // Sort the targets by the value of a `data-published-date` attribute, then by `data-title`\n         *\n         * mixer.sort('published-date:desc data-title:asc')\n         *     .then(function(state) {\n         *         console.log(state.activeSort.attribute === 'published-date'); // true\n         *         console.log(state.activeSort.order === 'desc'); // true\n         *\n         *         console.log(state.activeSort.next.attribute === 'title'); // true\n         *         console.log(state.activeSort.next.order === 'asc'); // true\n         *     });\n         *\n         * @example <caption>Example 4: Sorting by random</caption>\n         *\n         * mixer.sort('random')\n         *     .then(function(state) {\n         *         console.log(state.activeSort.order === 'random') // true\n         *     });\n         *\n         * @example <caption>Example 5: Sorting via an element collection</caption>\n         *\n         * var collection = Array.from(container.querySelectorAll('.mix'));\n         *\n         * // Swap the position of two elements in the collection:\n         *\n         * var temp = collection[1];\n         *\n         * collection[1] = collection[0];\n         * collection[0] = temp;\n         *\n         * // Pass the sorted collection to MixItUp\n         *\n         * mixer.sort(collection)\n         *     .then(function(state) {\n         *         console.log(state.targets[0] === collection[0]); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @param       {(string|Array.<HTMLElement>)}    sortString\n         *      A valid sort string (e.g. `'default'`, `'published-date:asc'`, or `'random'`). The sort method also accepts an array of all target elements in a user-defined order.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        sort: function() {\n            var self        = this,\n                instruction = self.parseSortArgs(arguments);\n\n            return self.multimix({\n                sort: instruction.command\n            }, instruction.animate, instruction.callback);\n        },\n\n        /**\n         * Changes the layout of the container by adding, removing or updating a\n         * layout-specific class name. If `animation.animateResizetargets` is\n         * enabled, MixItUp will attempt to gracefully animate the width, height,\n         * and position of targets between layout states.\n         *\n         * @example\n         *\n         * .changeLayout(containerClassName [, animate] [, callback])\n         *\n         * @example <caption>Example 1: Adding a new class name to the container</caption>\n         *\n         * mixer.changeLayout('container-list')\n         *      .then(function(state) {\n         *          console.log(state.activeContainerClass === 'container-list'); // true\n         *      });\n         *\n         * @example <caption>Example 2: Removing a previously added class name from the container</caption>\n         *\n         * mixer.changeLayout('')\n         *      .then(function(state) {\n         *          console.log(state.activeContainerClass === ''); // true\n         *      });\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @param       {string}    containerClassName\n         *      A layout-specific class name to add to the container.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        changeLayout: function() {\n            var self        = this,\n                instruction = self.parseChangeLayoutArgs(arguments);\n\n            return self.multimix({\n                changeLayout: instruction.command\n            }, instruction.animate, instruction.callback);\n        },\n\n        /**\n         * Updates the contents and order of the container to reflect the provided dataset,\n         * if the dataset API is in use.\n         *\n         * The dataset API is designed for use in API-driven JavaScript applications, and\n         * can be used instead of DOM-based methods such as `.filter()`, `.sort()`,\n         * `.insert()`, etc. When used, insertion, removal, sorting and pagination can be\n         * achieved purely via changes to your data model, without the uglyness of having\n         * to interact with or query the DOM directly.\n         *\n         * @example\n         *\n         * .dataset(dataset [, animate] [, callback])\n         *\n         * @example <caption>Example 1: Rendering a dataset</caption>\n         *\n         * var myDataset = [\n         *     {id: 1, ...},\n         *     {id: 2, ...},\n         *     {id: 3, ...}\n         * ];\n         *\n         * mixer.dataset(myDataset)\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 3); // true\n         *     });\n         *\n         * @example <caption>Example 2: Sorting a dataset</caption>\n         *\n         * // Create a new dataset in reverse order\n         *\n         * var newDataset = myDataset.slice().reverse();\n         *\n         * mixer.dataset(newDataset)\n         *     .then(function(state) {\n         *         console.log(state.activeDataset[0] === myDataset[2]); // true\n         *     });\n         *\n         * @example <caption>Example 3: Removing an item from the dataset</caption>\n         *\n         * console.log(myDataset.length); // 3\n         *\n         * // Create a new dataset with the last item removed.\n         *\n         * var newDataset = myDataset.slice().pop();\n         *\n         * mixer.dataset(newDataset)\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 2); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {Array.<object>}    dataset\n         *      An array of objects, each one representing the underlying data model of a target to be rendered.\n         * @param       {boolean}           [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}          [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        dataset: function() {\n            var self        = this,\n                instruction = self.parseDatasetArgs(arguments),\n                operation   = null,\n                queueItem   = null,\n                animate     = false;\n\n            self.callActions('beforeDataset', arguments);\n\n            if (!self.isBusy) {\n                if (instruction.callback) self.userCallback = instruction.callback;\n\n                animate = (instruction.animate ^ self.config.animation.enable) ? instruction.animate : self.config.animation.enable;\n\n                operation = self.getDataOperation(instruction.command.dataset);\n\n                return self.goMix(animate, operation);\n            } else {\n                queueItem = new mixitup.QueueItem();\n\n                queueItem.args          = arguments;\n                queueItem.instruction   = instruction;\n\n                return self.queueMix(queueItem);\n            }\n        },\n\n        /**\n         * Performs simultaneous `filter`, `sort`, `insert`, `remove` and `changeLayout`\n         * operations as requested.\n         *\n         * @example\n         *\n         * .multimix(multimixCommand [, animate] [, callback])\n         *\n         * @example <caption>Example 1: Performing simultaneous filtering and sorting</caption>\n         *\n         * mixer.multimix({\n         *     filter: '.category-b',\n         *     sort: 'published-date:desc'\n         * })\n         *     .then(function(state) {\n         *         console.log(state.activeFilter.selector === '.category-b'); // true\n         *         console.log(state.activeSort.attribute === 'published-date'); // true\n         *     });\n         *\n         * @example <caption>Example 2: Performing simultaneous sorting, insertion, and removal</caption>\n         *\n         * console.log(mixer.getState().totalShow); // 6\n         *\n         * // NB: When inserting via `multimix()`, an object should be provided as the value\n         * // for the `insert` portion of the command, allowing for a collection of elements\n         * // and an insertion index to be specified.\n         *\n         * mixer.multimix({\n         *     sort: 'published-date:desc', // Sort the container, including any new elements\n         *     insert: {\n         *         collection: [newElementReferenceA, newElementReferenceB], // Add 2 new elements at index 5\n         *         index: 5\n         *     },\n         *     remove: existingElementReference // Remove 1 existing element\n         * })\n         *     .then(function(state) {\n         *         console.log(state.activeSort.attribute === 'published-date'); // true\n         *         console.log(state.totalShow === 7); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @param       {object}    multimixCommand\n         *      An object containing one or more things to do\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        multimix: function() {\n            var self        = this,\n                operation   = null,\n                animate     = false,\n                queueItem   = null,\n                instruction = self.parseMultimixArgs(arguments);\n\n            self.callActions('beforeMultimix', arguments);\n\n            if (!self.isBusy) {\n                operation = self.getOperation(instruction.command);\n\n                if (self.config.controls.enable) {\n                    // Update controls for API calls\n\n                    if (instruction.command.filter && !self.isToggling) {\n                        // As we are not toggling, reset the toggle array\n                        // so new filter overrides existing toggles\n\n                        self.toggleArray.length = 0;\n                        self.buildToggleArray(operation.command);\n                    }\n\n                    if (self.queue.length < 1) {\n                        self.updateControls(operation.command);\n                    }\n                }\n\n                if (instruction.callback) self.userCallback = instruction.callback;\n\n                // Always allow the instruction to override the instance setting\n\n                animate = (instruction.animate ^ self.config.animation.enable) ?\n                    instruction.animate :\n                    self.config.animation.enable;\n\n                self.callFilters('operationMultimix', operation, arguments);\n\n                return self.goMix(animate, operation);\n            } else {\n                queueItem = new mixitup.QueueItem();\n\n                queueItem.args           = arguments;\n                queueItem.instruction    = instruction;\n                queueItem.triggerElement = self.lastClicked;\n                queueItem.isToggling     = self.isToggling;\n\n                return self.queueMix(queueItem);\n            }\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {object}            multimixCommand\n         * @param   {boolean}           [isPreFetch]\n         *      An optional boolean indicating that the operation is being pre-fetched for execution at a later time.\n         * @return  {Operation|null}\n         */\n\n        getOperation: function(multimixCommand) {\n            var self                = this,\n                sortCommand         = multimixCommand.sort,\n                filterCommand       = multimixCommand.filter,\n                changeLayoutCommand = multimixCommand.changeLayout,\n                removeCommand       = multimixCommand.remove,\n                insertCommand       = multimixCommand.insert,\n                operation           = new mixitup.Operation();\n\n            operation = self.callFilters('operationUnmappedGetOperation', operation, arguments);\n\n            operation.id                = h.randomHex();\n            operation.command           = multimixCommand;\n            operation.startState        = self.state;\n            operation.triggerElement    = self.lastClicked;\n\n            if (self.isBusy) {\n                if (self.config.debug.showWarnings) {\n                    console.warn(mixitup.messages.warningGetOperationInstanceBusy());\n                }\n\n                return null;\n            }\n\n            if (insertCommand) {\n                self.insertTargets(insertCommand, operation);\n            }\n\n            if (removeCommand) {\n                operation.toRemove = removeCommand.targets;\n            }\n\n            operation.startSort = operation.newSort = operation.startState.activeSort;\n            operation.startOrder = operation.newOrder = self.targets;\n\n            if (sortCommand) {\n                operation.startSort = operation.startState.activeSort;\n                operation.newSort   = sortCommand;\n\n                operation.willSort = self.willSort(sortCommand, operation.startState.activeSort);\n\n                if (operation.willSort) {\n                    self.sortOperation(operation);\n                }\n            }\n\n            operation.startFilter = operation.startState.activeFilter;\n\n            if (filterCommand) {\n                operation.newFilter = filterCommand;\n            } else {\n                operation.newFilter = h.extend(new mixitup.CommandFilter(), operation.startFilter);\n            }\n\n            if (operation.newFilter.selector === 'all') {\n                operation.newFilter.selector = self.config.selectors.target;\n            } else if (operation.newFilter.selector === 'none') {\n                operation.newFilter.selector = '';\n            }\n\n            self.filterOperation(operation);\n\n            operation.startContainerClassName = operation.startState.activeContainerClassName;\n\n            if (changeLayoutCommand) {\n                operation.newContainerClassName = changeLayoutCommand.containerClassName;\n\n                if (operation.newContainerClassName !== operation.startContainerClassName) {\n                    operation.willChangeLayout = true;\n                }\n            } else {\n                operation.newContainerClassName = operation.startContainerClassName;\n            }\n\n            if (self.config.animation.enable) {\n                // Populate the operation's position data\n\n                self.getStartMixData(operation);\n                self.setInter(operation);\n\n                operation.docState = h.getDocumentState(self.dom.document);\n\n                self.getInterMixData(operation);\n                self.setFinal(operation);\n                self.getFinalMixData(operation);\n\n                self.parseEffects();\n\n                operation.hasEffect = self.hasEffect();\n\n                self.getTweenData(operation);\n            }\n\n            if (operation.willSort) {\n                self.targets = operation.newOrder;\n            }\n\n            operation.newState = self.buildState(operation);\n\n            return self.callFilters('operationMappedGetOperation', operation, arguments);\n        },\n\n        /**\n         * Renders a previously created operation at a specific point in its path, as\n         * determined by a multiplier between 0 and 1.\n         *\n         * @example\n         * .tween(operation, multiplier)\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {mixitup.Operation}     operation\n         *      An operation object created via the `getOperation` method\n         *\n         * @param   {Float}                 multiplier\n         *      Any number between 0 and 1 representing the percentage complete of the operation\n         * @return  {void}\n         */\n\n        tween: function(operation, multiplier) {\n            var target          = null,\n                posData         = null,\n                toHideIndex     = -1,\n                i               = -1;\n\n            multiplier = Math.min(multiplier, 1);\n            multiplier = Math.max(multiplier, 0);\n\n            for (i = 0; target = operation.show[i]; i++) {\n                posData = operation.showPosData[i];\n\n                target.applyTween(posData, multiplier);\n            }\n\n            for (i = 0; target = operation.hide[i]; i++) {\n                if (target.isShown) {\n                    target.hide();\n                }\n\n                if ((toHideIndex = operation.toHide.indexOf(target)) > -1) {\n                    posData = operation.toHidePosData[toHideIndex];\n\n                    if (!target.isShown) {\n                        target.show();\n                    }\n\n                    target.applyTween(posData, multiplier);\n                }\n            }\n        },\n\n        /**\n         * Inserts one or more new target elements into the container at a specified\n         * index.\n         *\n         * To be indexed as targets, new elements must match the `selectors.target`\n         * selector (`'.mix'` by default).\n         *\n         * @example\n         *\n         * .insert(newElements [, index] [, animate], [, callback])\n         *\n         * @example <caption>Example 1: Inserting a single element via reference</caption>\n         *\n         * console.log(mixer.getState().totalShow); // 0\n         *\n         * // Create a new element\n         *\n         * var newElement = document.createElement('div');\n         * newElement.classList.add('mix');\n         *\n         * mixer.insert(newElement)\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 1); // true\n         *     });\n         *\n         * @example <caption>Example 2: Inserting a single element via HTML string</caption>\n         *\n         * console.log(mixer.getState().totalShow); // 1\n         *\n         * // Create a new element via reference\n         *\n         * var newElementHtml = '&lt;div class=\"mix\"&gt;&lt;/div&gt;';\n         *\n         * // Create and insert the new element at index 1\n         *\n         * mixer.insert(newElementHtml, 1)\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 2); // true\n         *         console.log(state.show[1].outerHTML === newElementHtml); // true\n         *     });\n         *\n         * @example <caption>Example 3: Inserting multiple elements via reference</caption>\n         *\n         * console.log(mixer.getState().totalShow); // 2\n         *\n         * // Create an array of new elements to insert.\n         *\n         * var newElement1 = document.createElement('div');\n         * var newElement2 = document.createElement('div');\n         *\n         * newElement1.classList.add('mix');\n         * newElement2.classList.add('mix');\n         *\n         * var newElementsCollection = [newElement1, newElement2];\n         *\n         * // Insert the new elements starting at index 1\n         *\n         * mixer.insert(newElementsCollection, 1)\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 4); // true\n         *         console.log(state.show[1] === newElement1); // true\n         *         console.log(state.show[2] === newElement2); // true\n         *     });\n         *\n         * @example <caption>Example 4: Inserting a jQuery collection object containing one or more elements</caption>\n         *\n         * console.log(mixer.getState().totalShow); // 4\n         *\n         * var $newElement = $('&lt;div class=\"mix\"&gt;&lt;/div&gt;');\n         *\n         * // Insert the new elements starting at index 3\n         *\n         * mixer.insert($newElement, 3)\n         *     .then(function(state) {\n         *         console.log(state.totalShow === 5); // true\n         *         console.log(state.show[3] === $newElement[0]); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements\n         *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.\n         * @param       {number}    index=0\n         *      The index at which to insert the new element(s). `0` by default.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        insert: function() {\n            var self = this,\n                args = self.parseInsertArgs(arguments);\n\n            return self.multimix({\n                insert: args.command\n            }, args.animate, args.callback);\n        },\n\n        /**\n         * Inserts one or more new elements before a provided reference element.\n         *\n         * @example\n         *\n         * .insertBefore(newElements, referenceElement [, animate] [, callback])\n         *\n         * @example <caption>Example: Inserting a new element before a reference element</caption>\n         *\n         * // An existing reference element is chosen at index 2\n         *\n         * var referenceElement = mixer.getState().show[2];\n         *\n         * // Create a new element\n         *\n         * var newElement = document.createElement('div');\n         * newElement.classList.add('mix');\n         *\n         * mixer.insertBefore(newElement, referenceElement)\n         *     .then(function(state) {\n         *         // The new element is inserted into the container at index 2, before the reference element\n         *\n         *         console.log(state.show[2] === newElement); // true\n         *\n         *         // The reference element is now at index 3\n         *\n         *         console.log(state.show[3] === referenceElement); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements\n         *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.\n         * @param       {HTMLElement}    referenceElement\n         *      A reference to an existing element in the container to insert new elements before.\n         *@param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        insertBefore: function() {\n            var self = this,\n                args = self.parseInsertArgs(arguments);\n\n            return self.insert(args.command.collection, 'before', args.command.sibling, args.animate, args.callback);\n        },\n\n        /**\n         * Inserts one or more new elements after a provided reference element.\n         *\n         * @example\n         *\n         * .insertAfter(newElements, referenceElement [, animate] [, callback])\n         *\n         * @example <caption>Example: Inserting a new element after a reference element</caption>\n         *\n         * // An existing reference element is chosen at index 2\n         *\n         * var referenceElement = mixer.getState().show[2];\n         *\n         * // Create a new element\n         *\n         * var newElement = document.createElement('div');\n         * newElement.classList.add('mix');\n         *\n         * mixer.insertAfter(newElement, referenceElement)\n         *     .then(function(state) {\n         *         // The new element is inserted into the container at index 3, after the reference element\n         *\n         *         console.log(state.show[3] === newElement); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements\n         *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.\n         * @param       {HTMLElement}    referenceElement\n         *      A reference to an existing element in the container to insert new elements after.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        insertAfter: function() {\n            var self = this,\n                args = self.parseInsertArgs(arguments);\n\n            return self.insert(args.command.collection, 'after', args.command.sibling, args.animate, args.callback);\n        },\n\n        /**\n         * Inserts one or more new elements into the container before all existing targets.\n         *\n         * @example\n         *\n         * .prepend(newElements [,animate] [,callback])\n         *\n         * @example <caption>Example: Prepending a new element</caption>\n         *\n         * // Create a new element\n         *\n         * var newElement = document.createElement('div');\n         * newElement.classList.add('mix');\n         *\n         * // Insert the element into the container\n         *\n         * mixer.prepend(newElement)\n         *     .then(function(state) {\n         *         console.log(state.show[0] === newElement); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements\n         *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        prepend: function() {\n            var self = this,\n                args = self.parseInsertArgs(arguments);\n\n            return self.insert(0, args.command.collection, args.animate, args.callback);\n        },\n\n        /**\n         * Inserts one or more new elements into the container after all existing targets.\n         *\n         * @example\n         *\n         * .append(newElements [,animate] [,callback])\n         *\n         * @example <caption>Example: Appending a new element</caption>\n         *\n         * // Create a new element\n         *\n         * var newElement = document.createElement('div');\n         * newElement.classList.add('mix');\n         *\n         * // Insert the element into the container\n         *\n         * mixer.append(newElement)\n         *     .then(function(state) {\n         *         console.log(state.show[state.show.length - 1] === newElement); // true\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements\n         *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        append: function() {\n            var self = this,\n                args = self.parseInsertArgs(arguments);\n\n            return self.insert(self.state.totalTargets, args.command.collection, args.animate, args.callback);\n        },\n\n        /**\n         * Removes one or more existing target elements from the container.\n         *\n         * @example\n         *\n         * .remove(elements [, animate] [, callback])\n         *\n         * @example <caption>Example 1: Removing an element by reference</caption>\n         *\n         * var elementToRemove = containerEl.firstElementChild;\n         *\n         * mixer.remove(elementToRemove)\n         *      .then(function(state) {\n         *          console.log(state.targets.indexOf(elementToRemove) === -1); // true\n         *      });\n         *\n         * @example <caption>Example 2: Removing a collection of elements by reference</caption>\n         *\n         * var elementsToRemove = containerEl.querySelectorAll('.category-a');\n         *\n         * console.log(elementsToRemove.length) // 3\n         *\n         * mixer.remove(elementsToRemove)\n         *      .then(function() {\n         *          console.log(containerEl.querySelectorAll('.category-a').length); // 0\n         *      });\n         *\n         * @example <caption>Example 3: Removing one or more elements by selector</caption>\n         *\n         * mixer.remove('.category-a')\n         *      .then(function() {\n         *          console.log(containerEl.querySelectorAll('.category-a').length); // 0\n         *      });\n         *\n         * @example <caption>Example 4: Removing an element by index</caption>\n         *\n         * console.log(mixer.getState.totalShow); // 4\n         *\n         * // Remove the element at index 3\n         *\n         * mixer.remove(3)\n         *      .then(function(state) {\n         *          console.log(state.totalShow); // 3\n         *          console.log(state.show[3]); // undefined\n         *      });\n         *\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {(HTMLElement|Array.<HTMLElement>|string|number)}    elements\n         *      A reference to a single element to remove, an array-like collection of elements, a selector string, or the index of an element to remove.\n         * @param       {boolean}   [animate=true]\n         *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.\n         * @param       {function}  [callback=null]\n         *      An optional callback function to be invoked after the operation has completed.\n         * @return      {Promise.<mixitup.State>}\n         *      A promise resolving with the current state object.\n         */\n\n        remove: function() {\n            var self = this,\n                args = self.parseRemoveArgs(arguments);\n\n            return self.multimix({\n                remove: args.command\n            }, args.animate, args.callback);\n        },\n\n        /**\n         * Retrieves the the value of any property or sub-object within the current\n         * mixitup configuration, or the whole configuration object.\n         *\n         * @example\n         *\n         * .getConfig([stringKey])\n         *\n         * @example <caption>Example 1: retrieve the entire configuration object</caption>\n         *\n         * var config = mixer.getConfig(); // Config { ... }\n         *\n         * @example <caption>Example 2: retrieve a named sub-object of configuration object</caption>\n         *\n         * var animation = mixer.getConfig('animation'); // ConfigAnimation { ... }\n         *\n         * @example <caption>Example 3: retrieve a value of configuration object via a dot-notation string key</caption>\n         *\n         * var effects = mixer.getConfig('animation.effects'); // 'fade scale'\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @param       {string}    [stringKey]    A \"dot-notation\" string key\n         * @return      {*}\n         */\n\n        getConfig: function(stringKey) {\n            var self    = this,\n                value   = null;\n\n            if (!stringKey) {\n                value = self.config;\n            } else {\n                value = h.getProperty(self.config, stringKey);\n            }\n\n            return self.callFilters('valueGetConfig', value, arguments);\n        },\n\n        /**\n         * Updates the configuration of the mixer, after it has been instantiated.\n         *\n         * See the Configuration Object documentation for a full list of avilable\n         * configuration options.\n         *\n         * @example\n         *\n         * .configure(config)\n         *\n         * @example <caption>Example 1: Updating animation options</caption>\n         *\n         * mixer.configure({\n         *     animation: {\n         *         effects: 'fade translateX(-100%)',\n         *         duration: 300\n         *     }\n         * });\n         *\n         * @example <caption>Example 2: Removing a callback after it has been set</caption>\n         *\n         * var mixer;\n         *\n         * function handleMixEndOnce() {\n         *     // Do something ..\n         *\n         *     // Then nullify the callback\n         *\n         *     mixer.configure({\n         *         callbacks: {\n         *             onMixEnd: null\n         *         }\n         *     });\n         * };\n         *\n         * // Instantiate a mixer with a callback defined\n         *\n         * mixer = mixitup(containerEl, {\n         *     callbacks: {\n         *         onMixEnd: handleMixEndOnce\n         *     }\n         * });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {object}    config\n         *      An object containing one of more configuration options.\n         * @return      {void}\n         */\n\n        configure: function(config) {\n            var self = this;\n\n            self.callActions('beforeConfigure', arguments);\n\n            h.extend(self.config, config, true, true);\n\n            self.callActions('afterConfigure', arguments);\n        },\n\n        /**\n         * Returns an object containing information about the current state of the\n         * mixer. See the State Object documentation for more information.\n         *\n         * NB: State objects are immutable and should therefore be regenerated\n         * after any operation.\n         *\n         * @example\n         *\n         * .getState();\n         *\n         * @example <caption>Example: Retrieving a state object</caption>\n         *\n         * var state = mixer.getState();\n         *\n         * console.log(state.totalShow + 'targets are currently shown');\n         *\n         * @public\n         * @instance\n         * @since       2.0.0\n         * @return      {mixitup.State} An object reflecting the current state of the mixer.\n         */\n\n        getState: function() {\n            var self    = this,\n                state   = null;\n\n            state = new mixitup.State();\n\n            h.extend(state, self.state);\n\n            h.freeze(state);\n\n            return self.callFilters('stateGetState', state, arguments);\n        },\n\n        /**\n         * Forces the re-indexing all targets within the container.\n         *\n         * This should only be used if some other piece of code in your application\n         * has manipulated the contents of your container, which should be avoided.\n         *\n         * If you need to add or remove target elements from the container, use\n         * the built-in `.insert()` or `.remove()` methods, and MixItUp will keep\n         * itself up to date.\n         *\n         * @example\n         *\n         * .forceRefresh()\n         *\n         * @example <caption>Example: Force refreshing the mixer after external DOM manipulation</caption>\n         *\n         * console.log(mixer.getState().totalShow); // 3\n         *\n         * // An element is removed from the container via some external DOM manipulation code:\n         *\n         * containerEl.removeChild(containerEl.firstElementChild);\n         *\n         * // The mixer does not know that the number of targets has changed:\n         *\n         * console.log(mixer.getState().totalShow); // 3\n         *\n         * mixer.forceRefresh();\n         *\n         * // After forceRefresh, the mixer is in sync again:\n         *\n         * console.log(mixer.getState().totalShow); // 2\n         *\n         * @public\n         * @instance\n         * @since 2.1.2\n         * @return {void}\n         */\n\n        forceRefresh: function() {\n            var self = this;\n\n            self.indexTargets();\n        },\n\n        /**\n         * Forces the re-rendering of all targets when using the Dataset API.\n         *\n         * By default, targets are only re-rendered when `data.dirtyCheck` is\n         * enabled, and an item's data has changed when `dataset()` is called.\n         *\n         * The `forceRender()` method allows for the re-rendering of all targets\n         * in response to some arbitrary event, such as the changing of the target\n         * render function.\n         *\n         * Targets are rendered against their existing data.\n         *\n         * @example\n         *\n         * .forceRender()\n         *\n         * @example <caption>Example: Force render targets after changing the target render function</caption>\n         *\n         * console.log(container.innerHTML); // ... &lt;span class=\"mix\"&gt;Foo&lt;/span&gt; ...\n         *\n         * mixer.configure({\n         *     render: {\n         *         target: (item) => `&lt;a href=\"/${item.slug}/\" class=\"mix\"&gt;${item.title}&lt;/a&gt;`\n         *     }\n         * });\n         *\n         * mixer.forceRender();\n         *\n         * console.log(container.innerHTML); // ... &lt;a href=\"/foo/\" class=\"mix\"&gt;Foo&lt;/a&gt; ...\n         *\n         * @public\n         * @instance\n         * @since 3.2.1\n         * @return {void}\n         */\n\n        forceRender: function() {\n            var self    = this,\n                target  = null,\n                el      = null,\n                id      = '';\n\n            for (id in self.cache) {\n                target = self.cache[id];\n\n                el = target.render(target.data);\n\n                if (el !== target.dom.el) {\n                    // Update target element reference\n\n                    if (target.isInDom) {\n                        target.unbindEvents();\n\n                        self.dom.parent.replaceChild(el, target.dom.el);\n                    }\n\n                    if (!target.isShown) {\n                        el.style.display = 'none';\n                    }\n\n                    target.dom.el = el;\n\n                    if (target.isInDom) {\n                        target.bindEvents();\n                    }\n                }\n            }\n\n            self.state = self.buildState(self.lastOperation);\n        },\n\n        /**\n         * Removes mixitup functionality from the container, unbinds all control\n         * event handlers, and deletes the mixer instance from MixItUp's internal\n         * cache.\n         *\n         * This should be performed whenever a mixer's container is removed from\n         * the DOM, such as during a page change in a single page application,\n         * or React's `componentWillUnmount()`.\n         *\n         * @example\n         *\n         * .destroy([cleanUp])\n         *\n         * @example <caption>Example: Destroying the mixer before removing its container element</caption>\n         *\n         * mixer.destroy();\n         *\n         * containerEl.parentElement.removeChild(containerEl);\n         *\n         * @public\n         * @instance\n         * @since   2.0.0\n         * @param   {boolean}   [cleanUp=false]\n         *     An optional boolean dictating whether or not to clean up any inline `display: none;` styling applied to hidden targets.\n         * @return  {void}\n         */\n\n        destroy: function(cleanUp) {\n            var self    = this,\n                control = null,\n                target  = null,\n                i       = 0;\n\n            self.callActions('beforeDestroy', arguments);\n\n            for (i = 0; control = self.controls[i]; i++) {\n                control.removeBinding(self);\n            }\n\n            for (i = 0; target = self.targets[i]; i++) {\n                if (cleanUp) {\n                    target.show();\n                }\n\n                target.unbindEvents();\n            }\n\n            if (self.dom.container.id.match(/^MixItUp/)) {\n                self.dom.container.removeAttribute('id');\n            }\n\n            delete mixitup.instances[self.id];\n\n            self.callActions('afterDestroy', arguments);\n        }\n    });\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.IMoveData = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.posIn          = null;\n        this.posOut         = null;\n        this.operation      = null;\n        this.callback       = null;\n        this.statusChange   = '';\n        this.duration       = -1;\n        this.staggerIndex   = -1;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.IMoveData);\n\n    mixitup.IMoveData.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.IMoveData.prototype.constructor = mixitup.IMoveData;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.TargetDom = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.el = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.TargetDom);\n\n    mixitup.TargetDom.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.TargetDom.prototype.constructor = mixitup.TargetDom;\n\n    /**\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Target = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.id         = '';\n        this.sortString = '';\n        this.mixer      = null;\n        this.callback   = null;\n        this.isShown    = false;\n        this.isBound    = false;\n        this.isExcluded = false;\n        this.isInDom    = false;\n        this.handler    = null;\n        this.operation  = null;\n        this.data       = null;\n        this.dom        = new mixitup.TargetDom();\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Target);\n\n    mixitup.Target.prototype = Object.create(mixitup.Base.prototype);\n\n    h.extend(mixitup.Target.prototype, {\n        constructor: mixitup.Target,\n\n        /**\n         * Initialises a newly instantiated Target.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {(Element|null)}    el\n         * @param   {object}            mixer\n         * @param   {object}            [data]\n         * @return  {void}\n         */\n\n        init: function(el, mixer, data) {\n            var self = this,\n                id   = '';\n\n            self.callActions('beforeInit', arguments);\n\n            self.mixer = mixer;\n\n            if (!el) {\n                // If no element is provided, render it\n\n                el = self.render(data);\n            }\n\n            self.cacheDom(el);\n\n            self.bindEvents();\n\n            if (self.dom.el.style.display !== 'none') {\n                self.isShown = true;\n            }\n\n            if (data && mixer.config.data.uidKey) {\n                if (typeof (id = data[mixer.config.data.uidKey]) === 'undefined' || id.toString().length < 1) {\n                    throw new TypeError(mixitup.messages.errorDatasetInvalidUidKey({\n                        uidKey: mixer.config.data.uidKey\n                    }));\n                }\n\n                self.id     = id;\n                self.data   = data;\n\n                mixer.cache[id] = self;\n            }\n\n            self.callActions('afterInit', arguments);\n        },\n\n        /**\n         * Renders the target element using a user-defined renderer function.\n         *\n         * @private\n         * @instance\n         * @since   3.1.4\n         * @param   {object} data\n         * @return  {void}\n         */\n\n        render: function(data) {\n            var self    = this,\n                render  = null,\n                el      = null,\n                temp    = null,\n                output  = '';\n\n            self.callActions('beforeRender', arguments);\n\n            render = self.callFilters('renderRender', self.mixer.config.render.target, arguments);\n\n            if (typeof render !== 'function') {\n                throw new TypeError(mixitup.messages.errorDatasetRendererNotSet());\n            }\n\n            output = render(data);\n\n            if (output && typeof output === 'object' && h.isElement(output)) {\n                el = output;\n            } else if (typeof output === 'string') {\n                temp = document.createElement('div');\n                temp.innerHTML = output;\n\n                el = temp.firstElementChild;\n            }\n\n            return self.callFilters('elRender', el, arguments);\n        },\n\n        /**\n         * Caches references of DOM elements neccessary for the target's functionality.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Element} el\n         * @return  {void}\n         */\n\n        cacheDom: function(el) {\n            var self = this;\n\n            self.callActions('beforeCacheDom', arguments);\n\n            self.dom.el = el;\n\n            self.callActions('afterCacheDom', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {string}    attributeName\n         * @return  {void}\n         */\n\n        getSortString: function(attributeName) {\n            var self    = this,\n                value   = self.dom.el.getAttribute('data-' + attributeName) || '';\n\n            self.callActions('beforeGetSortString', arguments);\n\n            value = isNaN(value * 1) ?\n                value.toLowerCase() :\n                value * 1;\n\n            self.sortString = value;\n\n            self.callActions('afterGetSortString', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {void}\n         */\n\n        show: function() {\n            var self = this;\n\n            self.callActions('beforeShow', arguments);\n\n            if (!self.isShown) {\n                self.dom.el.style.display = '';\n\n                self.isShown = true;\n            }\n\n            self.callActions('afterShow', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {void}\n         */\n\n        hide: function() {\n            var self = this;\n\n            self.callActions('beforeHide', arguments);\n\n            if (self.isShown) {\n                self.dom.el.style.display = 'none';\n\n                self.isShown = false;\n            }\n\n            self.callActions('afterHide', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {mixitup.IMoveData} moveData\n         * @return  {void}\n         */\n\n        move: function(moveData) {\n            var self = this;\n\n            self.callActions('beforeMove', arguments);\n\n            if (!self.isExcluded) {\n                self.mixer.targetsMoved++;\n            }\n\n            self.applyStylesIn(moveData);\n\n            requestAnimationFrame(function() {\n                self.applyStylesOut(moveData);\n            });\n\n            self.callActions('afterMove', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {object}    posData\n         * @param   {number}    multiplier\n         * @return  {void}\n         */\n\n        applyTween: function(posData, multiplier) {\n            var self                    = this,\n                propertyName            = '',\n                tweenData               = null,\n                posIn                   = posData.posIn,\n                currentTransformValues  = [],\n                currentValues           = new mixitup.StyleData(),\n                i                       = -1;\n\n            self.callActions('beforeApplyTween', arguments);\n\n            currentValues.x     = posIn.x;\n            currentValues.y     = posIn.y;\n\n            if (multiplier === 0) {\n                self.hide();\n            } else if (!self.isShown) {\n                self.show();\n            }\n\n            for (i = 0; propertyName = mixitup.features.TWEENABLE[i]; i++) {\n                tweenData = posData.tweenData[propertyName];\n\n                if (propertyName === 'x') {\n                    if (!tweenData) continue;\n\n                    currentValues.x = posIn.x + (tweenData * multiplier);\n                } else if (propertyName === 'y') {\n                    if (!tweenData) continue;\n\n                    currentValues.y = posIn.y + (tweenData * multiplier);\n                } else if (tweenData instanceof mixitup.TransformData) {\n                    if (!tweenData.value) continue;\n\n                    currentValues[propertyName].value =\n                        posIn[propertyName].value + (tweenData.value * multiplier);\n\n                    currentValues[propertyName].unit  = tweenData.unit;\n\n                    currentTransformValues.push(\n                        propertyName + '(' + currentValues[propertyName].value + tweenData.unit + ')'\n                    );\n                } else {\n                    if (!tweenData) continue;\n\n                    currentValues[propertyName] = posIn[propertyName] + (tweenData * multiplier);\n\n                    self.dom.el.style[propertyName] = currentValues[propertyName];\n                }\n            }\n\n            if (currentValues.x || currentValues.y) {\n                currentTransformValues.unshift('translate(' + currentValues.x + 'px, ' + currentValues.y + 'px)');\n            }\n\n            if (currentTransformValues.length) {\n                self.dom.el.style[mixitup.features.transformProp] = currentTransformValues.join(' ');\n            }\n\n            self.callActions('afterApplyTween', arguments);\n        },\n\n        /**\n         * Applies the initial styling to a target element before any transition\n         * is applied.\n         *\n         * @private\n         * @instance\n         * @param   {mixitup.IMoveData} moveData\n         * @return  {void}\n         */\n\n        applyStylesIn: function(moveData) {\n            var self            = this,\n                posIn           = moveData.posIn,\n                isFading        = self.mixer.effectsIn.opacity !== 1,\n                transformValues = [];\n\n            self.callActions('beforeApplyStylesIn', arguments);\n\n            transformValues.push('translate(' + posIn.x + 'px, ' + posIn.y + 'px)');\n\n            if (self.mixer.config.animation.animateResizeTargets) {\n                if (moveData.statusChange !== 'show') {\n                    // Don't apply posIn width or height or showing, as will be 0\n\n                    self.dom.el.style.width  = posIn.width + 'px';\n                    self.dom.el.style.height = posIn.height + 'px';\n                }\n\n                self.dom.el.style.marginRight  = posIn.marginRight + 'px';\n                self.dom.el.style.marginBottom = posIn.marginBottom + 'px';\n            }\n\n            isFading && (self.dom.el.style.opacity = posIn.opacity);\n\n            if (moveData.statusChange === 'show') {\n                transformValues = transformValues.concat(self.mixer.transformIn);\n            }\n\n            self.dom.el.style[mixitup.features.transformProp] = transformValues.join(' ');\n\n            self.callActions('afterApplyStylesIn', arguments);\n        },\n\n        /**\n         * Applies a transition followed by the final styles for the element to\n         * transition towards.\n         *\n         * @private\n         * @instance\n         * @param   {mixitup.IMoveData} moveData\n         * @return  {void}\n         */\n\n        applyStylesOut: function(moveData) {\n            var self            = this,\n                transitionRules = [],\n                transformValues = [],\n                isResizing      = self.mixer.config.animation.animateResizeTargets,\n                isFading        = typeof self.mixer.effectsIn.opacity !== 'undefined';\n\n            self.callActions('beforeApplyStylesOut', arguments);\n\n            // Build the transition rules\n\n            transitionRules.push(self.writeTransitionRule(\n                mixitup.features.transformRule,\n                moveData.staggerIndex\n            ));\n\n            if (moveData.statusChange !== 'none') {\n                transitionRules.push(self.writeTransitionRule(\n                    'opacity',\n                    moveData.staggerIndex,\n                    moveData.duration\n                ));\n            }\n\n            if (isResizing) {\n                transitionRules.push(self.writeTransitionRule(\n                    'width',\n                    moveData.staggerIndex,\n                    moveData.duration\n                ));\n\n                transitionRules.push(self.writeTransitionRule(\n                    'height',\n                    moveData.staggerIndex,\n                    moveData.duration\n                ));\n\n                transitionRules.push(self.writeTransitionRule(\n                    'margin',\n                    moveData.staggerIndex,\n                    moveData.duration\n                ));\n            }\n\n            // If no callback was provided, the element will\n            // not transition in any way so tag it as \"immovable\"\n\n            if (!moveData.callback) {\n                self.mixer.targetsImmovable++;\n\n                if (self.mixer.targetsMoved === self.mixer.targetsImmovable) {\n                    // If the total targets moved is equal to the\n                    // number of immovable targets, the operation\n                    // should be considered finished\n\n                    self.mixer.cleanUp(moveData.operation);\n                }\n\n                return;\n            }\n\n            // If the target will transition in some fasion,\n            // assign a callback function\n\n            self.operation = moveData.operation;\n            self.callback = moveData.callback;\n\n            // As long as the target is not excluded, increment\n            // the total number of targets bound\n\n            !self.isExcluded && self.mixer.targetsBound++;\n\n            // Tag the target as bound to differentiate from transitionEnd\n            // events that may come from stylesheet driven effects\n\n            self.isBound = true;\n\n            // Apply the transition\n\n            self.applyTransition(transitionRules);\n\n            // Apply width, height and margin negation\n\n            if (isResizing && moveData.posOut.width > 0 && moveData.posOut.height > 0) {\n                self.dom.el.style.width        = moveData.posOut.width + 'px';\n                self.dom.el.style.height       = moveData.posOut.height + 'px';\n                self.dom.el.style.marginRight  = moveData.posOut.marginRight + 'px';\n                self.dom.el.style.marginBottom = moveData.posOut.marginBottom + 'px';\n            }\n\n            if (!self.mixer.config.animation.nudge && moveData.statusChange === 'hide') {\n                // If we're not nudging, the translation should be\n                // applied before any other transforms to prevent\n                // lateral movement\n\n                transformValues.push('translate(' + moveData.posOut.x + 'px, ' + moveData.posOut.y + 'px)');\n            }\n\n            // Apply fade\n\n            switch (moveData.statusChange) {\n                case 'hide':\n                    isFading && (self.dom.el.style.opacity = self.mixer.effectsOut.opacity);\n\n                    transformValues = transformValues.concat(self.mixer.transformOut);\n\n                    break;\n                case 'show':\n                    isFading && (self.dom.el.style.opacity = 1);\n            }\n\n            if (\n                self.mixer.config.animation.nudge ||\n                (!self.mixer.config.animation.nudge && moveData.statusChange !== 'hide')\n            ) {\n                // Opposite of above - apply translate after\n                // other transform\n\n                transformValues.push('translate(' + moveData.posOut.x + 'px, ' + moveData.posOut.y + 'px)');\n            }\n\n            // Apply transforms\n\n            self.dom.el.style[mixitup.features.transformProp] = transformValues.join(' ');\n\n            self.callActions('afterApplyStylesOut', arguments);\n        },\n\n        /**\n         * Combines the name of a CSS property with the appropriate duration and delay\n         * values to created a valid transition rule.\n         *\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {string}    property\n         * @param   {number}    staggerIndex\n         * @param   {number}    duration\n         * @return  {string}\n         */\n\n        writeTransitionRule: function(property, staggerIndex, duration) {\n            var self  = this,\n                delay = self.getDelay(staggerIndex),\n                rule  = '';\n\n            rule = property + ' ' +\n                (duration > 0 ? duration : self.mixer.config.animation.duration) + 'ms ' +\n                delay + 'ms ' +\n                (property === 'opacity' ? 'linear' : self.mixer.config.animation.easing);\n\n            return self.callFilters('ruleWriteTransitionRule', rule, arguments);\n        },\n\n        /**\n         * Calculates the transition delay for each target element based on its index, if\n         * staggering is applied. If defined, A custom `animation.staggerSeqeuence`\n         * function can be used to manipulate the order of indices to produce custom\n         * stagger effects (e.g. for use in a grid with irregular row lengths).\n         *\n         * @private\n         * @instance\n         * @since   2.0.0\n         * @param   {number}    index\n         * @return  {number}\n         */\n\n        getDelay: function(index) {\n            var self    = this,\n                delay   = -1;\n\n            if (typeof self.mixer.config.animation.staggerSequence === 'function') {\n                index = self.mixer.config.animation.staggerSequence.call(self, index, self.state);\n            }\n\n            delay = !!self.mixer.staggerDuration ? index * self.mixer.staggerDuration : 0;\n\n            return self.callFilters('delayGetDelay', delay, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {string[]}  rules\n         * @return  {void}\n         */\n\n        applyTransition: function(rules) {\n            var self                = this,\n                transitionString    = rules.join(', ');\n\n            self.callActions('beforeApplyTransition', arguments);\n\n            self.dom.el.style[mixitup.features.transitionProp] = transitionString;\n\n            self.callActions('afterApplyTransition', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Event} e\n         * @return  {void}\n         */\n\n        handleTransitionEnd: function(e) {\n            var self        = this,\n                propName    = e.propertyName,\n                canResize   = self.mixer.config.animation.animateResizeTargets;\n\n            self.callActions('beforeHandleTransitionEnd', arguments);\n\n            if (\n                self.isBound &&\n                e.target.matches(self.mixer.config.selectors.target) &&\n                (\n                    propName.indexOf('transform') > -1 ||\n                    propName.indexOf('opacity') > -1 ||\n                    canResize && propName.indexOf('height') > -1 ||\n                    canResize && propName.indexOf('width') > -1 ||\n                    canResize && propName.indexOf('margin') > -1\n                )\n            ) {\n                self.callback.call(self, self.operation);\n\n                self.isBound = false;\n                self.callback = null;\n                self.operation = null;\n            }\n\n            self.callActions('afterHandleTransitionEnd', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {Event}     e\n         * @return  {void}\n         */\n\n        eventBus: function(e) {\n            var self = this;\n\n            self.callActions('beforeEventBus', arguments);\n\n            switch (e.type) {\n                case 'webkitTransitionEnd':\n                case 'transitionend':\n                    self.handleTransitionEnd(e);\n            }\n\n            self.callActions('afterEventBus', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {void}\n         */\n\n        unbindEvents: function() {\n            var self = this;\n\n            self.callActions('beforeUnbindEvents', arguments);\n\n            h.off(self.dom.el, 'webkitTransitionEnd', self.handler);\n            h.off(self.dom.el, 'transitionend', self.handler);\n\n            self.callActions('afterUnbindEvents', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @return  {void}\n         */\n\n        bindEvents: function() {\n            var self                = this,\n                transitionEndEvent  = '';\n\n            self.callActions('beforeBindEvents', arguments);\n\n            transitionEndEvent = mixitup.features.transitionPrefix === 'webkit' ? 'webkitTransitionEnd' : 'transitionend';\n\n            self.handler = function(e) {\n                return self.eventBus(e);\n            };\n\n            h.on(self.dom.el, transitionEndEvent, self.handler);\n\n            self.callActions('afterBindEvents', arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since   3.0.0\n         * @param   {boolean}   [getBox]\n         * @return  {PosData}\n         */\n\n        getPosData: function(getBox) {\n            var self    = this,\n                styles  = {},\n                rect    = null,\n                posData = new mixitup.StyleData();\n\n            self.callActions('beforeGetPosData', arguments);\n\n            posData.x = self.dom.el.offsetLeft;\n            posData.y = self.dom.el.offsetTop;\n\n            if (self.mixer.config.animation.animateResizeTargets || getBox) {\n                rect = self.dom.el.getBoundingClientRect();\n\n                posData.top     = rect.top;\n                posData.right   = rect.right;\n                posData.bottom  = rect.bottom;\n                posData.left    = rect.left;\n\n                posData.width  = rect.width;\n                posData.height = rect.height;\n            }\n\n            if (self.mixer.config.animation.animateResizeTargets) {\n                styles = window.getComputedStyle(self.dom.el);\n\n                posData.marginBottom = parseFloat(styles.marginBottom);\n                posData.marginRight  = parseFloat(styles.marginRight);\n            }\n\n            return self.callFilters('posDataGetPosData', posData, arguments);\n        },\n\n        /**\n         * @private\n         * @instance\n         * @since       3.0.0\n         * @return      {void}\n         */\n\n        cleanUp: function() {\n            var self = this;\n\n            self.callActions('beforeCleanUp', arguments);\n\n            self.dom.el.style[mixitup.features.transformProp]  = '';\n            self.dom.el.style[mixitup.features.transitionProp] = '';\n            self.dom.el.style.opacity                          = '';\n\n            if (self.mixer.config.animation.animateResizeTargets) {\n                self.dom.el.style.width        = '';\n                self.dom.el.style.height       = '';\n                self.dom.el.style.marginRight  = '';\n                self.dom.el.style.marginBottom = '';\n            }\n\n            self.callActions('afterCleanUp', arguments);\n        }\n    });\n\n    /**\n     * A jQuery-collection-like wrapper around one or more `mixitup.Mixer` instances\n     * allowing simultaneous control of said instances similar to the MixItUp 2 API.\n     *\n     * @example\n     * new mixitup.Collection(instances)\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     * @param       {mixitup.Mixer[]}   instances\n     */\n\n    mixitup.Collection = function(instances) {\n        var instance    = null,\n            i           = -1;\n\n        this.callActions('beforeConstruct');\n\n        for (i = 0; instance = instances[i]; i++) {\n            this[i] = instance;\n        }\n\n        this.length = instances.length;\n\n        this.callActions('afterConstruct');\n\n        h.freeze(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Collection);\n\n    mixitup.Collection.prototype = Object.create(mixitup.Base.prototype);\n\n    h.extend(mixitup.Collection.prototype,\n    /** @lends mixitup.Collection */\n    {\n        constructor: mixitup.Collection,\n\n        /**\n         * Calls a method on all instances in the collection by passing the method\n         * name as a string followed by any applicable parameters to be curried into\n         * to the method.\n         *\n         * @example\n         * .mixitup(methodName[,arg1][,arg2..]);\n         *\n         * @example\n         * var collection = new Collection([mixer1, mixer2]);\n         *\n         * return collection.mixitup('filter', '.category-a')\n         *     .then(function(states) {\n         *         state.forEach(function(state) {\n         *             console.log(state.activeFilter.selector); // .category-a\n         *         });\n         *     });\n         *\n         * @public\n         * @instance\n         * @since       3.0.0\n         * @param       {string}  methodName\n         * @return      {Promise<Array<mixitup.State>>}\n         */\n\n        mixitup: function(methodName) {\n            var self        = this,\n                instance    = null,\n                args        = Array.prototype.slice.call(arguments),\n                tasks       = [],\n                i           = -1;\n\n            this.callActions('beforeMixitup');\n\n            args.shift();\n\n            for (i = 0; instance = self[i]; i++) {\n                tasks.push(instance[methodName].apply(instance, args));\n            }\n\n            return self.callFilters('promiseMixitup', h.all(tasks, mixitup.libraries), arguments);\n        }\n    });\n\n    /**\n     * `mixitup.Operation` objects contain all data neccessary to describe the full\n     * lifecycle of any MixItUp operation. They can be used to compute and store an\n     * operation for use at a later time (e.g. programmatic tweening).\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Operation = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.id                      = '';\n\n        this.args                    = [];\n        this.command                 = null;\n        this.showPosData             = [];\n        this.toHidePosData           = [];\n\n        this.startState              = null;\n        this.newState                = null;\n        this.docState                = null;\n\n        this.willSort                = false;\n        this.willChangeLayout        = false;\n        this.hasEffect               = false;\n        this.hasFailed               = false;\n\n        this.triggerElement          = null;\n\n        this.show                    = [];\n        this.hide                    = [];\n        this.matching                = [];\n        this.toShow                  = [];\n        this.toHide                  = [];\n        this.toMove                  = [];\n        this.toRemove                = [];\n        this.startOrder              = [];\n        this.newOrder                = [];\n        this.startSort               = null;\n        this.newSort                 = null;\n        this.startFilter             = null;\n        this.newFilter               = null;\n        this.startDataset            = null;\n        this.newDataset              = null;\n        this.viewportDeltaX          = 0;\n        this.viewportDeltaY          = 0;\n        this.startX                  = 0;\n        this.startY                  = 0;\n        this.startHeight             = 0;\n        this.startWidth              = 0;\n        this.newX                    = 0;\n        this.newY                    = 0;\n        this.newHeight               = 0;\n        this.newWidth                = 0;\n        this.startContainerClassName = '';\n        this.startDisplay            = '';\n        this.newContainerClassName   = '';\n        this.newDisplay              = '';\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Operation);\n\n    mixitup.Operation.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.Operation.prototype.constructor = mixitup.Operation;\n\n    /**\n     * `mixitup.State` objects expose various pieces of data detailing the state of\n     * a MixItUp instance. They are provided at the start and end of any operation via\n     * callbacks and events, with the most recent state stored between operations\n     * for retrieval at any time via the API.\n     *\n     * @constructor\n     * @namespace\n     * @memberof    mixitup\n     * @public\n     * @since       3.0.0\n     */\n\n    mixitup.State = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /**\n         * The ID of the mixer instance.\n         *\n         * @name        id\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {string}\n         * @default     ''\n         */\n\n        this.id = '';\n\n        /**\n         * The currently active filter command as set by a control click or API call.\n         *\n         * @name        activeFilter\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {mixitup.CommandFilter}\n         * @default     null\n         */\n\n        this.activeFilter = null;\n\n        /**\n         * The currently active sort command as set by a control click or API call.\n         *\n         * @name        activeSort\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {mixitup.CommandSort}\n         * @default     null\n         */\n\n        this.activeSort = null;\n\n        /**\n         * The current layout-specific container class name, if applied.\n         *\n         * @name        activeContainerClassName\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {string}\n         * @default     ''\n         */\n\n        this.activeContainerClassName = '';\n\n        /**\n         * A reference to the container element that the mixer is instantiated on.\n         *\n         * @name        container\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Element}\n         * @default     null\n         */\n\n        this.container = null;\n\n        /**\n         * An array of all target elements indexed by the mixer.\n         *\n         * @name        targets\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Array.<Element>}\n         * @default     []\n         */\n\n        this.targets = [];\n\n        /**\n         * An array of all target elements not matching the current filter.\n         *\n         * @name        hide\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Array.<Element>}\n         * @default     []\n         */\n\n        this.hide = [];\n\n        /**\n         * An array of all target elements matching the current filter and any additional\n         * limits applied such as pagination.\n         *\n         * @name        show\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Array.<Element>}\n         * @default     []\n         */\n\n        this.show = [];\n\n        /**\n         * An array of all target elements matching the current filter irrespective of\n         * any additional limits applied such as pagination.\n         *\n         * @name        matching\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Array.<Element>}\n         * @default     []\n         */\n\n        this.matching = [];\n\n        /**\n         * An integer representing the total number of target elements indexed by the\n         * mixer. Equivalent to `state.targets.length`.\n         *\n         * @name        totalTargets\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {number}\n         * @default     -1\n         */\n\n        this.totalTargets = -1;\n\n        /**\n         * An integer representing the total number of target elements matching the\n         * current filter and any additional limits applied such as pagination.\n         * Equivalent to `state.show.length`.\n         *\n         * @name        totalShow\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {number}\n         * @default     -1\n         */\n\n        this.totalShow = -1;\n\n        /**\n         * An integer representing the total number of target elements not matching\n         * the current filter. Equivalent to `state.hide.length`.\n         *\n         * @name        totalHide\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {number}\n         * @default     -1\n         */\n\n        this.totalHide = -1;\n\n        /**\n         * An integer representing the total number of target elements matching the\n         * current filter irrespective of any other limits applied such as pagination.\n         * Equivalent to `state.matching.length`.\n         *\n         * @name        totalMatching\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {number}\n         * @default     -1\n         */\n\n        this.totalMatching = -1;\n\n        /**\n         * A boolean indicating whether the last operation \"failed\", i.e. no targets\n         * could be found matching the filter.\n         *\n         * @name        hasFailed\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {boolean}\n         * @default     false\n         */\n\n        this.hasFailed = false;\n\n        /**\n         * The DOM element that was clicked if the last operation was triggered by the\n         * clicking of a control and not an API call.\n         *\n         * @name        triggerElement\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Element|null}\n         * @default     null\n         */\n\n        this.triggerElement = null;\n\n        /**\n         * The currently active dataset underlying the rendered targets, if the\n         * dataset API is in use.\n         *\n         * @name        activeDataset\n         * @memberof    mixitup.State\n         * @instance\n         * @type        {Array.<object>}\n         * @default     null\n         */\n\n        this.activeDataset = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.State);\n\n    mixitup.State.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.State.prototype.constructor = mixitup.State;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.UserInstruction = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        this.command    = {};\n        this.animate    = false;\n        this.callback   = null;\n\n        this.callActions('afterConstruct');\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.UserInstruction);\n\n    mixitup.UserInstruction.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.UserInstruction.prototype.constructor = mixitup.UserInstruction;\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     */\n\n    mixitup.Messages = function() {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct');\n\n        /* Errors\n        ----------------------------------------------------------------------------- */\n\n        this.ERROR_FACTORY_INVALID_CONTAINER =\n            '[MixItUp] An invalid selector or element reference was passed to the mixitup factory function';\n\n        this.ERROR_FACTORY_CONTAINER_NOT_FOUND =\n            '[MixItUp] The provided selector yielded no container element';\n\n        this.ERROR_CONFIG_INVALID_ANIMATION_EFFECTS =\n            '[MixItUp] Invalid value for `animation.effects`';\n\n        this.ERROR_CONFIG_INVALID_CONTROLS_SCOPE =\n            '[MixItUp] Invalid value for `controls.scope`';\n\n        this.ERROR_CONFIG_INVALID_PROPERTY =\n            '[MixitUp] Invalid configuration object property \"${erroneous}\"${suggestion}';\n\n        this.ERROR_CONFIG_INVALID_PROPERTY_SUGGESTION =\n            '. Did you mean \"${probableMatch}\"?';\n\n        this.ERROR_CONFIG_DATA_UID_KEY_NOT_SET =\n            '[MixItUp] To use the dataset API, a UID key must be specified using `data.uidKey`';\n\n        this.ERROR_DATASET_INVALID_UID_KEY =\n            '[MixItUp] The specified UID key \"${uidKey}\" is not present on one or more dataset items';\n\n        this.ERROR_DATASET_DUPLICATE_UID =\n            '[MixItUp] The UID \"${uid}\" was found on two or more dataset items. UIDs must be unique.';\n\n        this.ERROR_INSERT_INVALID_ARGUMENTS =\n            '[MixItUp] Please provider either an index or a sibling and position to insert, not both';\n\n        this.ERROR_INSERT_PREEXISTING_ELEMENT =\n            '[MixItUp] An element to be inserted already exists in the container';\n\n        this.ERROR_FILTER_INVALID_ARGUMENTS =\n            '[MixItUp] Please provide either a selector or collection `.filter()`, not both';\n\n        this.ERROR_DATASET_NOT_SET =\n            '[MixItUp] To use the dataset API with pre-rendered targets, a starting dataset must be set using `load.dataset`';\n\n        this.ERROR_DATASET_PRERENDERED_MISMATCH =\n            '[MixItUp] `load.dataset` does not match pre-rendered targets';\n\n        this.ERROR_DATASET_RENDERER_NOT_SET =\n            '[MixItUp] To insert an element via the dataset API, a target renderer function must be provided to `render.target`';\n\n        this.ERROR_SORT_NON_EXISTENT_ELEMENT =\n            '[MixItUp] An element to be sorted does not already exist in the container';\n\n        /* Warnings\n        ----------------------------------------------------------------------------- */\n\n        this.WARNING_FACTORY_PREEXISTING_INSTANCE =\n            '[MixItUp] WARNING: This element already has an active MixItUp instance. The provided configuration object will be ignored.' +\n            ' If you wish to perform additional methods on this instance, please create a reference.';\n\n        this.WARNING_INSERT_NO_ELEMENTS =\n            '[MixItUp] WARNING: No valid elements were passed to `.insert()`';\n\n        this.WARNING_REMOVE_NO_ELEMENTS =\n            '[MixItUp] WARNING: No valid elements were passed to `.remove()`';\n\n        this.WARNING_MULTIMIX_INSTANCE_QUEUE_FULL =\n            '[MixItUp] WARNING: An operation was requested but the MixItUp instance was busy. The operation was rejected because the ' +\n            'queue is full or queuing is disabled.';\n\n        this.WARNING_GET_OPERATION_INSTANCE_BUSY =\n            '[MixItUp] WARNING: Operations can be be created while the MixItUp instance is busy.';\n\n        this.WARNING_NO_PROMISE_IMPLEMENTATION =\n            '[MixItUp] WARNING: No Promise implementations could be found. If you wish to use promises with MixItUp please install' +\n            ' an ES6 Promise polyfill.';\n\n        this.WARNING_INCONSISTENT_SORTING_ATTRIBUTES =\n            '[MixItUp] WARNING: The requested sorting data attribute \"${attribute}\" was not present on one or more target elements' +\n            ' which may product unexpected sort output';\n\n        this.callActions('afterConstruct');\n\n        this.compileTemplates();\n\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Messages);\n\n    mixitup.Messages.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.Messages.prototype.constructor = mixitup.Messages;\n\n    /**\n     * @return {void}\n     */\n\n    mixitup.Messages.prototype.compileTemplates = function() {\n        var errorKey        = '';\n        var errorMessage    = '';\n\n        for (errorKey in this) {\n            if (typeof (errorMessage = this[errorKey]) !== 'string') continue;\n\n            this[h.camelCase(errorKey)] = h.template(errorMessage);\n        }\n    };\n\n    mixitup.messages = new mixitup.Messages();\n\n    /**\n     * @constructor\n     * @memberof    mixitup\n     * @private\n     * @since       3.0.0\n     * @param       {mixitup.Mixer} mixer\n     */\n\n    mixitup.Facade = function Mixer(mixer) {\n        mixitup.Base.call(this);\n\n        this.callActions('beforeConstruct', arguments);\n\n        this.configure          = mixer.configure.bind(mixer);\n        this.show               = mixer.show.bind(mixer);\n        this.hide               = mixer.hide.bind(mixer);\n        this.filter             = mixer.filter.bind(mixer);\n        this.toggleOn           = mixer.toggleOn.bind(mixer);\n        this.toggleOff          = mixer.toggleOff.bind(mixer);\n        this.sort               = mixer.sort.bind(mixer);\n        this.changeLayout       = mixer.changeLayout.bind(mixer);\n        this.multimix           = mixer.multimix.bind(mixer);\n        this.dataset            = mixer.dataset.bind(mixer);\n        this.tween              = mixer.tween.bind(mixer);\n        this.insert             = mixer.insert.bind(mixer);\n        this.insertBefore       = mixer.insertBefore.bind(mixer);\n        this.insertAfter        = mixer.insertAfter.bind(mixer);\n        this.prepend            = mixer.prepend.bind(mixer);\n        this.append             = mixer.append.bind(mixer);\n        this.remove             = mixer.remove.bind(mixer);\n        this.destroy            = mixer.destroy.bind(mixer);\n        this.forceRefresh       = mixer.forceRefresh.bind(mixer);\n        this.forceRender        = mixer.forceRender.bind(mixer);\n        this.isMixing           = mixer.isMixing.bind(mixer);\n        this.getOperation       = mixer.getOperation.bind(mixer);\n        this.getConfig          = mixer.getConfig.bind(mixer);\n        this.getState           = mixer.getState.bind(mixer);\n\n        this.callActions('afterConstruct', arguments);\n\n        h.freeze(this);\n        h.seal(this);\n    };\n\n    mixitup.BaseStatic.call(mixitup.Facade);\n\n    mixitup.Facade.prototype = Object.create(mixitup.Base.prototype);\n\n    mixitup.Facade.prototype.constructor = mixitup.Facade;\n\n    if (true) {\n        module.exports = mixitup;\n    } else {}\n    mixitup.BaseStatic.call(mixitup.constructor);\n\n    mixitup.NAME = 'mixitup';\n    mixitup.CORE_VERSION = '3.3.1';\n})(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjczLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL21peGl0dXAvZGlzdC9taXhpdHVwLmpzPzdkYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIVxuICogTWl4SXRVcCB2My4zLjFcbiAqIEEgaGlnaC1wZXJmb3JtYW5jZSwgZGVwZW5kZW5jeS1mcmVlIGxpYnJhcnkgZm9yIGFuaW1hdGVkIGZpbHRlcmluZywgc29ydGluZyBhbmQgbW9yZVxuICogQnVpbGQgOTRlMGZiZjYtY2QwYi00OTg3LWIzYzAtMTRiNTliNjdiOGEwXG4gKlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgMjAxNC0yMDE4IEt1bmthTGFicyBMaW1pdGVkLlxuICogQGF1dGhvciAgICBLdW5rYUxhYnMgTGltaXRlZC5cbiAqIEBsaW5rICAgICAgaHR0cHM6Ly93d3cua3Vua2FsYWJzLmNvbS9taXhpdHVwL1xuICpcbiAqIEBsaWNlbnNlICAgQ29tbWVyY2lhbCB1c2UgcmVxdWlyZXMgYSBjb21tZXJjaWFsIGxpY2Vuc2UuXG4gKiAgICAgICAgICAgIGh0dHBzOi8vd3d3Lmt1bmthbGFicy5jb20vbWl4aXR1cC9saWNlbnNlcy9cbiAqXG4gKiAgICAgICAgICAgIE5vbi1jb21tZXJjaWFsIHVzZSBwZXJtaXR0ZWQgdW5kZXIgc2FtZSB0ZXJtcyBhcyBDQyBCWS1OQyAzLjAgbGljZW5zZS5cbiAqICAgICAgICAgICAgaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICovXG5cbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbWl4aXR1cCA9IG51bGwsXG4gICAgICAgIGggICAgICAgPSBudWxsO1xuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgVkVORE9SUyA9IFsnd2Via2l0JywgJ21veicsICdvJywgJ21zJ10sXG4gICAgICAgICAgICBjYW5hcnkgID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgIC8vIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgVkVORE9SUy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IGkrKykge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1tWRU5ET1JTW2ldICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmdcblxuICAgICAgICBpZiAodHlwZW9mIGNhbmFyeS5uZXh0RWxlbWVudFNpYmxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkVsZW1lbnQucHJvdG90eXBlLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVsZW1lbnQubWF0Y2hlc1xuXG4gICAgICAgIChmdW5jdGlvbihFbGVtZW50UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLm1hdGNoZXMgPVxuICAgICAgICAgICAgICAgIEVsZW1lbnRQcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgICAgICAgICAgICAgIEVsZW1lbnRQcm90b3R5cGUubWFjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgIEVsZW1lbnRQcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIHRoaXMpID4gLTE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSkod2luZG93LkVsZW1lbnQucHJvdG90eXBlKTtcblxuICAgICAgICAvLyBPYmplY3Qua2V5c1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1xuXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSAgICAgID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgaGFzRG9udEVudW1CdWcgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkb250RW51bXMgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGRvbnRFbnVtc0xlbmd0aCAgICAgPSAtMTtcblxuICAgICAgICAgICAgICAgIGhhc0RvbnRFbnVtQnVnID0gISh7XG4gICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBudWxsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgZG9udEVudW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICAgICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCAgICA9ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdC5jcmVhdGVcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IChmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgVGVtcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllc09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG90eXBlICE9PSBPYmplY3QocHJvdG90eXBlKSAmJiBwcm90b3R5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QsIG9yIG51bGwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIFRlbXAucHJvdG90eXBlID0gcHJvdG90eXBlIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgVGVtcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIFRlbXAucHJvdG90eXBlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc09iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIHByb3BlcnRpZXNPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9fcHJvdG9fXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cmluZy5wcm90b3R5b2UudHJpbVxuXG4gICAgICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG4gICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcblxuICAgICAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiwgaywgdCwgbGVuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQgPSBPYmplY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG4gPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobiAhPT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9vYmplY3RzL0Z1bmN0aW9uL2JpbmRcblxuICAgICAgICBpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFBcmdzLCBzZWxmLCBGTk9QLCBmQm91bmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgRk5PUCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXBwbHkodGhpcyBpbnN0YW5jZW9mIEZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBGTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgRk5PUCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50XG5cbiAgICAgICAgaWYgKCF3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgICAgd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcmVFdmVudCgnb24nICsgZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBtaXhpdHVwKClgIFwiZmFjdG9yeVwiIGZ1bmN0aW9uIGNyZWF0ZXMgYW5kIHJldHVybnMgaW5kaXZpZHVhbCBpbnN0YW5jZXNcbiAgICAgKiBvZiBNaXhJdFVwLCBrbm93biBhcyBcIm1peGVyc1wiLCBvbiB3aGljaCBBUEkgbWV0aG9kcyBjYW4gYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogV2hlbiBsb2FkaW5nIE1peEl0VXAgdmlhIGEgc2NyaXB0IHRhZywgdGhlIGZhY3RvcnkgZnVuY3Rpb24gaXMgYWNjZXNzZWRcbiAgICAgKiB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBgbWl4aXR1cGAuIFdoZW4gdXNpbmcgYSBtb2R1bGUgbG9hZGluZ1xuICAgICAqIHN5c3RlbSAoZS5nLiBFUzIwMTUsIENvbW1vbkpTLCBSZXF1aXJlSlMpLCB0aGUgZmFjdG9yeSBmdW5jdGlvbiBpc1xuICAgICAqIGV4cG9ydGVkIGludG8geW91ciBtb2R1bGUgd2hlbiB5b3UgcmVxdWlyZSB0aGUgTWl4SXRVcCBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtaXhpdHVwKGNvbnRhaW5lciBbLGNvbmZpZ10gWyxmb3JlaWduRG9jXSlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQ3JlYXRpbmcgYSBtaXhlciBpbnN0YW5jZSB3aXRoIGFuIGVsZW1lbnQgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAqIHZhciBjb250YWluZXJFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKTtcbiAgICAgKlxuICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBDcmVhdGluZyBhIG1peGVyIGluc3RhbmNlIHdpdGggYSBzZWxlY3RvciBzdHJpbmc8L2NhcHRpb24+XG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cCgnLmNvbnRhaW5lcicpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAzOiBQYXNzaW5nIGEgY29uZmlndXJhdGlvbiBvYmplY3Q8L2NhcHRpb24+XG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdmYWRlIHNjYWxlKDAuNSknXG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogUGFzc2luZyBhbiBpZnJhbWUgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIGNvbmZpZywgZm9yZWlnbkRvY3VtZW50KTtcbiAgICAgKlxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBraW5kICAgICAgICBmdW5jdGlvblxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqIEBwYXJhbSAgICAgICB7KEVsZW1lbnR8c3RyaW5nKX0gIGNvbnRhaW5lclxuICAgICAqICAgICAgQSBET00gZWxlbWVudCBvciBzZWxlY3RvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250YWluZXIocykgb24gd2hpY2ggdG8gaW5zdGFudGlhdGUgTWl4SXRVcC5cbiAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgICAgICAgICBbY29uZmlnXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgXCJjb25maWd1cmF0aW9uIG9iamVjdFwiIHVzZWQgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiB0aGUgTWl4SXRVcCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgICAgICAgICBbZm9yZWlnbkRvY11cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIHJlZmVyZW5jZSB0byBhIGBkb2N1bWVudGAsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgYSBNaXhJdFVwIGluc3RhbmNlIGluIGFuIGlmcmFtZS5cbiAgICAgKiBAcmV0dXJuICAgICAge21peGl0dXAuTWl4ZXJ9XG4gICAgICogICAgICBBIFwibWl4ZXJcIiBvYmplY3QgaG9sZGluZyB0aGUgTWl4SXRVcCBpbnN0YW5jZS5cbiAgICAgKi9cblxuICAgIG1peGl0dXAgPSBmdW5jdGlvbihjb250YWluZXIsIGNvbmZpZywgZm9yZWlnbkRvYykge1xuICAgICAgICB2YXIgZWwgICAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICByZXR1cm5Db2xsZWN0aW9uICAgID0gZmFsc2UsXG4gICAgICAgICAgICBpbnN0YW5jZSAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGZhY2FkZSAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgZG9jICAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBvdXRwdXQgICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGluc3RhbmNlcyAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgIGVsZW1lbnRzICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICBkb2MgPSBmb3JlaWduRG9jIHx8IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICBpZiAocmV0dXJuQ29sbGVjdGlvbiA9IGFyZ3VtZW50c1szXSkge1xuICAgICAgICAgICAgLy8gQSBub24tZG9jdW1lbnRlZCA0dGggcGFyYW1hdGVyIGVuYWJsaW5nIGNvbnRyb2wgb2YgbXVsdGlwbGUgaW5zdGFuY2VzXG5cbiAgICAgICAgICAgIHJldHVybkNvbGxlY3Rpb24gPSB0eXBlb2YgcmV0dXJuQ29sbGVjdGlvbiA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKGNvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyICYmIHR5cGVvZiBjb250YWluZXIgPT09ICdvYmplY3QnICYmIGguaXNFbGVtZW50KGNvbnRhaW5lciwgZG9jKSkge1xuICAgICAgICAgICAgZWxlbWVudHMgPSBbY29udGFpbmVyXTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIgJiYgdHlwZW9mIGNvbnRhaW5lciA9PT0gJ29iamVjdCcgJiYgY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQWx0aG91Z2ggbm90IGRvY3VtZW50ZWQsIHRoZSBjb250YWluZXIgbWF5IGFsc28gYmUgYW4gYXJyYXktbGlrZSBsaXN0IG9mXG4gICAgICAgICAgICAvLyBlbGVtZW50cyBzdWNoIGFzIGEgTm9kZUxpc3Qgb3IgalF1ZXJ5IGNvbGxlY3Rpb24sIGlzIHJldHVybkNvbGxlY3Rpb24gaXMgdHJ1ZVxuXG4gICAgICAgICAgICBlbGVtZW50cyA9IGNvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRmFjdG9yeUludmFsaWRDb250YWluZXIoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JGYWN0b3J5Q29udGFpbmVyTm90Rm91bmQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBlbCA9IGVsZW1lbnRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCAmJiAhcmV0dXJuQ29sbGVjdGlvbikgYnJlYWs7XG5cbiAgICAgICAgICAgIGlmICghZWwuaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9ICdNaXhJdFVwJyArIGgucmFuZG9tSGV4KCk7XG5cbiAgICAgICAgICAgICAgICBlbC5pZCA9IGlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IGVsLmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWl4aXR1cC5pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgbWl4aXR1cC5NaXhlcikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gbWl4aXR1cC5pbnN0YW5jZXNbaWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcgfHwgKGNvbmZpZyAmJiBjb25maWcuZGVidWcgJiYgY29uZmlnLmRlYnVnLnNob3dXYXJuaW5ncyAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdGYWN0b3J5UHJlZXhpc3RpbmdJbnN0YW5jZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IG1peGl0dXAuTWl4ZXIoKTtcblxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmF0dGFjaChlbCwgZG9jLCBpZCwgY29uZmlnKTtcblxuICAgICAgICAgICAgICAgIG1peGl0dXAuaW5zdGFuY2VzW2lkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmYWNhZGUgPSBuZXcgbWl4aXR1cC5GYWNhZGUoaW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZWJ1ZyAmJiBjb25maWcuZGVidWcuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChmYWNhZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBtaXhpdHVwLkNvbGxlY3Rpb24oaW5zdGFuY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZmlyc3QgaW5zdGFuY2UgcmVnYXJkbGVzc1xuXG4gICAgICAgICAgICBvdXRwdXQgPSBpbnN0YW5jZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYC51c2UoKWAgc3RhdGljIG1ldGhvZCBpcyB1c2VkIHRvIGV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBtaXhpdHVwIHdpdGggY29tcGF0aWJsZVxuICAgICAqIGV4dGVuc2lvbnMgYW5kIGxpYnJhcmllcyBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIG1vZHVsYXIgc2NvcGluZyBlLmcuIEVTMjAxNSwgQ29tbW9uSlMsIG9yIFJlcXVpcmVKUy5cbiAgICAgKlxuICAgICAqIFlvdSBuZWVkIG9ubHkgY2FsbCB0aGUgYC51c2UoKWAgZnVuY3Rpb24gb25jZSBwZXIgcHJvamVjdCwgcGVyIGV4dGVuc2lvbiwgYXMgbW9kdWxlIGxvYWRlcnNcbiAgICAgKiB3aWxsIGNhY2hlIGEgc2luZ2xlIHJlZmVyZW5jZSB0byBNaXhJdFVwIGluY2x1c2l2ZSBvZiBhbGwgY2hhbmdlcyBtYWRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtaXhpdHVwLnVzZShleHRlbnNpb24pXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IEV4dGVuZGluZyBNaXhJdFVwIHdpdGggdGhlIFBhZ2luYXRpb24gRXh0ZW5zaW9uPC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogaW1wb3J0IG1peGl0dXAgZnJvbSAnbWl4aXR1cCc7XG4gICAgICogaW1wb3J0IG1peGl0dXBQYWdpbmF0aW9uIGZyb20gJ21peGl0dXAtcGFnaW5hdGlvbic7XG4gICAgICpcbiAgICAgKiBtaXhpdHVwLnVzZShtaXhpdHVwUGFnaW5hdGlvbik7XG4gICAgICpcbiAgICAgKiAvLyBBbGwgbWl4ZXJzIGNyZWF0ZWQgYnkgdGhlIGZhY3RvcnkgZnVuY3Rpb24gaW4gYWxsIG1vZHVsZXMgd2lsbCBub3dcbiAgICAgKiAvLyBoYXZlIHBhZ2luYXRpb24gZnVuY3Rpb25hbGl0eVxuICAgICAqXG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cCgnLmNvbnRhaW5lcicpO1xuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBuYW1lICAgICB1c2VcbiAgICAgKiBAbWVtYmVyb2YgbWl4aXR1cFxuICAgICAqIEBraW5kICAgICBmdW5jdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgeyp9ICBleHRlbnNpb24gICBBIHJlZmVyZW5jZSB0byB0aGUgZXh0ZW5zaW9uIG9yIGxpYnJhcnkgdG8gYmUgdXNlZC5cbiAgICAgKiBAcmV0dXJuICAge3ZvaWR9XG4gICAgICovXG5cbiAgICBtaXhpdHVwLnVzZSA9IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgICBtaXhpdHVwLkJhc2UucHJvdG90eXBlLmNhbGxBY3Rpb25zLmNhbGwobWl4aXR1cCwgJ2JlZm9yZVVzZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgZXh0ZW5zaW9uJ3MgZmFjdG9yeSBmdW5jdGlvbiwgcGFzc2luZ1xuICAgICAgICAvLyB0aGUgbWl4aXR1cCBmYWN0b3J5IGFzIGEgcGFyYW1hdGVyXG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicgJiYgZXh0ZW5zaW9uLlRZUEUgPT09ICdtaXhpdHVwLWV4dGVuc2lvbicpIHtcbiAgICAgICAgICAgIC8vIE1peGl0dXAgZXh0ZW5zaW9uXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWl4aXR1cC5leHRlbnNpb25zW2V4dGVuc2lvbi5OQU1FXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24obWl4aXR1cCk7XG5cbiAgICAgICAgICAgICAgICBtaXhpdHVwLmV4dGVuc2lvbnNbZXh0ZW5zaW9uLk5BTUVdID0gZXh0ZW5zaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4dGVuc2lvbi5mbiAmJiBleHRlbnNpb24uZm4uanF1ZXJ5KSB7XG4gICAgICAgICAgICAvLyBqUXVlcnlcblxuICAgICAgICAgICAgbWl4aXR1cC5saWJyYXJpZXMuJCA9IGV4dGVuc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1peGl0dXAuQmFzZS5wcm90b3R5cGUuY2FsbEFjdGlvbnMuY2FsbChtaXhpdHVwLCAnYWZ0ZXJVc2UnLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLmluc3RhbmNlcyAgID0ge307XG4gICAgbWl4aXR1cC5leHRlbnNpb25zICA9IHt9O1xuICAgIG1peGl0dXAubGlicmFyaWVzICAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICBoID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIGNsc1xuICAgICAgICAgKiBAcmV0dXJuICB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xzICsgJyhcXFxcc3wkKScpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICBjbHNcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbCwgY2xzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQ2xhc3MoZWwsIGNscykpIGVsLmNsYXNzTmFtZSArPSBlbC5jbGFzc05hbWUgPyAnICcgKyBjbHMgOiBjbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICBlbFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgICAgY2xzXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIGNscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNscyArICcoXFxcXHN8JCknKTtcblxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBvbnRvIHRoZVxuICAgICAgICAgKiB0YXJnZXQgb2JqZWN0LiBBbHRlcnMgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIHNvdXJjZVxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBbZGVlcD1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2hhbmRsZUVycm9ycz1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSwgZGVlcCwgaGFuZGxlRXJyb3JzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlS2V5cyAgPSBbXSxcbiAgICAgICAgICAgICAgICBrZXkgICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGRlZXAgPSBkZWVwIHx8IGZhbHNlO1xuICAgICAgICAgICAgaGFuZGxlRXJyb3JzID0gaGFuZGxlRXJyb3JzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZXAgfHwgdHlwZW9mIHNvdXJjZVtrZXldICE9PSAnb2JqZWN0JyB8fCB0aGlzLmlzRWxlbWVudChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBub24tb2JqZWN0IHByb3BlcnRpZXMsIG9yIGFsbCBwcm9wZXJ0aWVzIGlmIHNoYWxsb3cgZXh0ZW5kXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmQoZGVzdGluYXRpb25ba2V5XSwgc291cmNlW2tleV0sIGRlZXAsIGhhbmRsZUVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3RzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmQoZGVzdGluYXRpb25ba2V5XSwgc291cmNlW2tleV0sIGRlZXAsIGhhbmRsZUVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFeHRlbmRFcnJvcihlcnIsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtFcnJvcn0gIGVyclxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGFuZGxlRXh0ZW5kRXJyb3I6IGZ1bmN0aW9uKGVyciwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIHZhciByZSAgICAgICAgICAgICAgICAgID0gL3Byb3BlcnR5IFwiPyhcXHcqKVwiP1ssOl0gb2JqZWN0L2ksXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb25lb3VzICAgICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9uICAgICAgICAgID0gJycsXG4gICAgICAgICAgICAgICAgcHJvYmFibGVNYXRjaCAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGtleSAgICAgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBtb3N0TWF0Y2hpbmdDaGFycyAgID0gLTEsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChtYXRjaGVzID0gcmUuZXhlYyhlcnIubWVzc2FnZSkpKSB7XG4gICAgICAgICAgICAgICAgZXJyb25lb3VzID0gbWF0Y2hlc1sxXTtcblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZXJyb25lb3VzLmxlbmd0aCAmJiBlcnJvbmVvdXMuY2hhckF0KGkpID09PSBrZXkuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IG1vc3RNYXRjaGluZ0NoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3N0TWF0Y2hpbmdDaGFycyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9iYWJsZU1hdGNoID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1vc3RNYXRjaGluZ0NoYXJzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uID0gbWl4aXR1cC5tZXNzYWdlcy5lcnJvckNvbmZpZ0ludmFsaWRQcm9wZXJ0eVN1Z2dlc3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvYmFibGVNYXRjaDogcHJvYmFibGVNYXRjaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWl4aXR1cC5tZXNzYWdlcy5lcnJvckNvbmZpZ0ludmFsaWRQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9uZW91czogZXJyb25lb3VzLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uOiBzdWdnZXN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcmV0dXJuICB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZSAgICAgICAgICA9IC9cXCR7KFtcXHddKil9L2csXG4gICAgICAgICAgICAgICAgZHluYW1pY3MgICAgPSB7fSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzICAgICA9IG51bGw7XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlcyA9IHJlLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljc1ttYXRjaGVzWzFdXSA9IG5ldyBSZWdFeHAoJ1xcXFwkeycgKyBtYXRjaGVzWzFdICsgJ30nLCAnZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgICAgID0gJycsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCAgPSBzdHI7XG5cbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGR5bmFtaWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGR5bmFtaWNzW2tleV0sIHR5cGVvZiBkYXRhW2tleV0gIT09ICd1bmRlZmluZWQnID8gZGF0YVtrZXldIDogJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIHR5cGVcbiAgICAgICAgICogQHBhcmFtICAge2Z1bmN0aW9ufSAgICAgIGZuXG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgICAgICB1c2VDYXB0dXJlXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBvbjogZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICBpZiAoIWVsKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxbJ2UnICsgdHlwZSArIGZuXSA9IGZuO1xuXG4gICAgICAgICAgICAgICAgZWxbdHlwZSArIGZuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlbFsnZScgKyB0eXBlICsgZm5dKHdpbmRvdy5ldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBlbFt0eXBlICsgZm5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICB0eXBlXG4gICAgICAgICAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gICAgICBmblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihlbCwgdHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGlmICghZWwpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGVsW3R5cGUgKyBmbl0pO1xuICAgICAgICAgICAgICAgIGVsW3R5cGUgKyBmbl0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgIGV2ZW50VHlwZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICAgIGRldGFpbFxuICAgICAgICAgKiBAcGFyYW0gICB7RG9jdW1lbnR9ICAgIFtkb2NdXG4gICAgICAgICAqIEByZXR1cm4gIHtDdXN0b21FdmVudH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZGV0YWlsLCBkb2MpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGRvYyA9IGRvYyB8fCB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jLmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnRPYmplY3QoKSxcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZXZlbnRUeXBlO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm4gIHtFdmVudH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0T3JpZ2luYWxFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudG91Y2hlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICBzZWxlY3RvclxuICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgICAgICBpbmRleDogZnVuY3Rpb24oZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgZGFzaCBvciBzbmFrZS1jYXNlIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBzdHJcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2lzUGFzY2FsXVxuICAgICAgICAgKiBAcmV0dXJuICB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgICAgICBjYW1lbENhc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbXy1dW2Etel0pL2csIGZ1bmN0aW9uKCQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvW18tXS8sICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIGRhc2ggb3Igc25ha2UtY2FzZSBzdHJpbmcgdG8gcGFzY2FsIGNhc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHN0clxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBbaXNQYXNjYWxdXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhc2NhbENhc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIChzdHIgPSB0aGlzLmNhbWVsQ2FzZShzdHIpKS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBjYW1lbCBvciBwYXNjYWwtY2FzZSBzdHJpbmcgdG8gZGFzaCBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBzdHJcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgZGFzaENhc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS5yZXBsYWNlKC9eLS8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgICAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MSHRtbEVsZW1lbnR9ICAgW2RvY11cbiAgICAgICAgICogQHJldHVybiAge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlzRWxlbWVudDogZnVuY3Rpb24oZWwsIGRvYykge1xuICAgICAgICAgICAgZG9jID0gZG9jIHx8IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGVsIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3ICYmXG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LkhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgZWwgaW5zdGFuY2VvZiBkb2MuZGVmYXVsdFZpZXcuSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBlbCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBlbC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWwubm9kZU5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBodG1sU3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MSHRtbEVsZW1lbnR9ICAgW2RvY11cbiAgICAgICAgICogQHJldHVybiAge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGh0bWxTdHJpbmcsIGRvYykge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xuXG4gICAgICAgICAgICBkb2MgPSBkb2MgfHwgd2luZG93LmRvY3VtZW50O1xuXG4gICAgICAgICAgICBmcmFnID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHRlbXAgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIHRlbXAuaW5uZXJIVE1MID0gaHRtbFN0cmluZy50cmltKCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0ZW1wLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHRlbXAuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7Tm9kZX0gbm9kZVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgcmVtb3ZlV2hpdGVzcGFjZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdmFyIGRlbGV0aW5nO1xuXG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRpbmcgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRpbmcucGFyZW50RWxlbWVudCAmJiBkZWxldGluZy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRlbGV0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8Kj59ICBiXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBpc0VxdWFsQXJyYXk6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBpID0gYS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChpICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICBhXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICBiXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBkZWVwRXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleSkgfHwgIXRoaXMuZGVlcEVxdWFscyhhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8Kj59ICBvbGRBcnJheVxuICAgICAgICAgKiBAcmV0dXJuICB7QXJyYXk8Kj59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFycmF5U2h1ZmZsZTogZnVuY3Rpb24ob2xkQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBuZXdBcnJheSAgICA9IG9sZEFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgbGVuICAgICAgICAgPSBuZXdBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSBsZW4sXG4gICAgICAgICAgICAgICAgcCAgICAgICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICB0ICAgICAgICAgICA9IFtdO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgcCA9IH5+KE1hdGgucmFuZG9tKCkgKiBsZW4pO1xuICAgICAgICAgICAgICAgIHQgPSBuZXdBcnJheVtpXTtcblxuICAgICAgICAgICAgICAgIG5ld0FycmF5W2ldID0gbmV3QXJyYXlbcF07XG4gICAgICAgICAgICAgICAgbmV3QXJyYXlbcF0gPSB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIGxpc3RcbiAgICAgICAgICovXG5cbiAgICAgICAgYXJyYXlGcm9tTGlzdDogZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCwgaTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge2Z1bmN0aW9ufSAgZnVuY1xuICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICB3YWl0XG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgIGltbWVkaWF0ZVxuICAgICAgICAgKiBAcmV0dXJuICB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIGRlYm91bmNlOiBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncyAgICAgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxOb3cgID0gaW1tZWRpYXRlICYmICF0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBsYXRlciAgICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxOb3cpIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuICB7b2JqZWN0fVxuICAgICAgICAgKi9cblxuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHhQb3NpdGlvbiAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgeVBvc2l0aW9uICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgICAgPSBlbGVtZW50O1xuXG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHhQb3NpdGlvbiAtPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgeVBvc2l0aW9uIC09IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB4UG9zaXRpb24gKz0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB5UG9zaXRpb24gKz0gZWxlbWVudC5vZmZzZXRUb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgeTogeVBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBub2RlMVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBub2RlMlxuICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRIeXBvdGVudXNlOiBmdW5jdGlvbihub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBub2RlMS54IC0gbm9kZTIueCxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVkgPSBub2RlMS55IC0gbm9kZTIueTtcblxuICAgICAgICAgICAgZGlzdGFuY2VYID0gZGlzdGFuY2VYIDwgMCA/IGRpc3RhbmNlWCAqIC0xIDogZGlzdGFuY2VYLFxuICAgICAgICAgICAgZGlzdGFuY2VZID0gZGlzdGFuY2VZIDwgMCA/IGRpc3RhbmNlWSAqIC0xIDogZGlzdGFuY2VZO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRpc3RhbmNlWCwgMikgKyBNYXRoLnBvdyhkaXN0YW5jZVksIDIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VhdGVzIHRoZSBhcmVhIG9mIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byByZWN0YW5nbGVzIGFuZCBleHByZXNzZXMgaXQgYXNcbiAgICAgICAgICogYSByYXRpbyBpbiBjb21wYXJpc29uIHRvIHRoZSBhcmVhIG9mIHRoZSBmaXJzdCByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtSZWN0fSAgYm94MVxuICAgICAgICAgKiBAcGFyYW0gICB7UmVjdH0gIGJveDJcbiAgICAgICAgICogQHJldHVybiAge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uUmF0aW86IGZ1bmN0aW9uKGJveDEsIGJveDIpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sQXJlYSAgICAgICAgID0gYm94MS53aWR0aCAqIGJveDEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblggICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25ZICAgICAgID0gLTEsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uQXJlYSAgICA9IC0xLFxuICAgICAgICAgICAgICAgIHJhdGlvICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uWCA9XG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oYm94MS5sZWZ0ICsgYm94MS53aWR0aCwgYm94Mi5sZWZ0ICsgYm94Mi53aWR0aCkgLSBNYXRoLm1heChib3gxLmxlZnQsIGJveDIubGVmdCkpO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25ZID1cbiAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBNYXRoLm1pbihib3gxLnRvcCArIGJveDEuaGVpZ2h0LCBib3gyLnRvcCArIGJveDIuaGVpZ2h0KSAtIE1hdGgubWF4KGJveDEudG9wLCBib3gyLnRvcCkpO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25BcmVhID0gaW50ZXJzZWN0aW9uWSAqIGludGVyc2VjdGlvblg7XG5cbiAgICAgICAgICAgIHJhdGlvID0gaW50ZXJzZWN0aW9uQXJlYSAvIGNvbnRyb2xBcmVhO1xuXG4gICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgICAgICAgICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICAgICAgICAgIFtpbmNsdWRlU2VsZl1cbiAgICAgICAgICogQHBhcmFtICAge0hUTUxIdG1sRWxlbWVudH0gICBbZG9jXVxuICAgICAgICAgKiBAcmV0dXJuICB7RWxlbWVudHxudWxsfVxuICAgICAgICAgKi9cblxuICAgICAgICBjbG9zZXN0UGFyZW50OiBmdW5jdGlvbihlbCwgc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBkb2MpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgZG9jID0gZG9jIHx8IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIGVsLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubWF0Y2hlcyAmJiBwYXJlbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEh0bWxFbGVtZW50fSAgIFtkb2NdXG4gICAgICAgICAqIEByZXR1cm4gIHtOb2RlTGlzdH1cbiAgICAgICAgICovXG5cbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uKGVsLCBzZWxlY3RvciwgZG9jKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gICAgPSBbXSxcbiAgICAgICAgICAgICAgICB0ZW1wSWQgICAgICA9ICcnO1xuXG4gICAgICAgICAgICBkb2MgPSBkb2MgfHwgd2luZG93LmRvYztcblxuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5pZCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wSWQgPSAnVGVtcCcgKyB0aGlzLnJhbmRvbUhleEtleSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLmlkID0gdGVtcElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgZWwuaWQgKyAnID4gJyArIHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZW1wSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYSBwcm92aWRlZCBhcnJheSwgd2l0aCBhbnkgZW1wdHkgc3RyaW5ncyByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8Kj59IG9yaWdpbmFsQXJyYXlcbiAgICAgICAgICogQHJldHVybiAge0FycmF5PCo+fVxuICAgICAgICAgKi9cblxuICAgICAgICBjbGVhbjogZnVuY3Rpb24ob3JpZ2luYWxBcnJheSkge1xuICAgICAgICAgICAgdmFyIGNsZWFuQXJyYXkgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gLTE7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQXJyYXlbaV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuQXJyYXkucHVzaChvcmlnaW5hbEFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjbGVhbkFycmF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBYnN0cmFjdHMgYW4gRVM2IHByb21pc2UgaW50byBhIHEtbGlrZSBkZWZlcnJlZCBpbnRlcmZhY2UgZm9yIHN0b3JhZ2UgYW5kIGRlZmVycmVkIHJlc29sdXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gbGlicmFyaWVzXG4gICAgICAgICAqIEByZXR1cm4ge2guRGVmZXJyZWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGRlZmVyOiBmdW5jdGlvbihsaWJyYXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcHJvbWlzZVdyYXBwZXIgPSBudWxsLFxuICAgICAgICAgICAgICAgICQgICAgICAgICAgICAgID0gbnVsbDtcblxuICAgICAgICAgICAgcHJvbWlzZVdyYXBwZXIgPSBuZXcgdGhpcy5EZWZlcnJlZCgpO1xuXG4gICAgICAgICAgICBpZiAobWl4aXR1cC5mZWF0dXJlcy5oYXMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBFUzYgbmF0aXZlIHByb21pc2Ugb3IgcG9seWZpbGxcblxuICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVdyYXBwZXIucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnJlamVjdCAgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgkID0gKHdpbmRvdy5qUXVlcnkgfHwgbGlicmFyaWVzLiQpKSAmJiB0eXBlb2YgJC5EZWZlcnJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGpRdWVyeVxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgICAgICBwcm9taXNlV3JhcHBlci5wcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnJlc29sdmUgPSBkZWZlcnJlZC5yZXNvbHZlO1xuICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnJlamVjdCAgPSBkZWZlcnJlZC5yZWplY3Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaW1wbGVtZW50YXRpb25cblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdOb1Byb21pc2VJbXBsZW1lbnRhdGlvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VXcmFwcGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8UHJvbWlzZT59ICAgIHRhc2tzXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgICAgICAgICAgbGlicmFyaWVzXG4gICAgICAgICAqIEByZXR1cm4gIHtQcm9taXNlPEFycmF5Pn1cbiAgICAgICAgICovXG5cbiAgICAgICAgYWxsOiBmdW5jdGlvbih0YXNrcywgbGlicmFyaWVzKSB7XG4gICAgICAgICAgICB2YXIgJCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChtaXhpdHVwLmZlYXR1cmVzLmhhcy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0YXNrcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgkID0gKHdpbmRvdy5qUXVlcnkgfHwgbGlicmFyaWVzLiQpKSAmJiB0eXBlb2YgJC53aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQud2hlbi5hcHBseSgkLCB0YXNrcylcbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkgd2hlbiByZXR1cm5zIHNwcmVhZCBhcmd1bWVudHMgcmF0aGVyIHRoYW4gYW4gYXJyYXkgb3IgcmVzb2x1dGlvbnNcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdOb1Byb21pc2VJbXBsZW1lbnRhdGlvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIHByb3BlcnR5XG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheTxzdHJpbmc+fSB2ZW5kb3JzXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldFByZWZpeDogZnVuY3Rpb24oZWwsIHByb3BlcnR5LCB2ZW5kb3JzKSB7XG4gICAgICAgICAgICB2YXIgaSAgICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIHByZWZpeCAgPSAnJztcblxuICAgICAgICAgICAgaWYgKGguZGFzaENhc2UocHJvcGVydHkpIGluIGVsLnN0eWxlKSByZXR1cm4gJyc7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHByZWZpeCA9IHZlbmRvcnNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggKyBwcm9wZXJ0eSBpbiBlbC5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJ3Vuc3VwcG9ydGVkJztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgcmFuZG9tSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoJzAwMDAwJyArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgPDwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRG9jdW1lbnR9ICBbZG9jXVxuICAgICAgICAgKiBAcmV0dXJuICB7b2JqZWN0fVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXREb2N1bWVudFN0YXRlOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIGRvYyA9IHR5cGVvZiBkb2MuYm9keSA9PT0gJ29iamVjdCcgPyBkb2MgOiB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGRvY0hlaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgZG9jV2lkdGg6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0V2lkdGg6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIG9ialxuICAgICAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBmblxuICAgICAgICAgKiBAcmV0dXJuICB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGVsLm9mZnNldFBhcmVudCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0eWxlcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyAmJlxuICAgICAgICAgICAgICAgIHN0eWxlcy52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJyAmJlxuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ICE9PSAnMCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIEZpeGVkIGVsZW1lbnRzIHJlcG9ydCBubyBvZmZzZXRQYXJlbnQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IG1heSBzdGlsbCBiZSBpbnZpc2libGVcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIG9ialxuICAgICAgICAgKi9cblxuICAgICAgICBzZWFsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LnNlYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Quc2VhbChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBvYmpcbiAgICAgICAgICovXG5cbiAgICAgICAgZnJlZXplOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmZyZWV6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgY29udHJvbFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBzcGVjaW1lblxuICAgICAgICAgKiBAcmV0dXJuICB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgY29tcGFyZVZlcnNpb25zOiBmdW5jdGlvbihjb250cm9sLCBzcGVjaW1lbikge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xQYXJ0cyAgICA9IGNvbnRyb2wuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBzcGVjaW1lblBhcnRzICAgPSBzcGVjaW1lbi5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xQYXJ0ICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIHNwZWNpbWVuUGFydCAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udHJvbFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbFBhcnQgICAgID0gcGFyc2VJbnQoY29udHJvbFBhcnRzW2ldLnJlcGxhY2UoL1teXFxkLl0vZywgJycpKTtcbiAgICAgICAgICAgICAgICBzcGVjaW1lblBhcnQgICAgPSBwYXJzZUludChzcGVjaW1lblBhcnRzW2ldLnJlcGxhY2UoL1teXFxkLl0vZywgJycpIHx8IDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpbWVuUGFydCA8IGNvbnRyb2xQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpbWVuUGFydCA+IGNvbnRyb2xQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cblxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgICAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlICAgID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ICAgICA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlkICAgICAgICAgPSBoLnJhbmRvbUhleCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgb2JqXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnJztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5Db25maWcuQ2xhc3NOYW1lc30gICBjbGFzc05hbWVzXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgIFttb2RpZmllcl1cbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q2xhc3NuYW1lOiBmdW5jdGlvbihjbGFzc05hbWVzLCBlbGVtZW50TmFtZSwgbW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc25hbWUgPSAnJztcblxuICAgICAgICAgICAgY2xhc3NuYW1lICs9IGNsYXNzTmFtZXMuYmxvY2s7XG5cbiAgICAgICAgICAgIGlmIChjbGFzc25hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NuYW1lICs9IGNsYXNzTmFtZXMuZGVsaW5lYXRvckVsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSBjbGFzc05hbWVzWydlbGVtZW50JyArIHRoaXMucGFzY2FsQ2FzZShlbGVtZW50TmFtZSldO1xuXG4gICAgICAgICAgICBpZiAoIW1vZGlmaWVyKSByZXR1cm4gY2xhc3NuYW1lO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NuYW1lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNsYXNzbmFtZSArPSBjbGFzc05hbWVzLmRlbGluZWF0b3JNb2RpZmllcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xhc3NuYW1lICs9IG1vZGlmaWVyO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NuYW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IG9uIGEgZ2l2ZW4gb2JqZWN0IHZpYSBpdHMgc3RyaW5nIGtleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgb2JqXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHN0cmluZ0tleVxuICAgICAgICAgKiBAcmV0dXJuICB7Kn0gdmFsdWVcbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgc3RyaW5nS2V5KSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgICAgICAgICAgID0gc3RyaW5nS2V5LnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgcmV0dXJuQ3VycmVudCAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50ICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIXN0cmluZ0tleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybkN1cnJlbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgb2JqID0gcmV0dXJuQ3VycmVudChvYmopO1xuXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtaXhpdHVwLmggPSBoO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEJhc2UgY2xhc3MgYWRkcyBpbnN0YW5jZSBtZXRob2RzIHRvIGFsbCBvdGhlciBleHRlbnNpYmxlIE1peEl0VXAgY2xhc3NlcyxcbiAgICAgKiBlbmFibGluZyB0aGUgY2FsbGluZyBvZiBhbnkgcmVnaXN0ZXJlZCBob29rcy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkJhc2UgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgbWl4aXR1cC5CYXNlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuQmFzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYW55IHJlZ2lzdGVyZWQgaG9va3MgZm9yIHRoZSBwcm92aWRlZCBhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkJhc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgYWN0aW9uTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNhbGxBY3Rpb25zOiBmdW5jdGlvbihhY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBob29rcyAgICAgICAgICAgPSBzZWxmLmNvbnN0cnVjdG9yLmFjdGlvbnNbYWN0aW9uTmFtZV0sXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uTmFtZSAgID0gJyc7XG5cbiAgICAgICAgICAgIGlmICghaG9va3MgfHwgaC5pc0VtcHR5T2JqZWN0KGhvb2tzKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBmb3IgKGV4dGVuc2lvbk5hbWUgaW4gaG9va3MpIHtcbiAgICAgICAgICAgICAgICBob29rc1tleHRlbnNpb25OYW1lXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYW55IHJlZ2lzdGVyZWQgaG9va3MgZm9yIHRoZSBwcm92aWRlZCBmaWx0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkJhc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgZmlsdGVyTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAgeyp9ICAgICAgICAgaW5wdXRcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtBcnJheTwqPn0gIGFyZ3NcbiAgICAgICAgICogQHJldHVybiAgICAgIHsqfVxuICAgICAgICAgKi9cblxuICAgICAgICBjYWxsRmlsdGVyczogZnVuY3Rpb24oZmlsdGVyTmFtZSwgaW5wdXQsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGhvb2tzICAgICAgICAgICA9IHNlbGYuY29uc3RydWN0b3IuZmlsdGVyc1tmaWx0ZXJOYW1lXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQgICAgICAgICAgPSBpbnB1dCxcbiAgICAgICAgICAgICAgICBleHRlbnNpb25OYW1lICAgPSAnJztcblxuICAgICAgICAgICAgaWYgKCFob29rcyB8fCBoLmlzRW1wdHlPYmplY3QoaG9va3MpKSByZXR1cm4gb3V0cHV0O1xuXG4gICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcblxuICAgICAgICAgICAgZm9yIChleHRlbnNpb25OYW1lIGluIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGguYXJyYXlGcm9tTGlzdChhcmdzKTtcblxuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChvdXRwdXQpO1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gaG9va3NbZXh0ZW5zaW9uTmFtZV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIEJhc2VTdGF0aWMgY2xhc3MgaG9sZHMgYSBzZXQgb2Ygc3RhdGljIG1ldGhvZHMgd2hpY2ggYXJlIHRoZW4gYWRkZWQgdG8gYWxsIG90aGVyXG4gICAgICogZXh0ZW5zaWJsZSBNaXhJdFVwIGNsYXNzZXMgYXMgYSBtZWFucyBvZiBpbnRlZ3JhdGluZyBleHRlbnNpb25zIHZpYSB0aGUgYWRkaXRpb24gb2YgbmV3XG4gICAgICogbWV0aG9kcyBhbmQvb3IgYWN0aW9ucyBhbmQgaG9va3MuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBzaGFsbG93IGV4dGVuZCBvbiB0aGUgY2xhc3MncyBwcm90b3R5cGUsIGFkZGluZyBvbmUgb3IgbW9yZSBuZXcgbWVtYmVycyB0b1xuICAgICAgICAgKiB0aGUgY2xhc3MgaW4gYSBzaW5nbGUgb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5CYXNlU3RhdGljXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4xLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtvYmplY3R9IGV4dGVuc2lvblxuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZXh0ZW5kID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBoLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgZXh0ZW5zaW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZSBhY3Rpb24gaG9vayBvZiB0aGUgcHJvdmlkZWQgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQmFzZVN0YXRpY1xuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHNpbmNlICAgICAgIDIuMS4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBob29rTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgZXh0ZW5zaW9uTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Z1bmN0aW9ufSAgZnVuY1xuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJBY3Rpb24gPSBmdW5jdGlvbihob29rTmFtZSwgZXh0ZW5zaW9uTmFtZSwgZnVuYykge1xuICAgICAgICAgICAgKHRoaXMuYWN0aW9uc1tob29rTmFtZV0gPSB0aGlzLmFjdGlvbnNbaG9va05hbWVdIHx8IHt9KVtleHRlbnNpb25OYW1lXSA9IGZ1bmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiB0aGUgZmlsdGVyIG9mIHRoZSBwcm92aWRlZCBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5CYXNlU3RhdGljXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4xLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIGhvb2tOYW1lXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBleHRlbnNpb25OYW1lXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBmdW5jXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbHRlciA9IGZ1bmN0aW9uKGhvb2tOYW1lLCBleHRlbnNpb25OYW1lLCBmdW5jKSB7XG4gICAgICAgICAgICAodGhpcy5maWx0ZXJzW2hvb2tOYW1lXSA9IHRoaXMuZmlsdGVyc1tob29rTmFtZV0gfHwge30pW2V4dGVuc2lvbk5hbWVdID0gZnVuYztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBtaXhpdHVwLkZlYXR1cmVzYCBjbGFzcyBwZXJmb3JtcyBhbGwgZmVhdHVyZSBhbmQgQ1NTIHByZWZpeCBkZXRlY3Rpb25cbiAgICAgKiBuZWNjZXNzYXJ5IGZvciBNaXhJdFVwIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSwgYXMgd2VsbCBhcyBzdG9yaW5nIHZhcmlvdXNcbiAgICAgKiBzdHJpbmcgYW5kIGFycmF5IGNvbnN0YW50cy4gQWxsIGZlYXR1cmUgZGVjZWN0aW9uIGlzIG9uIGV2YWx1YXRpb24gb2YgdGhlXG4gICAgICogbGlicmFyeSBhbmQgc3RvcmVkIGluIGEgc2luZ2xldG9uIGluc3RhbmNlIGZvciB1c2UgYnkgb3RoZXIgaW50ZXJuYWwgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIHRoaXMuYm94U2l6aW5nUHJlZml4ICAgICAgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1QcmVmaXggICAgICAgICAgICA9ICcnO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25QcmVmaXggICAgICAgICAgID0gJyc7XG5cbiAgICAgICAgdGhpcy5ib3hTaXppbmdQcmVmaXggICAgICAgICAgICA9ICcnO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVByb3AgICAgICAgICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUnVsZSAgICAgICAgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUHJvcCAgICAgICAgICAgICA9ICcnO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlUHJvcCAgICAgICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVPcmlnaW5Qcm9wICAgICAgPSAnJztcblxuICAgICAgICB0aGlzLmhhcyAgICAgICAgICAgICAgICAgICAgICAgID0gbmV3IG1peGl0dXAuSGFzKCk7XG5cbiAgICAgICAgdGhpcy5jYW5hcnkgICAgICAgICAgICAgICAgICAgICA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5CT1hfU0laSU5HX1BST1AgICAgICAgICAgICA9ICdib3hTaXppbmcnO1xuICAgICAgICB0aGlzLlRSQU5TSVRJT05fUFJPUCAgICAgICAgICAgID0gJ3RyYW5zaXRpb24nO1xuICAgICAgICB0aGlzLlRSQU5TRk9STV9QUk9QICAgICAgICAgICAgID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgIHRoaXMuUEVSU1BFQ1RJVkVfUFJPUCAgICAgICAgICAgPSAncGVyc3BlY3RpdmUnO1xuICAgICAgICB0aGlzLlBFUlNQRUNUSVZFX09SSUdJTl9QUk9QICAgID0gJ3BlcnNwZWN0aXZlT3JpZ2luJztcbiAgICAgICAgdGhpcy5WRU5ET1JTICAgICAgICAgICAgICAgICAgICA9IFsnV2Via2l0JywgJ21veicsICdPJywgJ21zJ107XG5cbiAgICAgICAgdGhpcy5UV0VFTkFCTEUgPSBbXG4gICAgICAgICAgICAnb3BhY2l0eScsXG4gICAgICAgICAgICAnd2lkdGgnLCAnaGVpZ2h0JyxcbiAgICAgICAgICAgICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICAgICAgJ3gnLCAneScsXG4gICAgICAgICAgICAnc2NhbGUnLFxuICAgICAgICAgICAgJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJyxcbiAgICAgICAgICAgICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWidcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkZlYXR1cmVzKTtcblxuICAgIG1peGl0dXAuRmVhdHVyZXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIGguZXh0ZW5kKG1peGl0dXAuRmVhdHVyZXMucHJvdG90eXBlLFxuICAgIC8qKiBAbGVuZHMgbWl4aXR1cC5GZWF0dXJlcyAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuRmVhdHVyZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FuYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIHNlbGYuc2V0UHJlZml4ZXMoKTtcbiAgICAgICAgICAgIHNlbGYucnVuVGVzdHMoKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBydW5UZXN0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVJ1blRlc3RzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5oYXMucHJvbWlzZXMgICAgICAgPSB0eXBlb2Ygd2luZG93LlByb21pc2UgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICBzZWxmLmhhcy50cmFuc2l0aW9ucyAgICA9IHNlbGYudHJhbnNpdGlvblByZWZpeCAhPT0gJ3Vuc3VwcG9ydGVkJztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJSdW5UZXN0cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKHNlbGYuaGFzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHNldFByZWZpeGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlU2V0UHJlZml4ZXMnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzZWxmLnRyYW5zaXRpb25QcmVmaXggICA9IGguZ2V0UHJlZml4KHNlbGYuY2FuYXJ5LCAnVHJhbnNpdGlvbicsIHNlbGYuVkVORE9SUyk7XG4gICAgICAgICAgICBzZWxmLnRyYW5zZm9ybVByZWZpeCAgICA9IGguZ2V0UHJlZml4KHNlbGYuY2FuYXJ5LCAnVHJhbnNmb3JtJywgc2VsZi5WRU5ET1JTKTtcbiAgICAgICAgICAgIHNlbGYuYm94U2l6aW5nUHJlZml4ICAgID0gaC5nZXRQcmVmaXgoc2VsZi5jYW5hcnksICdCb3hTaXppbmcnLCBzZWxmLlZFTkRPUlMpO1xuXG4gICAgICAgICAgICBzZWxmLmJveFNpemluZ1Byb3AgPSBzZWxmLmJveFNpemluZ1ByZWZpeCA/XG4gICAgICAgICAgICAgICAgc2VsZi5ib3hTaXppbmdQcmVmaXggKyBoLnBhc2NhbENhc2Uoc2VsZi5CT1hfU0laSU5HX1BST1ApIDogc2VsZi5CT1hfU0laSU5HX1BST1A7XG5cbiAgICAgICAgICAgIHNlbGYudHJhbnNpdGlvblByb3AgPSBzZWxmLnRyYW5zaXRpb25QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNpdGlvblByZWZpeCArIGgucGFzY2FsQ2FzZShzZWxmLlRSQU5TSVRJT05fUFJPUCkgOiBzZWxmLlRSQU5TSVRJT05fUFJPUDtcblxuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1Qcm9wID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgaC5wYXNjYWxDYXNlKHNlbGYuVFJBTlNGT1JNX1BST1ApIDogc2VsZi5UUkFOU0ZPUk1fUFJPUDtcblxuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1SdWxlID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgICctJyArIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgJy0nICsgc2VsZi5UUkFOU0ZPUk1fUFJPUCA6IHNlbGYuVFJBTlNGT1JNX1BST1A7XG5cbiAgICAgICAgICAgIHNlbGYucGVyc3BlY3RpdmVQcm9wID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgaC5wYXNjYWxDYXNlKHNlbGYuUEVSU1BFQ1RJVkVfUFJPUCkgOiBzZWxmLlBFUlNQRUNUSVZFX1BST1A7XG5cbiAgICAgICAgICAgIHNlbGYucGVyc3BlY3RpdmVPcmlnaW5Qcm9wID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgaC5wYXNjYWxDYXNlKHNlbGYuUEVSU1BFQ1RJVkVfT1JJR0lOX1BST1ApIDpcbiAgICAgICAgICAgICAgICBzZWxmLlBFUlNQRUNUSVZFX09SSUdJTl9QUk9QO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclNldFByZWZpeGVzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5IYXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucyAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb21pc2VzICAgICAgID0gZmFsc2U7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvLyBBc3NpZ24gYSBzaW5nbGV0b24gaW5zdGFuY2UgdG8gYG1peGl0dXAuZmVhdHVyZXNgIGFuZCBpbml0aWFsaXNlOlxuXG4gICAgbWl4aXR1cC5mZWF0dXJlcyA9IG5ldyBtaXhpdHVwLkZlYXR1cmVzKCk7XG5cbiAgICBtaXhpdHVwLmZlYXR1cmVzLmluaXQoKTtcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgb2YgcHJvcGVydGllcyBkZWZpbmluZyB0aGUgbWl4ZXIncyBhbmltYXRpb24gYW5kIGVmZmVjdHMgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgYW5pbWF0aW9uXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IGFuaW1hdGlvbiBzaG91bGQgYmUgZW5hYmxlZCBmb3IgdGhlIE1peEl0VXAgaW5zdGFuY2UuXG4gICAgICAgICAqIElmIGBmYWxzZWAsIGFsbCBvcGVyYXRpb25zIHdpbGwgb2NjdXIgaW5zdGFudGx5IGFuZCBzeW5jcm9ub3VzbHksIGFsdGhvdWdoIGNhbGxiYWNrXG4gICAgICAgICAqIGZ1bmN0aW9ucyBhbmQgYW55IHJldHVybmVkIHByb21pc2VzIHdpbGwgc3RpbGwgYmUgZnVsZmlsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBDcmVhdGUgYSBtaXhlciB3aXRoIGFsbCBhbmltYXRpb25zIGRpc2FibGVkPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZW5hYmxlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIHRydWVcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lbmFibGUgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBvZiBvbmUgb3IgbW9yZSBzcGFjZS1zZXBlcmF0ZWQgcHJvcGVydGllcyB0byB3aGljaCB0cmFuc2l0aW9ucyB3aWxsIGJlXG4gICAgICAgICAqIGFwcGxpZWQgZm9yIGFsbCBmaWx0ZXJpbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvcGVydGllcyBjYW4gYmUgbGlzdGVkIGFueSBvcmRlciBvciBjb21iaW5hdGlvbiwgYWx0aG91Z2ggdGhleSB3aWxsIGJlIGFwcGxpZWQgaW4gYSBzcGVjaWZpY1xuICAgICAgICAgKiBwcmVkZWZpbmVkIG9yZGVyIHRvIHByb2R1Y2UgY29uc2lzdGVudCByZXN1bHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBsZWFybiBtb3JlIGFib3V0IGF2YWlsYWJsZSBlZmZlY3RzLCBleHBlcmltZW50IHdpdGggb3VyIDxhIGhyZWY9XCJodHRwczovL3d3dy5rdW5rYWxhYnMuY29tL21peGl0dXAvXCI+XG4gICAgICAgICAqIHNhbmRib3ggZGVtbzwvYT4gYW5kIHRyeSBvdXQgdGhlIFwiRXhwb3J0IGNvbmZpZ1wiIGJ1dHRvbiBpbiB0aGUgQW5pbWF0aW9uIG9wdGlvbnMgZHJvcCBkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBBcHBseSBcImZhZGVcIiBhbmQgXCJ0cmFuc2xhdGVaXCIgZWZmZWN0cyB0byBhbGwgYW5pbWF0aW9uczwvY2FwdGlvbj5cbiAgICAgICAgICogLy8gQXMgdGFyZ2V0cyBhcmUgZmlsdGVyZWQgaW4gYW5kIG91dCwgdGhleSB3aWxsIGZhZGUgYmV0d2VlblxuICAgICAgICAgKiAvLyBvcGFjaXR5IDEgYW5kIDAgYW5kIHRyYW5zZm9ybSBiZXR3ZWVuIHRyYW5zbGF0ZVooLTEwMHB4KSBhbmRcbiAgICAgICAgICogLy8gdHJhbnNsYXRlWigwKS5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZWZmZWN0czogJ2ZhZGUgdHJhbnNsYXRlWigtMTAwcHgpJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVmZmVjdHNcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnZmFkZSBzY2FsZSdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lZmZlY3RzID0gJ2ZhZGUgc2NhbGUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBvZiBvbmUgb3IgbW9yZSBzcGFjZS1zZXBlcmF0ZWQgZWZmZWN0cyB0byBiZSBhcHBsaWVkIG9ubHkgdG8gZmlsdGVyLWluXG4gICAgICAgICAqIGFuaW1hdGlvbnMsIG92ZXJyaWRpbmcgYGNvbmZpZy5hbmltYXRpb24uZWZmZWN0c2AgaWYgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBBcHBseSBkb3dud2FyZHMgdmVydGljYWwgdHJhbnNsYXRlIHRvIHRhcmdldHMgYmVpbmcgZmlsdGVyZWQgaW48L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHNJbjogJ2ZhZGUgdHJhbnNsYXRlWSgtMTAwJSknXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZWZmZWN0c0luXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lZmZlY3RzSW4gPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgb2Ygb25lIG9yIG1vcmUgc3BhY2Utc2VwZXJhdGVkIGVmZmVjdHMgdG8gYmUgYXBwbGllZCBvbmx5IHRvIGZpbHRlci1vdXRcbiAgICAgICAgICogYW5pbWF0aW9ucywgb3ZlcnJpZGluZyBgY29uZmlnLmFuaW1hdGlvbi5lZmZlY3RzYCBpZiBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEFwcGx5IHVwd2FyZHMgdmVydGljYWwgdHJhbnNsYXRlIHRvIHRhcmdldHMgYmVpbmcgZmlsdGVyZWQgb3V0PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlZmZlY3RzT3V0OiAnZmFkZSB0cmFuc2xhdGVZKC0xMDAlKSdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBlZmZlY3RzT3V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lZmZlY3RzT3V0ID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgZGljdGF0aW5nIHRoZSBkdXJhdGlvbiBvZiBhbGwgTWl4SXRVcCBhbmltYXRpb25zIGluIG1pbGxpc2Vjb25kcywgbm90XG4gICAgICAgICAqIGluY2x1ZGluZyBhbnkgYWRkaXRpb25hbCBkZWxheSBhcGxsaWVkIHZpYSB0aGUgYCdzdGFnZ2VyJ2AgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBBcHBseSBhbiBhbmltYXRpb24gZHVyYXRpb24gb2YgMjAwbXMgdG8gYWxsIG1peGl0dXAgYW5pbWF0aW9uczwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGR1cmF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgNjAwXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSA2MDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdmFsaWQgQ1NTMyB0cmFuc2l0aW9uLXRpbWluZyBmdW5jdGlvbiBvciBzaG9ydGhhbmQuIEZvciBhIGZ1bGwgbGlzdCBvZiBhY2NlcHRlZFxuICAgICAgICAgKiB2YWx1ZXMsIHZpc2l0IDxhIGhyZWY9XCJodHRwOi8vZWFzaW5ncy5uZXRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5lYXNpbmdzLm5ldDwvYT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQXBwbHkgXCJlYXNlLWluLW91dFwiIGVhc2luZyB0byBhbGwgYW5pbWF0aW9uczwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IEFwcGx5IGEgY3VzdG9tIFwiY3ViaWMtYmV6aWVyXCIgZWFzaW5nIGZ1bmN0aW9uIHRvIGFsbCBhbmltYXRpb25zPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSknXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZWFzaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2Vhc2UnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gJ2Vhc2UnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIGFwcGx5IHBlcnNwZWN0aXZlIHRvIHRoZSBNaXhJdFVwIGNvbnRhaW5lclxuICAgICAgICAgKiBkdXJpbmcgYW5pbWF0aW9ucy4gQnkgZGVmYXVsdCwgcGVyc3BlY3RpdmUgaXMgYWx3YXlzIGFwcGxpZWQgYW5kIGNyZWF0ZXMgdGhlXG4gICAgICAgICAqIGlsbHVzaW9uIG9mIHRocmVlLWRpbWVuc2lvbmFsIHNwYWNlIGZvciBlZmZlY3RzIHN1Y2ggYXMgYHRyYW5zbGF0ZVpgLCBgcm90YXRlWGAsXG4gICAgICAgICAqIGFuZCBgcm90YXRlWWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgYW5kIGRlZmluZSB5b3VyIG93biBwZXJzcGVjdGl2ZSBzZXR0aW5ncyB2aWEgQ1NTLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBQcmV2ZW50IHBlcnNwZWN0aXZlIGZyb20gYmVpbmcgYXBwbGllZCB0byBhbnkgM0QgdHJhbnNmb3JtczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgYXBwbHlQZXJzcGVjdGl2ZTogZmFsc2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhcHBseVBlcnNwZWN0aXZlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmFwcGx5UGVyc3BlY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyc3BlY3RpdmUgZGlzdGFuY2UgdmFsdWUgdG8gYmUgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIGR1cmluZyBhbmltYXRpb25zLFxuICAgICAgICAgKiBhZmZlY3RpbmcgYW55IDNELXRyYW5zZm9ybS1iYXNlZCBlZmZlY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXQgYSBwZXJzcGVjdGl2ZSBkaXN0YW5jZSBvZiAyMDAwcHg8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdyb3RhdGVZKC0yNWRlZyknLFxuICAgICAgICAgKiAgICAgICAgIHBlcnNwZWN0aXZlRGlzdGFuY2U6ICcyMDAwcHgnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgcGVyc3BlY3RpdmVEaXN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICczMDAwcHgnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVEaXN0YW5jZSA9ICczMDAwcHgnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyc3BlY3RpdmUtb3JpZ2luIHZhbHVlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lciBkdXJpbmcgYW5pbWF0aW9ucyxcbiAgICAgICAgICogYWZmZWN0aW5nIGFueSAzRC10cmFuc2Zvcm0tYmFzZWQgZWZmZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogU2V0IGEgcGVyc3BlY3RpdmUgb3JpZ2luIGluIHRoZSB0b3AtcmlnaHQgb2YgdGhlIGNvbnRhaW5lcjwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZWZmZWN0czogJ3RyYW5zYXRlWigtMjAwcHgpJyxcbiAgICAgICAgICogICAgICAgICBwZXJzcGVjdGl2ZU9yaWdpbjogJzEwMCUgMCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBwZXJzcGVjdGl2ZU9yaWdpblxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICc1MCUgNTAlJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlT3JpZ2luID0gJzUwJSA1MCUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIGVuYWJsZSB0aGUgcXVldWluZyBvZiBvcGVyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAgKGRlZmF1bHQpLCBhbmQgYSBjb250cm9sIGlzIGNsaWNrZWQgb3IgYW4gQVBJIGNhbGwgaXMgbWFkZSB3aGlsZSBhbm90aGVyXG4gICAgICAgICAqIG9wZXJhdGlvbiBpcyBwcm9ncmVzcywgdGhlIG9wZXJhdGlvbiB3aWxsIGdvIGludG8gdGhlIHF1ZXVlIGFuZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZXhlY3R1dGVkXG4gICAgICAgICAqIHdoZW4gdGhlIHByZXZpb3VzIG9wZXJhaXRvbnMgaXMgZmluaXNoZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBmYWxzZWAsIGFueSByZXF1ZXN0ZWQgb3BlcmF0aW9ucyB3aWxsIGJlIGlnbm9yZWQsIGFuZCB0aGUgYG9uTWl4QnVzeWAgY2FsbGJhY2sgYW5kIGBtaXhCdXN5YFxuICAgICAgICAgKiBldmVudCB3aWxsIGJlIGZpcmVkLiBJZiBgZGVidWcuc2hvd1dhcm5pbmdzYCBpcyBlbmFibGVkLCBhIGNvbnNvbGUgd2FybmluZyB3aWxsIGFsc28gb2NjdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGUgcXVldWluZzwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgcXVldWVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnF1ZXVlID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZWdlciBkaWN0YWN0aW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiBvcGVyYXRpb25zIGFsbG93ZWQgaW4gdGhlIHF1ZXVlIGF0XG4gICAgICAgICAqIGFueSB0aW1lLCB3aGVuIHF1ZXVpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQWxsb3cgYSBtYXhpbXVtIG9mIDUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWUgYXQgYW55IHRpbWU8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIHF1ZXVlTGltaXQ6IDVcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBxdWV1ZUxpbWl0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgM1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnF1ZXVlTGltaXQgPSAzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24gdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlXG4gICAgICAgICAqIGNvbnRhaW5lciBhcyBlbGVtZW50cyBhcmUgZmlsdGVyZWQgaW4gYW5kIG91dC4gSWYgZGlzYWJsZWQsIHRoZSBjb250YWluZXIgaGVpZ2h0XG4gICAgICAgICAqIHdpbGwgY2hhbmdlIGFicnVwdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCBtYXkgYmUgZGVzaXJhYmxlIHRvIGRpc2FibGUgdGhpcyBvbiBtb2JpbGUgZGV2aWNlcyBhcyB0aGUgQ1NTIGBoZWlnaHRgIGFuZFxuICAgICAgICAgKiBgd2lkdGhgIHByb3BlcnRpZXMgZG8gbm90IHJlY2VpdmUgR1BVLWFjY2VsZXJhdGlvbiBhbmQgY2FuIHRoZXJlZm9yZSBjYXVzZSBzdHV0dGVyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IERpc2FibGUgdGhlIHRyYW5zaXRpb25pbmcgb2YgdGhlIGNvbnRhaW5lciBoZWlnaHQgYW5kL29yIHdpZHRoPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBhbmltYXRlUmVzaXplQ29udGFpbmVyOiBmYWxzZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBEaXNhYmxlIHRoZSB0cmFuc2l0aW9uaW5nIG9mIHRoZSBjb250YWluZXIgaGVpZ2h0IGFuZC9vciB3aWR0aCBmb3IgbW9iaWxlIGRldmljZXMgb25seTwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgYW5pbWF0ZVJlc2l6ZUNvbnRhaW5lcjogbXlGZWF0dXJlVGVzdHMuaXNNb2JpbGUgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhbmltYXRlUmVzaXplQ29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIHRydWVcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5hbmltYXRlUmVzaXplQ29udGFpbmVyID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRhcmdldFxuICAgICAgICAgKiBlbGVtZW50cyBhcyB0aGV5IGNoYW5nZSB0aHJvdWdob3V0IHRoZSBjb3Vyc2Ugb2YgYW4gYW5pbWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIG9mdGVuIGEgbXVzdCBmb3IgZmxleC1ib3ggZ3JpZCBsYXlvdXRzIHdoZXJlIHRoZSBzaXplIG9mIHRhcmdldCBlbGVtZW50cyBtYXkgY2hhbmdlXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiBmaW5hbCB0aGVpciBwb3NpdGlvbiBpbiByZWxhdGlvbiB0byB0aGVpciBzaWJsaW5ncywgb3IgZm9yIGAuY2hhbmdlTGF5b3V0KClgXG4gICAgICAgICAqIG9wZXJhdGlvbnMgd2hlcmUgdGhlIHNpemUgb2YgdGFyZ2V0cyBjaGFuZ2UgYmV0d2VlbiBsYXlvdXRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOQjogVGhpcyBmZWF0dXJlIHJlcXVpcmVzIGFkZGl0aW9uYWwgY2FsY3VsYXRpb25zIGFuZCBtYW5pcHVsYXRpb24gdG8gbm9uLWhhcmR3YXJlLWFjY2VsZXJhdGVkXG4gICAgICAgICAqIHByb3BlcnRpZXMgd2hpY2ggbWF5IGFkdmVyc2VseSBhZmZlY3QgcGVyZm9ybWFuY2Ugb24gc2xvd2VyIGRldmljZXMsIGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgICogZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRW5hYmxlIHRoZSB0cmFuc2l0aW9uaW5nIG9mIHRhcmdldCB3aWR0aHMgYW5kIGhlaWdodHM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGFuaW1hdGVSZXNpemVUYXJnZXRzOiB0cnVlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgYW5pbWF0ZVJlc2l6ZVRhcmdldHNcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgZmFsc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5hbmltYXRlUmVzaXplVGFyZ2V0cyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBmdW5jdGlvbiB1c2VkIHRvIG1hbmlwdWxhdGUgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBzdGFnZ2VyIGRlbGF5IGlzXG4gICAgICAgICAqIGluY3JlbWVudGVkIHdoZW4gdXNpbmcgdGhlIOKAmHN0YWdnZXLigJkgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzaW5nIHRoZSAnc3RhZ2dlcicgZWZmZWN0LCB0aGUgZGVsYXkgYXBwbGllZCB0byBlYWNoIHRhcmdldCBlbGVtZW50IGlzIGluY3JlbWVudGVkXG4gICAgICAgICAqIGJhc2VkIG9uIGl0cyBpbmRleC4gWW91IG1heSBjcmVhdGUgYSBjdXN0b20gZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlXG4gICAgICAgICAqIGRlbGF5IGlzIGluY3JlbWVudGVkIGFuZCBjcmVhdGUgZW5nYWdpbmcgbm9uLWxpbmVhciBzdGFnZ2VyIGVmZmVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCBlbGVtZW50IGFzIGEgcGFyYW1ldGVyLCBhbmQgbXVzdFxuICAgICAgICAgKiByZXR1cm4gYW4gaW50ZWdlciB3aGljaCBzZXJ2ZXMgYXMgdGhlIG11bHRpcGxpZXIgZm9yIHRoZSBzdGFnZ2VyIGRlbGF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFN0YWdnZXIgdGFyZ2V0IGVsZW1lbnRzIGJ5IGNvbHVtbiBpbiBhIDMtY29sdW1uIGdyaWQ8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdmYWRlIHN0YWdnZXIoMTAwbXMpJyxcbiAgICAgICAgICogICAgICAgICBzdGFnZ2VyU2VxdWVuY2U6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICogICAgICAgICAgICAgcmV0dXJuIGkgJSAzO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogVXNpbmcgYW4gYWxnb3JpdGhtIHRvIHByb2R1Y2UgYSBtb3JlIGNvbXBsZXggc2VxdWVuY2U8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdmYWRlIHN0YWdnZXIoMTAwbXMpJyxcbiAgICAgICAgICogICAgICAgICBzdGFnZ2VyU2VxdWVuY2U6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICogICAgICAgICAgICAgcmV0dXJuICgyKmkpIC0gKDUqKChpLzMpIC0gKCgxLzMpICogKGklMykpKSk7XG4gICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHN0YWdnZXJTZXF1ZW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Z1bmN0aW9ufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnN0YWdnZXJTZXF1ZW5jZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciBvciBub3QgdG8gcmV2ZXJzZSB0aGUgZGlyZWN0aW9uIG9mIGB0cmFuc2xhdGVgXG4gICAgICAgICAqIGFuZCBgcm90YXRlYCB0cmFuc2Zvcm1zIGZvciBlbGVtZW50cyBiZWluZyBmaWx0ZXJlZCBvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjYXJvdXNlbC1saWtlIGFuaW1hdGlvbnMgd2hlcmUgZWxlbWVudHMgZW50ZXIgYW5kIGV4aXRcbiAgICAgICAgICogZnJvbSBvcHBvc2l0ZSBkaXJlY3Rpb25zLiBJZiBlbmFibGVkLCB0aGUgZWZmZWN0IGB0cmFuc2xhdGVYKC0xMDAlKWAgZm9yIGVsZW1lbnRzXG4gICAgICAgICAqIGJlaW5nIGZpbHRlcmVkIGluIHdvdWxkIGJlY29tZSBgdHJhbnNsYXRlWCgxMDAlKWAgZm9yIHRhcmdldHMgYmVpbmcgZmlsdGVyZWQgb3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgY2FuIGFsc28gYmUgYWNoaWV2ZWQgYnkgcHJvdmlkaW5nIHNlcGVyYXRlIGVmZmVjdHNcbiAgICAgICAgICogc3RyaW5ncyBmb3IgYGNvbmZpZy5hbmltYXRpb24uZWZmZWN0c0luYCBhbmQgYGNvbmZpZy5hbmltYXRpb24uZWZmZWN0c091dGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFJldmVyc2UgdGhlIGRlc2lyZWQgZGlyZWN0aW9uIG9uIGFueSB0cmFuc2xhdGUvcm90YXRlIGVmZmVjdCBmb3IgdGFyZ2V0cyBiZWluZyBmaWx0ZXJlZCBvdXQ8L2NhcHRpb24+XG4gICAgICAgICAqIC8vIEVsZW1lbnRzIGJlaW5nIGZpbHRlcmVkIGluIHdpbGwgYmUgdHJhbnNsYXRlZCBmcm9tICcxMDAlJyB0byAnMCcgd2hpbGVcbiAgICAgICAgICogLy8gZWxlbWVudHMgYmVpbmcgZmlsdGVyZWQgb3V0IHdpbGwgYmUgdHJhbnNsYXRlZCBmcm9tIDAgdG8gJy0xMDAlJ1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlZmZlY3RzOiAnZmFkZSB0cmFuc2xhdGVYKDEwMCUpJyxcbiAgICAgICAgICogICAgICAgICByZXZlcnNlT3V0OiB0cnVlLFxuICAgICAgICAgKiAgICAgICAgIG51ZGdlOiBmYWxzZSAvLyBEaXNhYmxlIG51ZGdpbmcgdG8gY3JlYXRlIGEgY2Fyb3VzZWwtbGlrZSBlZmZlY3RcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICByZXZlcnNlT3V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIGZhbHNlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucmV2ZXJzZU91dCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIFwibnVkZ2VcIiB0aGUgYW5pbWF0aW9uIHBhdGggb2YgdGFyZ2V0c1xuICAgICAgICAgKiB3aGVuIHRoZXkgYXJlIGJlaW5nIGZpbHRlcmVkIGluIGFuZCBvdXQgc2ltdWxhdGVub3VzbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaGFzIGJlZW4gdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgTWl4SXRVcCBzaW5jZSB2ZXJzaW9uIDEsIGJ1dCBpdFxuICAgICAgICAgKiBtYXkgYmUgZGVzaXJhYmxlIHRvIGRpc2FibGUgdGhpcyBlZmZlY3Qgd2hlbiBmaWx0ZXJpbmcgZGlyZWN0bHkgZnJvbVxuICAgICAgICAgKiBvbmUgZXhjbHVzaXZlIHNldCBvZiB0YXJnZXRzIHRvIGEgZGlmZmVyZW50IGV4Y2x1c2l2ZSBzZXQgb2YgdGFyZ2V0cyxcbiAgICAgICAgICogdG8gY3JlYXRlIGEgY2Fyb3VzZWwtbGlrZSBlZmZlY3QsIG9yIGEgZ2VuZXJhbGx5IG1vcmUgc3VidGxlIGFuaW1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRGlzYWJsZSB0aGUgXCJudWRnaW5nXCIgb2YgdGFyZ2V0cyBiZWluZyBmaWx0ZXJlZCBpbiBhbmQgb3V0IHNpbXVsYXRlbm91c2x5PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBudWRnZTogZmFsc2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBudWRnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICB0cnVlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubnVkZ2UgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIGNsYW1wIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciB3aGlsZSBNaXhJdFVwJ3NcbiAgICAgICAgICogZ2VvbWV0cnkgdGVzdHMgYXJlIGNhcnJpZWQgb3V0IGJlZm9yZSBhbiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHByZXZlbnQgc2Nyb2xsLWJhciBmbGlja2VyLCBjbGFtcGluZyBpcyB0dXJuZWQgb24gYnkgZGVmYXVsdC4gQnV0IGluIHRoZSBjYXNlIHdoZXJlIHRoZVxuICAgICAgICAgKiBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBtaWdodCBhZmZlY3QgaXRzIHZlcnRpY2FsIHBvc2l0aW9uaW5nIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICAgKiAoZS5nLiBhIHZlcnRpY2FsbHktY2VudGVyZWQgY29udGFpbmVyKSwgdGhpcyBzaG91bGQgYmUgdHVybmVkIG9mZiB0byBlbnN1cmUgYWNjdXJhdGVcbiAgICAgICAgICogdGVzdCByZXN1bHRzIGFuZCBhIHNtb290aCBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGUgY29udGFpbmVyIGhlaWdodC1jbGFtcGluZzwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgY2xhbXBIZWlnaHQ6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY2xhbXBIZWlnaHRcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNsYW1wSGVpZ2h0ID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0byBjbGFtcCB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciB3aGlsZSBNaXhJdFVwJ3NcbiAgICAgICAgICogZ2VvbWV0cnkgdGVzdHMgYXJlIGNhcnJpZWQgb3V0IGJlZm9yZSBhbiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHByZXZlbnQgc2Nyb2xsLWJhciBmbGlja2VyLCBjbGFtcGluZyBpcyB0dXJuZWQgb24gYnkgZGVmYXVsdC4gQnV0IGluIHRoZSBjYXNlIHdoZXJlIHRoZVxuICAgICAgICAgKiB3aWR0aCBvZiB0aGUgY29udGFpbmVyIG1pZ2h0IGFmZmVjdCBpdHMgaG9yaXR6b250YWwgcG9zaXRpb25pbmcgaW4gdGhlIHZpZXdwb3J0XG4gICAgICAgICAqIChlLmcuIGEgaG9yaXpvbnRhbGwtY2VudGVyZWQgY29udGFpbmVyKSwgdGhpcyBzaG91bGQgYmUgdHVybmVkIG9mZiB0byBlbnN1cmUgYWNjdXJhdGVcbiAgICAgICAgICogdGVzdCByZXN1bHRzIGFuZCBhIHNtb290aCBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGUgY29udGFpbmVyIHdpZHRoLWNsYW1waW5nPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBjbGFtcFdpZHRoOiBmYWxzZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGNsYW1wV2lkdGhcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNsYW1wV2lkdGggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0FuaW1hdGlvbik7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0FuaW1hdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdBbmltYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdBbmltYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gdGhlIGJlaGF2aW9yIG9mIHRoZSBNaXhlci5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBiZWhhdmlvclxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMS4xMlxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdCZWhhdmlvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRvIGFsbG93IFwibGl2ZVwiIHNvcnRpbmcgb2YgdGhlIG1peGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCZWNhdXNlIG9mIHRoZSBleHBlbnNpdmUgbmF0dXJlIG9mIHNvcnRpbmcsIE1peEl0VXAgbWFrZXMgdXNlIG9mIHNldmVyYWxcbiAgICAgICAgICogaW50ZXJuYWwgb3B0aW1pemF0aW9ucyB0byBza2lwIHJlZHVuZGFudCBzb3J0aW5nIG9wZXJhdGlvbnMsIHN1Y2ggYXMgd2hlblxuICAgICAgICAgKiB0aGUgbmV3bHkgcmVxdWVzdGVkIHNvcnQgY29tbWFuZCBpcyB0aGUgc2FtZSBhcyB0aGUgYWN0aXZlIG9uZS4gVGhlIGNhdmVhdFxuICAgICAgICAgKiB0byB0aGlzIG9wdGltaXphdGlvbiBpcyB0aGF0IFwibGl2ZVwiIGVkaXRzIHRvIHRoZSB2YWx1ZSBvZiBhIHRhcmdldCdzIHNvcnRpbmdcbiAgICAgICAgICogYXR0cmlidXRlIHdpbGwgYmUgaWdub3JlZCB3aGVuIHJlcXVlc3RpbmcgYSByZS1zb3J0IGJ5IHRoZSBzYW1lIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgc2V0dGluZyB0byBgYmVoYXZpb3IubGl2ZVNvcnRgIHRvIGB0cnVlYCwgdGhlIG1peGVyIHdpbGwgYWx3YXlzIHJlLXNvcnRcbiAgICAgICAgICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgc29ydGluZyBhdHRyaWJ1dGUgYW5kIG9yZGVyIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRW5hYmxpbmcgYGxpdmVTb3J0YCB0byBhbGxvdyBmb3IgcmUtc29ydGluZzwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYmVoYXZpb3I6IHtcbiAgICAgICAgICogICAgICAgICBsaXZlU29ydDogdHJ1ZVxuICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBzb3J0OiAnZWRpdGVkOmRlc2MnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdGFyZ2V0ID0gY29udGFpbmVyRWwuY2hpbGRyZW5bM107XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZWRpdGVkJykpOyAvLyAnMjAxNS0wNC0yNCdcbiAgICAgICAgICpcbiAgICAgICAgICogdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1lZGl0ZWQnLCAnMjAxNy0wOC0xMCcpOyAvLyBVcGRhdGUgdGhlIHRhcmdldCdzIGVkaXRlZCBkYXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ2VkaXRlZDpkZXNjJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgLy8gVGhlIHRhcmdldCBpcyBub3cgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRhcmdldHNbMF0gPT09IHRhcmdldCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbGl2ZVNvcnRcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmJlaGF2aW9yXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBmYWxzZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmxpdmVTb3J0ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29uZmlnQmVoYXZpb3IpO1xuXG4gICAgbWl4aXR1cC5Db25maWdCZWhhdmlvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdCZWhhdmlvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbmZpZ0JlaGF2aW9yO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbnMgdG8gYmUgaW52b2tlZCBhdCB2YXJpb3VzXG4gICAgICogcG9pbnRzIHdpdGhpbiB0aGUgbGlmZWN5Y2xlIG9mIGEgbWl4ZXIgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBhbmFsb2dvdXMgdG8gYW4gZXZlbnQgb2YgdGhlIHNhbWUgbmFtZSB0cmlnZ2VyZWQgZnJvbSB0aGVcbiAgICAgKiBjb250YWluZXIgZWxlbWVudCwgYW5kIGlzIGludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbGJhY2sgZnVuY3Rpb25zIHJlY2VpdmUgdGhlIGN1cnJlbnQgYHN0YXRlYCBvYmplY3QgYXMgdGhlaXIgZmlyc3RcbiAgICAgKiBhcmd1bWVudCwgYXMgd2VsbCBhcyBvdGhlciBtb3JlIHNwZWNpZmljIGFyZ3VtZW50cyBkZXNjcmliZWQgYmVsb3cuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgY2FsbGJhY2tzXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnQ2FsbGJhY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IE1peEl0VXAgb3BlcmF0aW9uIGlzIHJlcXVlc3RlZFxuICAgICAgICAgKiBhbmQgYmVmb3JlIGFuaW1hdGlvbnMgaGF2ZSBiZWd1bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBzZWNvbmQgYGZ1dHVyZVN0YXRlYCBhcmd1bWVudCBpcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGZpbmFsXG4gICAgICAgICAqIHN0YXRlIG9mIHRoZSBtaXhlciBvbmNlIHRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEFkZGluZyBhbiBgb25NaXhTdGFydGAgY2FsbGJhY2sgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgIG9uTWl4U3RhcnQ6IGZ1bmN0aW9uKHN0YXRlLCBmdXR1cmVTdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIG9wZXJhdGlvbi4uLicpO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBvbk1peFN0YXJ0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jYWxsYmFja3NcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMub25NaXhTdGFydCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuIGEgTWl4SXRVcCBvcGVyYXRpb24gaXMgcmVxdWVzdGVkIHdoaWxlIGFub3RoZXJcbiAgICAgICAgICogb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLCBhbmQgdGhlIGFuaW1hdGlvbiBxdWV1ZSBpcyBmdWxsLCBvciBxdWV1ZWluZ1xuICAgICAgICAgKiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQWRkaW5nIGFuIGBvbk1peEJ1c3lgIGNhbGxiYWNrIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICogICAgICAgICBvbk1peEJ1c3k6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWl4ZXIgYnVzeScpO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBvbk1peEJ1c3lcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNhbGxiYWNrc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtmdW5jdGlvbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIG51bGxcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5vbk1peEJ1c3kgID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIGFueSBNaXhJdFVwIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLCBhbmQgdGhlXG4gICAgICAgICAqIHN0YXRlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEFkZGluZyBhbiBgb25NaXhFbmRgIGNhbGxiYWNrIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICogICAgICAgICBvbk1peEVuZDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPcGVyYXRpb24gY29tcGxldGUnKTtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgb25NaXhFbmRcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNhbGxiYWNrc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtmdW5jdGlvbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIG51bGxcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5vbk1peEVuZCAgID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIHdoZW5ldmVyIGFuIG9wZXJhdGlvbiBcImZhaWxzXCIsIGkuZS4gbm8gdGFyZ2V0c1xuICAgICAgICAgKiBjb3VsZCBiZSBmb3VuZCBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIGZpbHRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQWRkaW5nIGFuIGBvbk1peEZhaWxgIGNhbGxiYWNrIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICogICAgICAgICBvbk1peEZhaWw6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gaXRlbXMgY291bGQgYmUgZm91bmQgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBmaWx0ZXInKTtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgb25NaXhGYWlsXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jYWxsYmFja3NcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMub25NaXhGYWlsICA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuZXZlciBhIE1peEl0VXAgY29udHJvbCBpcyBjbGlja2VkLCBhbmQgYmVmb3JlIGl0c1xuICAgICAgICAgKiByZXNwZWN0aXZlIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjbGlja2VkIGVsZW1lbnQgaXMgYXNzaWduZWQgdG8gdGhlIGB0aGlzYCBrZXl3b3JkIHdpdGhpbiB0aGUgZnVuY3Rpb24uIFRoZSBvcmlnaW5hbFxuICAgICAgICAgKiBjbGljayBldmVudCBpcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWZcbiAgICAgICAgICogdXNpbmcgYDxhPmAgdGFncyBhcyBjb250cm9scyB3aGVyZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBuZWVkcyB0byBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybmluZyBgZmFsc2VgIGZyb20gdGhlIGNhbGxiYWNrIHdpbGwgcHJldmVudCB0aGUgY29udHJvbCBjbGljayBmcm9tIHRyaWdnZXJpbmdcbiAgICAgICAgICogYW4gb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IEFkZGluZyBhbiBgb25NaXhDbGlja2AgY2FsbGJhY2sgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgIG9uTWl4Q2xpY2s6IGZ1bmN0aW9uKHN0YXRlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGhlIGNvbnRyb2wgXCInICsgdGhpcy5pbm5lclRleHQgKyAnXCIgd2FzIGNsaWNrZWQnKTtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IFVzaW5nIGBvbk1peENsaWNrYCB0byBtYW5pcHVsYXRlIHRoZSBvcmlnaW5hbCBjbGljayBldmVudDwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAqICAgICAgICAgb25NaXhDbGljazogZnVuY3Rpb24oc3RhdGUsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICogICAgICAgICAgICAgIC8vIFByZXZlbnQgb3JpZ2luYWwgY2xpY2sgZXZlbnQgZnJvbSBidWJibGluZyB1cDpcbiAgICAgICAgICogICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgY2xpY2tlZCBlbGVtZW50OlxuICAgICAgICAgKiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogVXNpbmcgYG9uTWl4Q2xpY2tgIHRvIGNvbmRpdGlvbmFsbHkgY2FuY2VsIG9wZXJhdGlvbnM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgIG9uTWl4Q2xpY2s6IGZ1bmN0aW9uKHN0YXRlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAvLyBQZXJmb3JtIHNvbWUgY29uZGl0aW9uYWwgY2hlY2s6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICAgICBpZiAobXlBcHAuaXNMb2FkaW5nKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgLy8gQnkgcmV0dXJuaW5nIGZhbHNlLCB3ZSBjYW4gcHJldmVudCB0aGUgY29udHJvbCBjbGljayBmcm9tIHRyaWdnZXJpbmcgYW4gb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICogICAgICAgICAgICAgIH1cbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgb25NaXhDbGlja1xuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2FsbGJhY2tzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Z1bmN0aW9ufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm9uTWl4Q2xpY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0NhbGxiYWNrcyk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0NhbGxiYWNrcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdDYWxsYmFja3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdDYWxsYmFja3M7XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gY2xpY2thYmxlIGNvbnRyb2wgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgY29udHJvbHNcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCBjb250cm9scyBzaG91bGQgYmUgZW5hYmxlZCBmb3IgdGhlIG1peGVyIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAgKGRlZmF1bHQgYmVoYXZpb3IpLCBNaXhJdFVwIHdpbGwgc2VhcmNoIHRoZSBET00gZm9yIGFueSBjbGlja2FibGUgZWxlbWVudHMgd2l0aFxuICAgICAgICAgKiBgZGF0YS1maWx0ZXJgLCBgZGF0YS1zb3J0YCBvciBgZGF0YS10b2dnbGVgIGF0dHJpYnV0ZXMsIGFuZCBiaW5kIHRoZW0gZm9yIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCwgbm8gY2xpY2sgaGFuZGxlcnMgd2lsbCBiZSBib3VuZCwgYW5kIGFsbCBmdW5jdGlvbmFsaXR5IG11c3QgdGhlcmVmb3JlIGJlIHBlcmZvcm1lZFxuICAgICAgICAgKiB2aWEgdGhlIG1peGVyJ3MgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSBkbyBub3QgaW50ZW5kIHRvIHVzZSB0aGUgZGVmYXVsdCBjb250cm9scywgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAgd2lsbFxuICAgICAgICAgKiBtYXJnaW5hbGx5IGltcHJvdmUgdGhlIHN0YXJ0dXAgdGltZSBvZiB5b3VyIG1peGVyIGluc3RhbmNlLCBhbmQgd2lsbCBhbHNvIHByZXZlbnQgYW55IG90aGVyIGFjdGl2ZVxuICAgICAgICAgKiBtaXhlciBpbnN0YW5jZXMgaW4gdGhlIERPTSB3aGljaCBhcmUgYm91bmQgdG8gY29udHJvbHMgZnJvbSBjb250cm9sbGluZyB0aGUgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGluZyBjb250cm9sczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY29udHJvbHM6IHtcbiAgICAgICAgICogICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBXaXRoIHRoZSBkZWZhdWx0IGNvbnRyb2xzIGRpc2FibGVkLCB3ZSBjYW4gb25seSBjb250cm9sXG4gICAgICAgICAqIC8vIHRoZSBtaXhlciB2aWEgaXRzIEFQSSBtZXRob2RzLCBlLmcuOlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5maWx0ZXIoJy5jYXQtMScpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZW5hYmxlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jb250cm9sc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciBvciBub3QgdG8gdXNlIGV2ZW50IGRlbGVnYXRpb24gd2hlbiBiaW5kaW5nIGNsaWNrIGV2ZW50c1xuICAgICAgICAgKiB0byB0aGUgZGVmYXVsdCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCAoZGVmYXVsdCBiZWhhdmlvciksIGVhY2ggY29udHJvbCBidXR0b24gaW4gdGhlIERPTSB3aWxsIGJlIGZvdW5kIGFuZFxuICAgICAgICAgKiBpbmRpdmlkdWFsbHkgYm91bmQgd2hlbiBhIG1peGVyIGlzIGluc3RhbnRpYXRlZCwgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIGFjdGlvbnNcbiAgICAgICAgICogY2FjaGVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYHRydWVgLCBhIHNpbmdsZSBjbGljayBoYW5kbGVyIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgYHdpbmRvd2AgKG9yIGNvbnRhaW5lciBlbGVtZW50IC0gc2VlXG4gICAgICAgICAqIGBjb25maWcuY29udHJvbHMuc2NvcGVgKSwgYW5kIGFueSBjbGljayBldmVudHMgdHJpZ2dlcmVkIGJ5IGVsZW1lbnRzIHdpdGggYGRhdGEtZmlsdGVyYCxcbiAgICAgICAgICogYGRhdGEtc29ydGAgb3IgYGRhdGEtdG9nZ2xlYCBhdHRyaWJ1dGVzIHByZXNlbnQgd2lsbCBiZSBoYW5kbGVkIGFzIHRoZXkgcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSByZXF1aXJlIGEgdXNlciBpbnRlcmZhY2Ugd2hlcmUgY29udHJvbCBidXR0b25zIG1heSBiZSBhZGRlZCwgcmVtb3ZlZCwgb3IgY2hhbmdlZCBkdXJpbmcgdGhlXG4gICAgICAgICAqIGxpZmV0aW1lIG9mIGEgbWl4ZXIsIGBjb250cm9scy5saXZlYCBzaG91bGQgYmUgc2V0IHRvIGB0cnVlYC4gVGhlcmUgaXMgYSBtYXJnaW5hbCBidXQgdW5hdm9pZGFibGVcbiAgICAgICAgICogcGVyZm9ybWFuY2UgZGVmaWNpdCB3aGVuIHVzaW5nIGxpdmUgY29udHJvbHMsIGFzIHRoZSB2YWx1ZSBvZiBlYWNoIGNvbnRyb2wgYnV0dG9uIG11c3QgYmUgcmVhZFxuICAgICAgICAgKiBmcm9tIHRoZSBET00gaW4gcmVhbCB0aW1lIG9uY2UgdGhlIGNsaWNrIGV2ZW50IGhhcyBwcm9wYWdhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXR0aW5nIGxpdmUgY29udHJvbHM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNvbnRyb2xzOiB7XG4gICAgICAgICAqICAgICAgICAgbGl2ZTogdHJ1ZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ29udHJvbCBidXR0b25zIGNhbiBub3cgYmUgYWRkZWQsIHJlbW92ZSBhbmQgY2hhbmdlZCB3aXRob3V0IGJyZWFraW5nXG4gICAgICAgICAqIC8vIHRoZSBtaXhlcidzIFVJXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBsaXZlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jb250cm9sc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmxpdmUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgZGljdGF0aW5nIHRoZSBcInNjb3BlXCIgdG8gdXNlIHdoZW4gYmluZGluZyBvciBxdWVyeWluZyB0aGUgZGVmYXVsdCBjb250cm9scy4gVGhlIGF2YWlsYWJsZVxuICAgICAgICAgKiB2YWx1ZXMgYXJlIGAnZ2xvYmFsJ2Agb3IgYCdsb2NhbCdgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgJ2dsb2JhbCdgIChkZWZhdWx0IGJlaGF2aW9yKSwgTWl4SXRVcCB3aWxsIHF1ZXJ5IHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIGNvbnRyb2wgYnV0dG9uc1xuICAgICAgICAgKiB0byBiaW5kLCBvciBkZWxlZ2F0ZSBjbGljayBldmVudHMgZnJvbSAoc2VlIGBjb25maWcuY29udHJvbHMubGl2ZWApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgJ2xvY2FsJ2AsIE1peEl0VXAgd2lsbCBvbmx5IHF1ZXJ5IChvciBiaW5kIGNsaWNrIGV2ZW50cyB0bykgaXRzIG93biBjb250YWluZXIgZWxlbWVudC5cbiAgICAgICAgICogVGhpcyBtYXkgYmUgZGVzaXJlYWJsZSBpZiB5b3UgcmVxdWlyZSBtdWx0aXBsZSBhY3RpdmUgbWl4ZXIgaW5zdGFuY2VzIHdpdGhpbiB0aGUgc2FtZSBkb2N1bWVudCwgd2l0aFxuICAgICAgICAgKiBjb250cm9scyB0aGF0IHdvdWxkIG90aGVyd2lzZSBpbnRlZmVyZSB3aXRoIGVhY2ggb3RoZXIgaWYgc2NvcGVkIGdsb2JhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb252ZXJzZWx5LCBpZiB5b3Ugd2lzaCB0byBjb250cm9sIG11bHRpcGxlIGluc3RhbmNlcyB3aXRoIGEgc2luZ2xlIFVJLCB5b3Ugd291bGQgY3JlYXRlIG9uZVxuICAgICAgICAgKiBzZXQgb2YgY29udHJvbHMgYW5kIGtlZXAgdGhlIGNvbnRyb2xzIHNjb3BlIG9mIGVhY2ggbWl4ZXIgc2V0IHRvIGBnbG9iYWxgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXR0aW5nICdsb2NhbCcgc2NvcGVkIGNvbnRyb2xzPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXJPbmUgPSBtaXhpdHVwKGNvbnRhaW5lck9uZSwge1xuICAgICAgICAgKiAgICAgY29udHJvbHM6IHtcbiAgICAgICAgICogICAgICAgICBzY29wZTogJ2xvY2FsJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyVHdvID0gbWl4aXR1cChjb250YWluZXJUd28sIHtcbiAgICAgICAgICogICAgIGNvbnRyb2xzOiB7XG4gICAgICAgICAqICAgICAgICAgc2NvcGU6ICdsb2NhbCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEJvdGggbWl4ZXJzIGNhbiBub3cgZXhpc3Qgd2l0aGluIHRoZSBzYW1lIGRvY3VtZW50IHdpdGhcbiAgICAgICAgICogLy8gaXNvbGF0ZWQgY29udHJvbHMgcGxhY2VkIHdpdGhpbiB0aGVpciBjb250YWluZXIgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzY29wZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY29udHJvbHNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2dsb2JhbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5zY29wZSA9ICdnbG9iYWwnOyAvLyBlbnVtOiBbJ2xvY2FsJyAsJ2dsb2JhbCddXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIGRpY3RhdGluZyB0aGUgdHlwZSBvZiBsb2dpYyB0byBhcHBseSB3aGVuIGNvbmNhdGVuYXRpbmcgdGhlIGZpbHRlciBzZWxlY3RvcnMgb2ZcbiAgICAgICAgICogYWN0aXZlIHRvZ2dsZSBidXR0b25zIChpLmUuIGFueSBjbGlja2FibGUgZWxlbWVudCB3aXRoIGEgYGRhdGEtdG9nZ2xlYCBhdHRyaWJ1dGUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYCdvcidgIChkZWZhdWx0IGJlaGF2aW9yKSwgc2VsZWN0b3JzIHdpbGwgYmUgY29uY2F0ZW5hdGVkIHRvZ2V0aGVyIGFzXG4gICAgICAgICAqIGEgY29tbWEtc2VwZXJhdGVkIGxpc3QuIEZvciBleGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBgJy5jYXQtMSwgLmNhdC0yJ2AgKHNob3dzIGFueSBlbGVtZW50cyBtYXRjaGluZyBgJy5jYXQtMSdgIE9SIGAnLmNhdC0yJ2ApXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHNldCB0byBgJ2FuZCdgLCBzZWxlY3RvcnMgd2lsbCBiZSBkaXJlY3RseSBjb25jYXRlbmF0ZWQgdG9nZXRoZXIuIEZvciBleGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBgJy5jYXQtMS5jYXQtMidgIChzaG93cyBhbnkgZWxlbWVudHMgd2hpY2ggbWF0Y2ggYm90aCBgJy5jYXQtMSdgIEFORCBgJy5jYXQtMidgKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXR0aW5nIFwiYW5kXCIgdG9nZ2xlIGxvZ2ljPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjb250cm9sczoge1xuICAgICAgICAgKiAgICAgICAgIHRvZ2dsZUxvZ2ljOiAnYW5kJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRvZ2dsZUxvZ2ljXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jb250cm9sc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnb3InXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudG9nZ2xlTG9naWMgPSAnb3InOyAvLyBlbnVtOiBbJ29yJywgJ2FuZCddXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIGRpY3RhdGluZyB0aGUgZmlsdGVyIGJlaGF2aW9yIHdoZW4gYWxsIHRvZ2dsZXMgYXJlIGluYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgJ2FsbCdgIChkZWZhdWx0IGJlaGF2aW9yKSwgKmFsbCogdGFyZ2V0cyB3aWxsIGJlIHNob3duIGJ5IGRlZmF1bHRcbiAgICAgICAgICogd2hlbiBubyB0b2dnbGVzIGFyZSBhY3RpdmUsIG9yIGF0IHRoZSBtb21lbnQgYWxsIGFjdGl2ZSB0b2dnbGVzIGFyZSB0b2dnbGVkIG9mZi5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBzZXQgdG8gYCdub25lJ2AsIG5vIHRhcmdldHMgd2lsbCBiZSBzaG93biBieSBkZWZhdWx0IHdoZW4gbm8gdG9nZ2xlcyBhcmVcbiAgICAgICAgICogYWN0aXZlLCBvciBhdCB0aGUgbW9tZW50IGFsbCBhY3RpdmUgdG9nZ2xlcyBhcmUgdG9nZ2xlZCBvZmYuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogU2V0dGluZyB0aGUgZGVmYXVsdCB0b2dnbGUgYmVoYXZpb3IgdG8gYCdhbGwnYDwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY29udHJvbHM6IHtcbiAgICAgICAgICogICAgICAgICB0b2dnbGVEZWZhdWx0OiAnYWxsJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIudG9nZ2xlT24oJy5jYXQtMicpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAvLyBEZWFjdGl2YXRlIGFsbCBhY3RpdmUgdG9nZ2xlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHJldHVybiBtaXhlci50b2dnbGVPZmYoJy5jYXQtMicpXG4gICAgICAgICAqICAgICB9KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yKTsgLy8gJ2FsbCdcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93KTsgLy8gMTJcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IFNldHRpbmcgdGhlIGRlZmF1bHQgdG9nZ2xlIGJlaGF2aW9yIHRvIGAnbm9uZSdgPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjb250cm9sczoge1xuICAgICAgICAgKiAgICAgICAgIHRvZ2dsZURlZmF1bHQ6ICdub25lJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIudG9nZ2xlT24oJy5jYXQtMicpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAvLyBEZWFjdGl2YXRlIGFsbCBhY3RpdmUgdG9nZ2xlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHJldHVybiBtaXhlci50b2dnbGVPZmYoJy5jYXQtMicpXG4gICAgICAgICAqICAgICB9KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yKTsgLy8gJ25vbmUnXG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRvdGFsU2hvdyk7IC8vIDBcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdG9nZ2xlRGVmYXVsdFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY29udHJvbHNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2FsbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50b2dnbGVEZWZhdWx0ID0gJ2FsbCc7IC8vIGVudW06IFsnYWxsJywgJ25vbmUnXVxuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0NvbnRyb2xzKTtcblxuICAgIG1peGl0dXAuQ29uZmlnQ29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnQ29udHJvbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdDb250cm9scztcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgb2YgcHJvcGVydGllcyBkZWZpbmluZyB0aGUgb3V0cHV0IGFuZCBzdHJ1Y3R1cmUgb2YgY2xhc3MgbmFtZXMgcHJvZ3JhbW1hdGljYWxseVxuICAgICAqIGFkZGVkIHRvIGNvbnRyb2xzIGFuZCBjb250YWluZXJzIHRvIHJlZmxlY3QgdGhlIHN0YXRlIG9mIHRoZSBtaXhlci5cbiAgICAgKlxuICAgICAqIE1vc3QgY29tbW9ubHksIGNsYXNzIG5hbWVzIGFyZSBhZGRlZCB0byBjb250cm9scyBieSBNaXhJdFVwIHRvIGluZGljYXRlIHRoYXRcbiAgICAgKiB0aGUgY29udHJvbCBpcyBhY3RpdmUgc28gdGhhdCBpdCBjYW4gYmUgc3R5bGVkIGFjY29yZGluZ2x5IC0gYCdtaXhpdHVwLWNvbnRyb2wtYWN0aXZlJ2AgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIFVzaW5nIGEgXCJCRU1cIiBsaWtlIHN0cnVjdHVyZSwgZWFjaCBjbGFzc25hbWUgaXMgYnJva2VuIGludG8gdGhlIHRocmVlIHBhcnRzOlxuICAgICAqIGEgYmxvY2sgbmFtZXNwYWNlIChgJ21peGl0dXAnYCksIGFuIGVsZW1lbnQgbmFtZSAoZS5nLiBgJ2NvbnRyb2wnYCksIGFuZCBhbiBvcHRpb25hbCBtb2RpZmllclxuICAgICAqIG5hbWUgKGUuZy4gYCdhY3RpdmUnYCkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBlYWNoIHBhcnQgb2YgdGhlIGNsYXNzbmFtZSBpcyBjb25jYXRlbmF0ZWQgdG9nZXRoZXIgdXNpbmcgc2luZ2xlIGh5cGhlbnMgYXNcbiAgICAgKiBkZWxpbmVhdG9ycywgYnV0IHRoaXMgY2FuIGJlIGVhc2lseSBjdXN0b21pc2VkIHRvIG1hdGNoIHRoZSBuYW1pbmcgY29udmVudGlvbiBhbmQgc3R5bGUgb2ZcbiAgICAgKiB5b3VyIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgY2xhc3NOYW1lc1xuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbmZpZ0NsYXNzTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImJsb2NrXCIgcG9ydGlvbiwgb3IgdG9wLWxldmVsIG5hbWVzcGFjZSBhZGRlZCB0byB0aGUgc3RhcnQgb2YgYW55IGNsYXNzIG5hbWVzIGNyZWF0ZWQgYnkgTWl4SXRVcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBjaGFuZ2luZyB0aGUgYGNvbmZpZy5jbGFzc05hbWVzLmJsb2NrYCB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcInBvcnRmb2xpby1jb250cm9sLWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogUmVtb3ZpbmcgYGNvbmZpZy5jbGFzc05hbWVzLmJsb2NrYDwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAnJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcImNvbnRyb2wtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGJsb2NrXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdtaXhpdHVwJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmJsb2NrID0gJ21peGl0dXAnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJlbGVtZW50XCIgcG9ydGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhZGRlZCB0byBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBlbGVtZW50Q29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdjb250YWluZXInXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZWxlbWVudENvbnRhaW5lciA9ICdjb250YWluZXInO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJlbGVtZW50XCIgcG9ydGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhZGRlZCB0byBmaWx0ZXIgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGFsbCBmaWx0ZXIsIHNvcnQsIG11bHRpbWl4IGFuZCB0b2dnbGUgY29udHJvbHMgdGFrZSB0aGUgc2FtZSBlbGVtZW50IHZhbHVlIG9mIGAnY29udHJvbCdgLCBidXRcbiAgICAgICAgICogZWFjaCB0eXBlJ3MgZWxlbWVudCB2YWx1ZSBjYW4gYmUgaW5kaXZpZHVhbGx5IG92ZXJ3cml0dGVuIHRvIG1hdGNoIHRoZSB1bmlxdWUgY2xhc3NOYW1lcyBvZiB5b3VyIGNvbnRyb2xzIGFzIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBjaGFuZ2luZyB0aGUgYGNvbmZpZy5jbGFzc05hbWVzLmVsZW1lbnRGaWx0ZXJgIHZhbHVlPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAqICAgICAgICAgZWxlbWVudEZpbHRlcjogJ2ZpbHRlcidcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEFjdGl2ZSBmaWx0ZXIgb3V0cHV0OiBcIm1peGl0dXAtZmlsdGVyLWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogY2hhbmdpbmcgdGhlIGBjb25maWcuY2xhc3NOYW1lcy5ibG9ja2AgYW5kIGBjb25maWcuY2xhc3NOYW1lcy5lbGVtZW50RmlsdGVyYCB2YWx1ZXM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICogICAgICAgICBibG9jazogJ3BvcnRmb2xpbycsXG4gICAgICAgICAqICAgICAgICAgZWxlbWVudEZpbHRlcjogJ2ZpbHRlcidcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEFjdGl2ZSBmaWx0ZXIgb3V0cHV0OiBcInBvcnRmb2xpby1maWx0ZXItYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVsZW1lbnRGaWx0ZXJcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNsYXNzTmFtZXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2NvbnRyb2wnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZWxlbWVudEZpbHRlciA9ICdjb250cm9sJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZWxlbWVudFwiIHBvcnRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gc29ydCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgYWxsIGZpbHRlciwgc29ydCwgbXVsdGltaXggYW5kIHRvZ2dsZSBjb250cm9scyB0YWtlIHRoZSBzYW1lIGVsZW1lbnQgdmFsdWUgb2YgYCdjb250cm9sJ2AsIGJ1dFxuICAgICAgICAgKiBlYWNoIHR5cGUncyBlbGVtZW50IHZhbHVlIGNhbiBiZSBpbmRpdmlkdWFsbHkgb3ZlcndyaXR0ZW4gdG8gbWF0Y2ggdGhlIHVuaXF1ZSBjbGFzc05hbWVzIG9mIHlvdXIgY29udHJvbHMgYXMgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudFNvcnRgIHZhbHVlPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAqICAgICAgICAgZWxlbWVudFNvcnQ6ICdzb3J0J1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIHNvcnQgb3V0cHV0OiBcIm1peGl0dXAtc29ydC1hY3RpdmVcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuYmxvY2tgIGFuZCBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudFNvcnRgIHZhbHVlczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJyxcbiAgICAgICAgICogICAgICAgICBlbGVtZW50U29ydDogJ3NvcnQnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBBY3RpdmUgc29ydCBvdXRwdXQ6IFwicG9ydGZvbGlvLXNvcnQtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVsZW1lbnRTb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdjb250cm9sJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmVsZW1lbnRTb3J0ID0gJ2NvbnRyb2wnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJlbGVtZW50XCIgcG9ydGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhZGRlZCB0byBtdWx0aW1peCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgYWxsIGZpbHRlciwgc29ydCwgbXVsdGltaXggYW5kIHRvZ2dsZSBjb250cm9scyB0YWtlIHRoZSBzYW1lIGVsZW1lbnQgdmFsdWUgb2YgYCdjb250cm9sJ2AsIGJ1dFxuICAgICAgICAgKiBlYWNoIHR5cGUncyBlbGVtZW50IHZhbHVlIGNhbiBiZSBpbmRpdmlkdWFsbHkgb3ZlcndyaXR0ZW4gdG8gbWF0Y2ggdGhlIHVuaXF1ZSBjbGFzc05hbWVzIG9mIHlvdXIgY29udHJvbHMgYXMgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudE11bHRpbWl4YCB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGVsZW1lbnRNdWx0aW1peDogJ211bHRpbWl4J1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIG11bHRpbWl4IG91dHB1dDogXCJtaXhpdHVwLW11bHRpbWl4LWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogY2hhbmdpbmcgdGhlIGBjb25maWcuY2xhc3NOYW1lcy5ibG9ja2AgYW5kIGBjb25maWcuY2xhc3NOYW1lcy5lbGVtZW50TXVsdGltaXhgIHZhbHVlczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJyxcbiAgICAgICAgICogICAgICAgICBlbGVtZW50U29ydDogJ211bHRpbWl4J1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIG11bHRpbWl4IG91dHB1dDogXCJwb3J0Zm9saW8tbXVsdGltaXgtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVsZW1lbnRNdWx0aW1peFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2xhc3NOYW1lc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnY29udHJvbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lbGVtZW50TXVsdGltaXggPSAnY29udHJvbCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImVsZW1lbnRcIiBwb3J0aW9uIG9mIHRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRvZ2dsZSBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgYWxsIGZpbHRlciwgc29ydCwgbXVsdGltaXggYW5kIHRvZ2dsZSBjb250cm9scyB0YWtlIHRoZSBzYW1lIGVsZW1lbnQgdmFsdWUgb2YgYCdjb250cm9sJ2AsIGJ1dFxuICAgICAgICAgKiBlYWNoIHR5cGUncyBlbGVtZW50IHZhbHVlIGNhbiBiZSBpbmRpdmlkdWFsbHkgb3ZlcndyaXR0ZW4gdG8gbWF0Y2ggdGhlIHVuaXF1ZSBjbGFzc05hbWVzIG9mIHlvdXIgY29udHJvbHMgYXMgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudFRvZ2dsZWAgdmFsdWU8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICogICAgICAgICBlbGVtZW50VG9nZ2xlOiAndG9nZ2xlJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIHRvZ2dsZSBvdXRwdXQ6IFwibWl4aXR1cC10b2dnbGUtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBjaGFuZ2luZyB0aGUgYGNvbmZpZy5jbGFzc05hbWVzLmJsb2NrYCBhbmQgYGNvbmZpZy5jbGFzc05hbWVzLmVsZW1lbnRUb2dnbGVgIHZhbHVlczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJyxcbiAgICAgICAgICogICAgICAgICBlbGVtZW50VG9nZ2xlOiAndG9nZ2xlJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIHRvZ2dsZSBvdXRwdXQ6IFwicG9ydGZvbGlvLXRvZ2dsZS1hY3RpdmVcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZWxlbWVudFRvZ2dsZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2xhc3NOYW1lc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnY29udHJvbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lbGVtZW50VG9nZ2xlID0gJ2NvbnRyb2wnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJtb2RpZmllclwiIHBvcnRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gYWN0aXZlIGNvbnRyb2xzLlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbW9kaWZpZXJBY3RpdmVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNsYXNzTmFtZXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2FjdGl2ZSdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5tb2RpZmllckFjdGl2ZSA9ICdhY3RpdmUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJtb2RpZmllclwiIHBvcnRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtb2RpZmllckRpc2FibGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdkaXNhYmxlZCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5tb2RpZmllckRpc2FibGVkID0gJ2Rpc2FibGVkJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwibW9kaWZpZXJcIiBwb3J0aW9uIG9mIHRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBjb250YWluZXIgd2hlbiBpbiBhIFwiZmFpbGVkXCIgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtb2RpZmllckZhaWxlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2xhc3NOYW1lc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnZmFpbGVkJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1vZGlmaWVyRmFpbGVkID0gJ2ZhaWxlZCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxpbmVhdG9yIHVzZWQgYmV0d2VlbiB0aGUgXCJibG9ja1wiIGFuZCBcImVsZW1lbnRcIiBwb3J0aW9ucyBvZiBhbnkgY2xhc3MgbmFtZSBhZGRlZCBieSBNaXhJdFVwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgYmxvY2sgcG9ydGlvbiBpcyBvbW1pdGVkIGJ5IHNldHRpbmcgaXQgdG8gYW4gZW1wdHkgc3RyaW5nLCBubyBkZWxpbmVhdG9yIHdpbGwgYmUgYWRkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IGNoYW5naW5nIHRoZSBkZWxpbmVhdG9yIHRvIG1hdGNoIEJFTSBjb252ZW50aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAqICAgICAgICAgZGVsaW5lYXRvckVsZW1lbnQ6ICdfXydcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGV4YW1wbGUgYWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcIm1peGl0dXBfX2NvbnRyb2wtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGRlbGluZWF0b3JFbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICctJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmRlbGluZWF0b3JFbGVtZW50ID0gJy0nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsaW5lYXRvciB1c2VkIGJldHdlZW4gdGhlIFwiZWxlbWVudFwiIGFuZCBcIm1vZGlmaWVyXCIgcG9ydGlvbnMgb2YgYW55IGNsYXNzIG5hbWUgYWRkZWQgYnkgTWl4SXRVcC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGVsZW1lbnQgcG9ydGlvbiBpcyBvbW1pdGVkIGJ5IHNldHRpbmcgaXQgdG8gYW4gZW1wdHkgc3RyaW5nLCBubyBkZWxpbmVhdG9yIHdpbGwgYmUgYWRkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IGNoYW5naW5nIGJvdGggZGVsaW5lYXRvcnMgdG8gbWF0Y2ggQkVNIGNvbnZlbnRpb248L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICogICAgICAgICBkZWxpbmVhdG9yRWxlbWVudDogJ19fJ1xuICAgICAgICAgKiAgICAgICAgIGRlbGluZWF0b3JNb2RpZmllcjogJy0tJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcIm1peGl0dXBfX2NvbnRyb2wtLWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBkZWxpbmVhdG9yTW9kaWZpZXJcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNsYXNzTmFtZXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJy0nXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZGVsaW5lYXRvck1vZGlmaWVyID0gJy0nO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0NsYXNzTmFtZXMpO1xuXG4gICAgbWl4aXR1cC5Db25maWdDbGFzc05hbWVzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0NsYXNzTmFtZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdDbGFzc05hbWVzO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBwcm9wZXJ0aWVzIHJlbGF0aW5nIHRvIE1peEl0VXAncyBkYXRhc2V0IEFQSS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBkYXRhXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgbmFtZSBvZiB0aGUga2V5IGNvbnRhaW5pbmcgeW91ciBkYXRhIG1vZGVsJ3MgdW5pcXVlXG4gICAgICAgICAqIGlkZW50aWZpZXIgKFVJRCkuIFRvIHVzZSB0aGUgZGF0YXNldCBBUEksIGEgVUlEIGtleSBtdXN0IGJlIHNwZWNpZmllZCBhbmRcbiAgICAgICAgICogYmUgcHJlc2VudCBhbmQgdW5pcXVlIG9uIGFsbCBvYmplY3RzIGluIHRoZSBkYXRhc2V0IHlvdSBwcm92aWRlIHRvIE1peEl0VXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBpZiB5b3VyIGRhdGFzZXQgaXMgbWFkZSB1cCBvZiBNb25nb0RCIGRvY3VtZW50cywgdGhlIFVJRFxuICAgICAgICAgKiBrZXkgd291bGQgYmUgYCdpZCdgIG9yIGAnX2lkJ2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFNldHRpbmcgdGhlIFVJRCB0byBgJ2lkJ2A8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGRhdGE6IHtcbiAgICAgICAgICogICAgICAgICB1aWRLZXk6ICdpZCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICB1aWRLZXlcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmRhdGFcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy51aWRLZXkgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCBNaXhJdFVwIHNob3VsZCBcImRpcnR5IGNoZWNrXCIgZWFjaCBvYmplY3QgaW5cbiAgICAgICAgICogeW91ciBkYXRhc2V0IGZvciBjaGFuZ2VzIHdoZW5ldmVyIGAuZGF0YXNldCgpYCBpcyBjYWxsZWQsIGFuZCByZS1yZW5kZXIgYW55IHRhcmdldHNcbiAgICAgICAgICogZm9yIHdoaWNoIGEgY2hhbmdlIGlzIGZvdW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGNvbXBsZXhpdHkgb2YgeW91ciBkYXRhIG1vZGVsLCBkaXJ0eSBjaGVja2luZyBjYW4gYmUgZXhwZW5zaXZlXG4gICAgICAgICAqIGFuZCBpcyB0aGVyZWZvcmUgZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogTkI6IEZvciBjaGFuZ2VzIHRvIGJlIGRldGVjdGVkLCBhIG5ldyBpbW11dGFibGUgaW5zdGFuY2Ugb2YgdGhlIGVkaXRlZCBtb2RlbCBtdXN0IGJlXG4gICAgICAgICAqIHByb3ZpZGVkIHRvIG1peGl0dXAsIHJhdGhlciB0aGFuIG1hbmlwdWxhdGluZyBwcm9wZXJ0aWVzIG9uIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICogSWYgeW91ciBjaGFuZ2VzIGFyZSBhIHJlc3VsdCBvZiBhIERCIHdyaXRlIGFuZCByZWFkLCB5b3Ugd2lsbCBtb3N0IGxpa2VseSBiZSBjYWxsaW5nXG4gICAgICAgICAqIGAuZGF0YXNldCgpYCB3aXRoIGEgY2xlYW4gc2V0IG9mIG9iamVjdHMgZWFjaCB0aW1lLCBzbyB0aGlzIHdpbGwgbm90IGJlIGFuIGlzc3VlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBFbmFibGluZyBkaXJ0eSBjaGVja2luZzwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG15RGF0YXNldCA9IFtcbiAgICAgICAgICogICAgIHtcbiAgICAgICAgICogICAgICAgICBpZDogMCxcbiAgICAgICAgICogICAgICAgICB0aXRsZTogXCJCbG9nIFBvc3QgVGl0bGUgMFwiXG4gICAgICAgICAqICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAge1xuICAgICAgICAgKiAgICAgICAgIGlkOiAxLFxuICAgICAgICAgKiAgICAgICAgIHRpdGxlOiBcIkJsb2cgUG9zdCBUaXRsZSAxXCJcbiAgICAgICAgICogICAgICAgICAuLi5cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogXTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gSW5zdGFudGlhdGUgYSBtaXhlciB3aXRoIGEgcHJlLWxvYWRlZCBkYXRhc2V0LCBhbmQgYSB0YXJnZXQgcmVuZGVyZXJcbiAgICAgICAgICogLy8gZnVuY3Rpb24gZGVmaW5lZFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBkYXRhOiB7XG4gICAgICAgICAqICAgICAgICAgdWlkS2V5OiAnaWQnLFxuICAgICAgICAgKiAgICAgICAgIGRpcnR5Q2hlY2s6IHRydWVcbiAgICAgICAgICogICAgIH0sXG4gICAgICAgICAqICAgICBsb2FkOiB7XG4gICAgICAgICAqICAgICAgICAgZGF0YXNldDogbXlEYXRhc2V0XG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAgcmVuZGVyOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEZvciBpbGx1c3RyYXRpb24sIHdlIHdpbGwgY2xvbmUgYW5kIGVkaXQgdGhlIHNlY29uZCBvYmplY3QgaW4gdGhlIGRhdGFzZXQuXG4gICAgICAgICAqIC8vIE5COiB0aGlzIHdvdWxkIHR5cGljYWxseSBiZSBkb25lIHNlcnZlci1zaWRlIGluIHJlc3BvbnNlIHRvIGEgREIgdXBkYXRlLFxuICAgICAgICAgKiBhbmQgdGhlbiByZS1xdWVyaWVkIHZpYSBhbiBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIG15RGF0YXNldFsxXSA9IE9iamVjdC5hc3NpZ24oe30sIG15RGF0YXNldFsxXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG15RGF0YXNldFsxXS50aXRsZSA9ICdCbG9nIFBvc3QgVGl0bGUgMTEnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5kYXRhc2V0KG15RGF0YXNldClcbiAgICAgICAgICogICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICAgICAvLyB0aGUgdGFyZ2V0IHdpdGggSUQgXCIxXCIsIHdpbGwgYmUgcmUtcmVuZGVyZWQgcmVmbGVjdGluZyBpdHMgbmV3IHRpdGxlXG4gICAgICAgICAqICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZGlydHlDaGVja1xuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuZGF0YVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgZmFsc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5kaXJ0eUNoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29uZmlnRGF0YSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0RhdGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbmZpZ0RhdGE7XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgYWxsb3dpbmcgdGhlIHRvZ2dsaW5nIG9mIHZhcmlvdXMgZGVidWcgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgZGVidWdcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgbWl4ZXIgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlXG4gICAgICAgICAqIGBtaXhpdHVwKClgIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGV4cG9zZSBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIG1peGVyIGluc3RhbmNlcyBvbmx5IGV4cG9zZSB0aGVpciBwdWJsaWMgQVBJLCBidXQgZW5hYmxpbmdcbiAgICAgICAgICogZGVidWcgbW9kZSB3aWxsIGdpdmUgeW91IGFjY2VzcyB0byB2YXJpb3VzIG1peGVyIGludGVybmFscyB3aGljaCBtYXkgYWlkXG4gICAgICAgICAqIGluIGRlYnVnZ2luZywgb3IgdGhlIGF1dGhvcmluZyBvZiBleHRlbnNpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBFbmFibGluZyBkZWJ1ZyBtb2RlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBkZWJ1Zzoge1xuICAgICAgICAgKiAgICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHdpbGwgbm93IGJlIHZpc2libGUgb24gdGhlIG1peGVyIGluc3RhbmNlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlcik7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBlbmFibGVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmRlYnVnXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBmYWxzZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHdhcm5pbmdzIHNob3VsZCBiZSBzaG93biB3aGVuIHZhcmlvdXNcbiAgICAgICAgICogY29tbW9uIGdvdGNoYXMgb2NjdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhcm5pbmdzIGFyZSBpbnRlbmRlZCB0byBwcm92aWRlIGluc2lnaHRzIGR1cmluZyBkZXZlbG9wbWVudCB3aGVuIHNvbWV0aGluZ1xuICAgICAgICAgKiBvY2N1cnMgdGhhdCBpcyBub3QgYSBmYXRhbCwgYnV0IG1heSBpbmRpY2F0ZSBhbiBpc3N1ZSB3aXRoIHlvdXIgaW50ZWdyYXRpb24sXG4gICAgICAgICAqIGFuZCBhcmUgdGhlcmVmb3JlIHR1cm5lZCBvbiBieSBkZWZhdWx0LiBIb3dldmVyLCB5b3UgbWF5IHdpc2ggdG8gZGlzYWJsZVxuICAgICAgICAgKiB0aGVtIGluIHByb2R1Y3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogRGlzYWJsaW5nIHdhcm5pbmdzPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBkZWJ1Zzoge1xuICAgICAgICAgKiAgICAgICAgIHNob3dXYXJuaW5nczogZmFsc2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogRGlzYWJsaW5nIHdhcm5pbmdzIGJhc2VkIG9uIGVudmlyb25tZW50PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgc2hvd1dhcm5pbmdzID0gbXlBcHBDb25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGRlYnVnOiB7XG4gICAgICAgICAqICAgICAgICAgc2hvd1dhcm5pbmdzOiBzaG93V2FybmluZ3NcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzaG93V2FybmluZ3NcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmRlYnVnXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICB0cnVlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuc2hvd1dhcm5pbmdzID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBmb3Igc2VydmVyLXNpZGUgdGVzdGluZyBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZmF1eEFzeW5jXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5kZWJ1Z1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgZmFsc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5mYXV4QXN5bmMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdEZWJ1Zyk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0RlYnVnLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0RlYnVnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnRGVidWc7XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gdGhlIGxheW91dCBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnXG4gICAgICogQG5hbWUgICAgICAgIGxheW91dFxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbmZpZ0xheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCBtaXhpdHVwIHNob3VsZCBxdWVyeSBhbGwgZGVzY2VuZGFudHNcbiAgICAgICAgICogb2YgdGhlIGNvbnRhaW5lciBmb3IgdGFyZ2V0cywgb3Igb25seSBpbW1lZGlhdGUgY2hpbGRyZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIG1peGl0dXAgd2lsbCBxdWVyeSBhbGwgZGVzY2VuZGFudHMgbWF0Y2hpbmcgdGhlXG4gICAgICAgICAqIGBzZWxlY3RvcnMudGFyZ2V0YCBzZWxlY3RvciB3aGVuIGluZGV4aW5nIHRhcmdldHMgdXBvbiBpbnN0YW50aWF0aW9uLlxuICAgICAgICAgKiBUaGlzIGFsbG93cyBmb3IgdGFyZ2V0cyB0byBiZSBuZXN0ZWQgaW5zaWRlIGEgc3ViLWNvbnRhaW5lciB3aGljaCBpc1xuICAgICAgICAgKiB1c2VmdWwgd2hlbiByaW5nLWZlbmNpbmcgdGFyZ2V0cyBmcm9tIGxvY2FsbHkgc2NvcGVkIGNvbnRyb2xzIGluIHlvdXJcbiAgICAgICAgICogbWFya3VwIChzZWUgYGNvbnRyb2xzLnNjb3BlYCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEhvd2V2ZXIsIGlmIHlvdSBhcmUgYnVpbGRpbmcgYSBtb3JlIGNvbXBsZXggVUkgcmVxdWlyaW5nIHRoZSBuZXN0aW5nXG4gICAgICAgICAqIG9mIG1peGVycyB3aXRoaW4gbWl4ZXJzLCB5b3Ugd2lsbCBtb3N0IGxpa2VseSB3YW50IHRvIGxpbWl0IHRhcmdldHMgdG9cbiAgICAgICAgICogaW1tZWRpYXRlIGNoaWxkcmVuIG9mIHRoZSBjb250YWluZXIgYnkgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFJlc3RyaWN0aW5nIHRhcmdldHMgdG8gaW1tZWRpYXRlIGNoaWxkcmVuPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICogICAgICAgICBhbGxvd05lc3RlZFRhcmdldHM6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgYWxsb3dOZXN0ZWRUYXJnZXRzXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sYXlvdXRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIHRydWVcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5hbGxvd05lc3RlZFRhcmdldHMgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBzcGVjaWZ5aW5nIGFuIG9wdGlvbmFsIGNsYXNzIG5hbWUgdG8gYXBwbHkgdG8gdGhlIGNvbnRhaW5lciB3aGVuIGluXG4gICAgICAgICAqIGl0cyBkZWZhdWx0IHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBjaGFuZ2luZyB0aGlzIGNsYXNzIG5hbWUgb3IgYWRkaW5nIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyIHZpYSB0aGVcbiAgICAgICAgICogYC5jaGFuZ2VMYXlvdXQoKWAgQVBJIG1ldGhvZCwgdGhlIENTUyBsYXlvdXQgb2YgdGhlIGNvbnRhaW5lciBjYW4gYmUgY2hhbmdlZCxcbiAgICAgICAgICogYW5kIE1peEl0VXAgd2lsbCBhdHRlbXAgdG8gZ3JhY2VmdWxseSBhbmltYXRlIHRoZSBjb250YWluZXIgYW5kIGl0cyB0YXJnZXRzXG4gICAgICAgICAqIGJldHdlZW4gc3RhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFNwZWNpZnlpbmcgYSBjb250YWluZXIgY2xhc3MgbmFtZTwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgbGF5b3V0OiB7XG4gICAgICAgICAqICAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lOiAnZ3JpZCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogQ2hhbmdpbmcgdGhlIGRlZmF1bHQgY2xhc3MgbmFtZSB3aXRoIGAuY2hhbmdlTGF5b3V0KClgPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICogICAgICAgICBjb250YWluZXJDbGFzc05hbWU6ICdncmlkJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuY2hhbmdlTGF5b3V0KCdsaXN0JylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZUNvbnRhaW5lckNsYXNzKTsgLy8gXCJsaXN0XCJcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sYXlvdXRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gYSBub24tdGFyZ2V0IHNpYmxpbmcgZWxlbWVudCBhZnRlciB3aGljaCB0byBpbnNlcnQgdGFyZ2V0c1xuICAgICAgICAgKiB3aGVuIHRoZXJlIGFyZSBubyB0YXJnZXRzIGluIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFNldHRpbmcgYSBgc2libGluZ0JlZm9yZWAgcmVmZXJlbmNlIGVsZW1lbnQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBhZGRCdXR0b24gPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgbGF5b3V0OiB7XG4gICAgICAgICAqICAgICAgICAgc2libGluZ0JlZm9yZTogYWRkQnV0dG9uXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgc2libGluZ0JlZm9yZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcubGF5b3V0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0hUTUxFbGVtZW50fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnNpYmxpbmdCZWZvcmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byBhIG5vbi10YXJnZXQgc2libGluZyBlbGVtZW50IGJlZm9yZSB3aGljaCB0byBpbnNlcnQgdGFyZ2V0c1xuICAgICAgICAgKiB3aGVuIHRoZXJlIGFyZSBubyB0YXJnZXRzIGluIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFNldHRpbmcgYW4gYHNpYmxpbmdBZnRlcmAgcmVmZXJlbmNlIGVsZW1lbnQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBnYXAgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcuZ2FwJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGxheW91dDoge1xuICAgICAgICAgKiAgICAgICAgIHNpYmxpbmdBZnRlcjogZ2FwXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgc2libGluZ0FmdGVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sYXlvdXRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuc2libGluZ0FmdGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdMYXlvdXQpO1xuXG4gICAgbWl4aXR1cC5Db25maWdMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnTGF5b3V0O1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBwcm9wZXJ0aWVzIGRlZmluaW5nIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBtaXhlciBvbiBsb2FkIChpbnN0YW50aWF0aW9uKS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBsb2FkXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnTG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgZGVmaW5pbmcgYW55IGZpbHRlcmluZyB0byBiZSBzdGF0aWNhbGx5IGFwcGxpZWQgdG8gdGhlIG1peGVyIG9uIGxvYWQuXG4gICAgICAgICAqIEFzIHBlciB0aGUgYC5maWx0ZXIoKWAgQVBJLCB0aGlzIGNhbiBiZSBhbnkgdmFsaWQgc2VsZWN0b3Igc3RyaW5nLCBvciB0aGVcbiAgICAgICAgICogdmFsdWVzIGAnYWxsJ2Agb3IgYCdub25lJ2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogRGVmaW5pbmcgYW4gaW5pdGlhbCBmaWx0ZXIgc2VsZWN0b3IgdG8gYmUgYXBwbGllZCBvbiBsb2FkPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBUaGUgbWl4ZXIgd2lsbCBzaG93IG9ubHkgdGhvc2UgdGFyZ2V0cyBtYXRjaGluZyAnLmNhdGVnb3J5LWEnIG9uIGxvYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBmaWx0ZXI6ICcuY2F0ZWdvcnktYSdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogSGlkaW5nIGFsbCB0YXJnZXRzIG9uIGxvYWQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoZSBtaXhlciB3aWxsIHNob3cgaGlkZSBhbGwgdGFyZ2V0cyBvbiBsb2FkLlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBsb2FkOiB7XG4gICAgICAgICAqICAgICAgICAgZmlsdGVyOiAnbm9uZSdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBmaWx0ZXJcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmxvYWRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2FsbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5maWx0ZXIgPSAnYWxsJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgZGVmaW5pbmcgYW55IHNvcnRpbmcgdG8gYmUgc3RhdGljYWxseSBhcHBsaWVkIHRvIHRoZSBtaXhlciBvbiBsb2FkLlxuICAgICAgICAgKiBBcyBwZXIgdGhlIGAuc29ydCgpYCBBUEksIHRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgXCJzb3J0IHN0cmluZ1wiIG1hZGUgdXAgb2ZcbiAgICAgICAgICogYW4gYXR0cmlidXRlIHRvIHNvcnQgYnkgKG9yIGAnZGVmYXVsdCdgKSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBzb3J0aW5nXG4gICAgICAgICAqIG9yZGVyLCBvciB0aGUgdmFsdWUgYCdyYW5kb20nYDtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRGVmaW5pbmcgc29ydGluZyB0byBiZSBhcHBsaWVkIG9uIGxvYWQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoZSBtaXhlciB3aWxsIHNvcnQgdGhlIGNvbnRhaW5lciBieSB0aGUgdmFsdWUgb2YgdGhlIGBkYXRhLXB1Ymxpc2hlZC1kYXRlYFxuICAgICAgICAgKiAvLyBhdHRyaWJ1dGUsIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBzb3J0OiAncHVibGlzaGVkLWRhdGU6ZGVzYydcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sb2FkXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdkZWZhdWx0OmFzYydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5zb3J0ID0gJ2RlZmF1bHQ6YXNjJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBvZiBhbnkgcHJlLXJlbmRlcmVkIHRhcmdldHMsXG4gICAgICAgICAqIHdoZW4gdXNpbmcgdGhlIGAuZGF0YXNldCgpYCBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5COiBJZiB0YXJnZXRzIGFyZSBwcmUtcmVuZGVyZWQgd2hlbiB0aGUgbWl4ZXIgaXMgaW5zdGFudGlhdGVkLCB0aGlzIG11c3QgYmUgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBEZWZpbmluZyB0aGUgaW5pdGlhbCB1bmRlcnlsaW5nIGRhdGFzZXQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBteURhdGFzZXQgPSBbXG4gICAgICAgICAqICAgICB7XG4gICAgICAgICAqICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAqICAgICAgICAgdGl0bGU6IFwiQmxvZyBQb3N0IFRpdGxlIDBcIixcbiAgICAgICAgICogICAgICAgICAuLi5cbiAgICAgICAgICogICAgIH0sXG4gICAgICAgICAqICAgICB7XG4gICAgICAgICAqICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAqICAgICAgICAgdGl0bGU6IFwiQmxvZyBQb3N0IFRpdGxlIDFcIixcbiAgICAgICAgICogICAgICAgICAuLi5cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogXTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgZGF0YToge1xuICAgICAgICAgKiAgICAgICAgIHVpZEtleTogJ2lkJ1xuICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBkYXRhc2V0OiBteURhdGFzZXRcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBkYXRhc2V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sb2FkXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0FycmF5LjxvYmplY3Q+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0xvYWQpO1xuXG4gICAgbWl4aXR1cC5Db25maWdMb2FkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0xvYWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdMb2FkO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBwcm9wZXJ0aWVzIGRlZmluaW5nIHRoZSBzZWxlY3RvcnMgdXNlZCB0byBxdWVyeSBlbGVtZW50cyB3aXRoaW4gYSBtaXhpdHVwIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBzZWxlY3RvcnNcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdTZWxlY3RvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2VsZWN0b3Igc3RyaW5nIHVzZWQgdG8gcXVlcnkgYW5kIGluZGV4IHRhcmdldCBlbGVtZW50cyB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGNsYXNzIHNlbGVjdG9yIGAnLm1peCdgIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSBjaGFuZ2VkIHRvIGFuXG4gICAgICAgICAqIGF0dHJpYnV0ZSBvciBlbGVtZW50IHNlbGVjdG9yIHRvIG1hdGNoIHRoZSBzdHlsZSBvZiB5b3VyIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQ2hhbmdpbmcgdGhlIHRhcmdldCBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiAnLnBvcnRmb2xpby1pdGVtJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBVc2luZyBhbiBhdHRyaWJ1dGUgc2VsZWN0b3IgYXMgYSB0YXJnZXQgc2VsZWN0b3I8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoZSBtaXhlciB3aWxsIHNlYXJjaCBmb3IgYW55IGNoaWxkcmVuIHdpdGggdGhlIGF0dHJpYnV0ZSBgZGF0YS1yZWY9XCJtaXhcImBcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiAnW2RhdGEtcmVmPVwibWl4XCJdJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRhcmdldFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuc2VsZWN0b3JzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICcubWl4J1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnRhcmdldCA9ICcubWl4JztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBvcHRpb25hbCBzZWxlY3RvciBzdHJpbmcgdXNlZCB0byBhZGQgZnVydGhlciBzcGVjaWZpY2l0eSB0byB0aGUgcXVlcnlpbmcgb2YgY29udHJvbCBlbGVtZW50cyxcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gdGhlaXIgbWFuZGF0b3J5IGRhdGEgYXR0cmlidXRlIChlLmcuIGBkYXRhLWZpbHRlcmAsIGBkYXRhLXRvZ2dsZWAsIGBkYXRhLXNvcnRgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCBpZiBvdGhlciBlbGVtZW50cyBpbiB5b3VyIGRvY3VtZW50IG11c3QgY29udGFpbiB0aGUgYWJvdmUgYXR0cmlidXRlc1xuICAgICAgICAgKiAoZS5nLiBmb3IgdXNlIGluIHRoaXJkLXBhcnR5IHNjcmlwdHMpLCBhbmQgd291bGQgb3RoZXJ3aXNlIGludGVyZmVyZSB3aXRoIE1peEl0VXAuIEFkZGluZ1xuICAgICAgICAgKiBhbiBhZGRpdGlvbmFsIGBjb250cm9sYCBzZWxlY3RvciBvZiB5b3VyIGNob2ljZSBhbGxvd3MgTWl4SXRVcCB0byByZXN0cmljdCBldmVudCBoYW5kbGluZ1xuICAgICAgICAgKiB0byBvbmx5IHRob3NlIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBkZWZpbmVkIHNlbGVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY29udHJvbFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuc2VsZWN0b3JzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICcnXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQWRkaW5nIGEgYHNlbGVjdG9ycy5jb250cm9sYCBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAqICAgICAgICAgY29udHJvbDogJy5taXhpdHVwLWNvbnRyb2wnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBXaWxsIG5vdCBiZSBoYW5kbGVkOlxuICAgICAgICAgKiAvLyA8YnV0dG9uIGRhdGEtZmlsdGVyPVwiLmNhdGVnb3J5LWFcIj48L2J1dHRvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gV2lsbCBiZSBoYW5kbGVkOlxuICAgICAgICAgKiAvLyA8YnV0dG9uIGNsYXNzPVwibWl4aXR1cC1jb250cm9sXCIgZGF0YS1maWx0ZXI9XCIuY2F0ZWdvcnktYVwiPjwvYnV0dG9uPlxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNvbnRyb2wgPSAnJztcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdTZWxlY3RvcnMpO1xuXG4gICAgbWl4aXR1cC5Db25maWdTZWxlY3RvcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnU2VsZWN0b3JzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnU2VsZWN0b3JzO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBvcHRpb25hbCByZW5kZXIgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBhbmQgdXBkYXRpbmcgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBBbGwgcmVuZGVyIGZ1bmN0aW9ucyByZWNlaXZlIGEgZGF0YSBvYmplY3QsIGFuZCBzaG91bGQgcmV0dXJuIGEgdmFsaWQgSFRNTCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgcmVuZGVyXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnUmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyBhbiBIVE1MIHN0cmluZyByZXByZXNlbnRpbmcgYSB0YXJnZXQgZWxlbWVudCwgb3IgYSByZWZlcmVuY2UgdG8gYVxuICAgICAgICAgKiBzaW5nbGUgRE9NIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIGFzIHBhcnQgb2YgdGhlIGAuZGF0YXNldCgpYCBBUEksIHdoZW5ldmVyIGEgbmV3IGl0ZW0gaXMgYWRkZWRcbiAgICAgICAgICogdG8gdGhlIGRhdGFzZXQsIG9yIGFuIGl0ZW0gaW4gdGhlIGRhdGFzZXQgY2hhbmdlcyAoaWYgYGRhdGFzZXQuZGlydHlDaGVja2AgaXMgZW5hYmxlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgcmVsZXZhbnQgZGF0YXNldCBpdGVtIGFzIGl0cyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogVXNpbmcgc3RyaW5nIGNvbmNhdGVuYXRpb248L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIHJlbmRlcjoge1xuICAgICAgICAgKiAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgKiAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgJyZsdDtkaXYgY2xhc3M9XCJtaXhcIiZndDsnICtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAnJmx0O2gyJmd0OycgKyBpdGVtLnRpdGxlICsgJyZsdDsvaDImZ3Q7JyArXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAnJmx0Oy9kaXYmZ3Q7J1xuICAgICAgICAgKiAgICAgICAgICAgICApO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogVXNpbmcgYW4gRVMyMDE1IHRlbXBsYXRlIGxpdGVyYWw8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIHJlbmRlcjoge1xuICAgICAgICAgKiAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgKiAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgYCZsdDtkaXYgY2xhc3M9XCJtaXhcIiZndDtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAmbHQ7aDImZ3Q7JHtpdGVtLnRpdGxlfSZsdDsvaDImZ3Q7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgJmx0Oy9kaXYmZ3Q7YFxuICAgICAgICAgKiAgICAgICAgICAgICApO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogVXNpbmcgYSBIYW5kbGViYXJzIHRlbXBsYXRlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdGFyZ2V0VGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoJyZsdDtkaXYgY2xhc3M9XCJtaXhcIiZndDsmbHQ7aDImZ3Q7e3t0aXRsZX19Jmx0Oy9oMiZndDsmbHQ7L2RpdiZndDsnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgcmVuZGVyOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiB0YXJnZXRUZW1wbGF0ZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSA0OiBSZXR1cm5pbmcgYSBET00gZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgcmVuZGVyOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBzaW5nbGUgZWxlbWVudCB1c2luZyB5b3VyIGZyYW1ld29yaydzIGJ1aWx0LWluIHJlbmRlcmVyXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICAgICB2YXIgZWwgPSAuLi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdGFyZ2V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5yZW5kZXJcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnbnVsbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ1JlbmRlcik7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ1JlbmRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdSZW5kZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdSZW5kZXI7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbmZpZ1RlbXBsYXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdUZW1wbGF0ZXMpO1xuXG4gICAgbWl4aXR1cC5Db25maWdUZW1wbGF0ZXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnVGVtcGxhdGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnVGVtcGxhdGVzO1xuXG4gICAgLyoqXG4gICAgICogYG1peGl0dXAuQ29uZmlnYCBpcyBhbiBpbnRlcmZhY2UgdXNlZCBmb3IgY3VzdG9taXNpbmcgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYVxuICAgICAqIG1peGVyIGluc3RhbmNlLiBJdCBpcyBvcmdhbmlzZWQgaW50byBzZXZlcmFsIHNlbWFudGljYWxseSBkaXN0aW5jdCBzdWItb2JqZWN0cyxcbiAgICAgKiBlYWNoIG9uZSBwZXJ0YWluaW5nIHRvIGEgcGFydGljdWxhciBhc3BlY3Qgb2YgTWl4SXRVcCBmdW5jdGlvbmFsaXR5LlxuICAgICAqXG4gICAgICogQW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBhbnkgb3IgYWxsIG9mIHRoZSBhdmFpbGFibGUgcHJvcGVyaWVzLFxuICAgICAqIGtub3duIGFzIHRoZSBcImNvbmZpZ3VyYXRpb24gb2JqZWN0XCIsIGNhbiBiZSBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG9cbiAgICAgKiB0aGUgYG1peGl0dXBgIGZhY3RvcnkgZnVuY3Rpb24gd2hlbiBjcmVhdGluZyBhIG1peGVyIGluc3RhbmNlIHRvIGN1c3RvbWlzZSBpdHNcbiAgICAgKiBmdW5jdGlvbmFsaXR5IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIElmIG5vIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIHBhc3NlZCwgdGhlIG1peGVyIGluc3RhbmNlIHdpbGwgdGFrZSBvbiB0aGUgZGVmYXVsdFxuICAgICAqIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGRldGFpbGVkIGJlbG93LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBDcmVhdGluZyBhbmQgcGFzc2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3Q8L2NhcHRpb24+XG4gICAgICogLy8gQ3JlYXRlIGEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBkZXNpcmVkIHZhbHVlc1xuICAgICAqXG4gICAgICogdmFyIGNvbmZpZyA9IHtcbiAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICogICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHNlbGVjdG9yczoge1xuICAgICAqICAgICAgICAgdGFyZ2V0OiAnLml0ZW0nXG4gICAgICogICAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gUGFzcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gdGhlIG1peGl0dXAgZmFjdG9yeSBmdW5jdGlvblxuICAgICAqXG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwgY29uZmlnKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogUGFzc2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaW5saW5lPC9jYXB0aW9uPlxuICAgICAqIC8vIFR5cGljYWxseSwgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIHBhc3NlZCBpbmxpbmUgZm9yIGJyZXZpdHkuXG4gICAgICpcbiAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICogICAgIGNvbnRyb2xzOiB7XG4gICAgICogICAgICAgICBsaXZlOiB0cnVlLFxuICAgICAqICAgICAgICAgdG9nZ2xlTG9naWM6ICdhbmQnXG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb24gICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvciAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdCZWhhdmlvcigpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0NhbGxiYWNrcygpO1xuICAgICAgICB0aGlzLmNvbnRyb2xzICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0NvbnRyb2xzKCk7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyAgICAgICAgID0gbmV3IG1peGl0dXAuQ29uZmlnQ2xhc3NOYW1lcygpO1xuICAgICAgICB0aGlzLmRhdGEgICAgICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0RhdGEoKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyAgICAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdEZWJ1ZygpO1xuICAgICAgICB0aGlzLmxheW91dCAgICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0xheW91dCgpO1xuICAgICAgICB0aGlzLmxvYWQgICAgICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0xvYWQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdTZWxlY3RvcnMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXIgICAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdSZW5kZXIoKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdUZW1wbGF0ZXMoKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWcpO1xuXG4gICAgbWl4aXR1cC5Db25maWcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5NaXhlckRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmRvY3VtZW50ICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmJvZHkgICAgICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudCAgICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldHMgICAgICAgICAgICAgICAgPSBbXTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5NaXhlckRvbSk7XG5cbiAgICBtaXhpdHVwLk1peGVyRG9tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLk1peGVyRG9tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuTWl4ZXJEb207XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLlVpQ2xhc3NOYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmJhc2UgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy5hY3RpdmUgICAgID0gJyc7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlVpQ2xhc3NOYW1lcyk7XG5cbiAgICBtaXhpdHVwLlVpQ2xhc3NOYW1lcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5VaUNsYXNzTmFtZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5VaUNsYXNzTmFtZXM7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgaW50byB3aGljaCBhbGwgYXJiaXRyYXJ5IGFyZ3VtZW50cyBzZW50IHRvICcuZGF0YXNldCgpJyBhcmUgbWFwcGVkLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db21tYW5kRGF0YXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbW1hbmREYXRhc2V0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZERhdGFzZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZERhdGFzZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db21tYW5kRGF0YXNldDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5tdWx0aW1peCgpJyBhcmUgbWFwcGVkLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db21tYW5kTXVsdGltaXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5maWx0ZXIgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnNvcnQgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5zZXJ0ICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmUgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5nZUxheW91dCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29tbWFuZE11bHRpbWl4KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZE11bHRpbWl4LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbW1hbmRNdWx0aW1peC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbW1hbmRNdWx0aW1peDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5maWx0ZXIoKScgYXJlIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29tbWFuZEZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnNlbGVjdG9yICAgPSAnJztcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb24gICAgID0gJ3Nob3cnOyAvLyBlbnVtOiBbJ3Nob3cnLCAnaGlkZSddXG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29tbWFuZEZpbHRlcik7XG5cbiAgICBtaXhpdHVwLkNvbW1hbmRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbW1hbmRGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgaW50byB3aGljaCBhbGwgYXJiaXRyYXJ5IGFyZ3VtZW50cyBzZW50IHRvICcuc29ydCgpJyBhcmUgbWFwcGVkLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db21tYW5kU29ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnNvcnRTdHJpbmcgPSAnJztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgID0gJyc7XG4gICAgICAgIHRoaXMub3JkZXIgICAgICA9ICdhc2MnO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgICAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbW1hbmRTb3J0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZFNvcnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZFNvcnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db21tYW5kU29ydDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5pbnNlcnQoKScgYXJlIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29tbWFuZEluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmluZGV4ICAgICAgPSAwO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiAgID0gJ2JlZm9yZSc7IC8vIGVudW06IFsnYmVmb3JlJywgJ2FmdGVyJ11cbiAgICAgICAgdGhpcy5zaWJsaW5nICAgID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db21tYW5kSW5zZXJ0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZEluc2VydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db21tYW5kSW5zZXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29tbWFuZEluc2VydDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5yZW1vdmUoKScgYXJlIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29tbWFuZFJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnRhcmdldHMgICAgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gW107XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29tbWFuZFJlbW92ZSk7XG5cbiAgICBtaXhpdHVwLkNvbW1hbmRSZW1vdmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZFJlbW92ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbW1hbmRSZW1vdmU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgaW50byB3aGljaCBhbGwgYXJiaXRyYXJ5IGFyZ3VtZW50cyBzZW50IHRvICcuY2hhbmdlTGF5b3V0KCknIGFyZSBtYXBwZWQuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbW1hbmRDaGFuZ2VMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSAnJztcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db21tYW5kQ2hhbmdlTGF5b3V0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZENoYW5nZUxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db21tYW5kQ2hhbmdlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29tbWFuZENoYW5nZUxheW91dDtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICAgIHR5cGVcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICAgIHNlbGVjdG9yXG4gICAgICogQHBhcmFtICAgICAgIHtib29sZWFufSAgICAgICBbbGl2ZV1cbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICAgIFtwYXJlbnRdXG4gICAgICogICAgIEFuIG9wdGlvbmFsIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIG1peGVyLmRvbSBwcm9wZXJ0eSBjb250YWluaW5nIGEgcmVmZXJlbmNlIHRvIGEgcGFyZW50IGVsZW1lbnQuXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbnRyb2xEZWZpbml0aW9uID0gZnVuY3Rpb24odHlwZSwgc2VsZWN0b3IsIGxpdmUsIHBhcmVudCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnR5cGUgICAgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdG9yICA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmxpdmUgICAgICA9IGxpdmUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50ICAgID0gcGFyZW50IHx8ICcnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5mcmVlemUodGhpcyk7XG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db250cm9sRGVmaW5pdGlvbik7XG5cbiAgICBtaXhpdHVwLkNvbnRyb2xEZWZpbml0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbnRyb2xEZWZpbml0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29udHJvbERlZmluaXRpb247XG5cbiAgICBtaXhpdHVwLmNvbnRyb2xEZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgbWl4aXR1cC5jb250cm9sRGVmaW5pdGlvbnMucHVzaChuZXcgbWl4aXR1cC5Db250cm9sRGVmaW5pdGlvbignbXVsdGltaXgnLCAnW2RhdGEtZmlsdGVyXVtkYXRhLXNvcnRdJykpO1xuICAgIG1peGl0dXAuY29udHJvbERlZmluaXRpb25zLnB1c2gobmV3IG1peGl0dXAuQ29udHJvbERlZmluaXRpb24oJ2ZpbHRlcicsICdbZGF0YS1maWx0ZXJdJykpO1xuICAgIG1peGl0dXAuY29udHJvbERlZmluaXRpb25zLnB1c2gobmV3IG1peGl0dXAuQ29udHJvbERlZmluaXRpb24oJ3NvcnQnLCAnW2RhdGEtc29ydF0nKSk7XG4gICAgbWl4aXR1cC5jb250cm9sRGVmaW5pdGlvbnMucHVzaChuZXcgbWl4aXR1cC5Db250cm9sRGVmaW5pdGlvbigndG9nZ2xlJywgJ1tkYXRhLXRvZ2dsZV0nKSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbnRyb2wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5lbCAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RvciAgID0gJyc7XG4gICAgICAgIHRoaXMuYm91bmQgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnBlbmRpbmcgICAgPSAtMTtcbiAgICAgICAgdGhpcy50eXBlICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMuc3RhdHVzICAgICA9ICdpbmFjdGl2ZSc7IC8vIGVudW06IFsnaW5hY3RpdmUnLCAnYWN0aXZlJywgJ2Rpc2FibGVkJywgJ2xpdmUnXVxuICAgICAgICB0aGlzLmZpbHRlciAgICAgPSAnJztcbiAgICAgICAgdGhpcy5zb3J0ICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMuY2FuRGlzYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBuZXcgbWl4aXR1cC5VaUNsYXNzTmFtZXMoKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db250cm9sKTtcblxuICAgIG1peGl0dXAuQ29udHJvbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgaC5leHRlbmQobWl4aXR1cC5Db250cm9sLnByb3RvdHlwZSxcbiAgICAvKiogQGxlbmRzIG1peGl0dXAuQ29udHJvbCAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuQ29udHJvbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBzZWxlY3RvclxuICAgICAgICAgKi9cblxuICAgICAgICBpbml0OiBmdW5jdGlvbihlbCwgdHlwZSwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuZWwgICAgICAgICA9IGVsO1xuICAgICAgICAgICAgc2VsZi50eXBlICAgICAgID0gdHlwZTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0b3IgICA9IHNlbGVjdG9yO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gJ2xpdmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbkRpc2FibGUgPSB0eXBlb2Ygc2VsZi5lbC5kaXNhYmxlID09PSAnYm9vbGVhbic7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5maWx0ZXIgPSBzZWxmLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS1maWx0ZXInKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbHRlciA9IHNlbGYuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29ydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnQgICA9IHNlbGYuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpbWl4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlsdGVyID0gc2VsZi5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmlsdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnQgICA9IHNlbGYuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmJpbmRDbGljaygpO1xuXG4gICAgICAgICAgICBtaXhpdHVwLmNvbnRyb2xzLnB1c2goc2VsZik7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVySW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAge21peGl0dXAuTWl4ZXJ9IG1peGVyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlzQm91bmQ6IGZ1bmN0aW9uKG1peGVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaXNCb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVJc0JvdW5kJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaXNCb3VuZCA9IHNlbGYuYm91bmQuaW5kZXhPZihtaXhlcikgPiAtMTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2FmdGVySXNCb3VuZCcsIGlzQm91bmQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAge21peGl0dXAuTWl4ZXJ9IG1peGVyXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFkZEJpbmRpbmc6IGZ1bmN0aW9uKG1peGVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUFkZEJpbmRpbmcnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNCb3VuZCgpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib3VuZC5wdXNoKG1peGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJBZGRCaW5kaW5nJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICB7bWl4aXR1cC5NaXhlcn0gbWl4ZXJcbiAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgcmVtb3ZlQmluZGluZzogZnVuY3Rpb24obWl4ZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVtb3ZlSW5kZXggPSAtMTtcblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlUmVtb3ZlQmluZGluZycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICgocmVtb3ZlSW5kZXggPSBzZWxmLmJvdW5kLmluZGV4T2YobWl4ZXIpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib3VuZC5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5ib3VuZC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gYmluZGluZ3MgZXhpc3QsIHVuYmluZCBldmVudCBjbGljayBoYW5kbGVyc1xuXG4gICAgICAgICAgICAgICAgc2VsZi51bmJpbmRDbGljaygpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYG1peGl0dXAuY29udHJvbHNgIGxpc3RcblxuICAgICAgICAgICAgICAgIHJlbW92ZUluZGV4ID0gbWl4aXR1cC5jb250cm9scy5pbmRleE9mKHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgbWl4aXR1cC5jb250cm9scy5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhzZWxmLmVsLCAnaW5hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyUmVtb3ZlQmluZGluZycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGJpbmRDbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUJpbmRDbGljaycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZUNsaWNrKGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaC5vbihzZWxmLmVsLCAnY2xpY2snLCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckJpbmRDbGljaycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHVuYmluZENsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlVW5iaW5kQ2xpY2snLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBoLm9mZihzZWxmLmVsLCAnY2xpY2snLCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlclVuYmluZENsaWNrJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge01vdXNlRXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGJ1dHRvbiAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBtaXhlciAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmUgICAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHZvaWQoMCksXG4gICAgICAgICAgICAgICAgY29tbWFuZCAgICAgPSB7fSxcbiAgICAgICAgICAgICAgICBjbG9uZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgY29tbWFuZHMgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVIYW5kbGVDbGljaycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IDA7XG5cbiAgICAgICAgICAgIG1peGVyID0gc2VsZi5ib3VuZFswXTtcblxuICAgICAgICAgICAgaWYgKCFzZWxmLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gc2VsZi5lbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gaC5jbG9zZXN0UGFyZW50KGUudGFyZ2V0LCBtaXhlci5jb25maWcuc2VsZWN0b3JzLmNvbnRyb2wgKyBzZWxmLnNlbGVjdG9yLCB0cnVlLCBtaXhlci5kb20uZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVySGFuZGxlQ2xpY2snLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuZmlsdGVyID0gc2VsZi5maWx0ZXIgfHwgYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1maWx0ZXInKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5zb3J0ID0gc2VsZi5zb3J0IHx8IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc29ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpbWl4JzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5maWx0ZXIgID0gc2VsZi5maWx0ZXIgfHwgYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1maWx0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5zb3J0ICAgID0gc2VsZi5zb3J0IHx8IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc29ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuZmlsdGVyICA9IHNlbGYuZmlsdGVyIHx8IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlID0gaC5oYXNDbGFzcyhidXR0b24sIHNlbGYuY2xhc3NOYW1lcy5hY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUgPSBzZWxmLnN0YXR1cyA9PT0gJ2FjdGl2ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYuYm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgY29tbWFuZCBmb3IgZWFjaCBib3VuZCBtaXhlciBpbnN0YW5jZVxuXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBuZXcgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgoKTtcblxuICAgICAgICAgICAgICAgIGguZXh0ZW5kKGNsb25lLCBjb21tYW5kKTtcblxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY2xvbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21tYW5kcyA9IHNlbGYuY2FsbEZpbHRlcnMoJ2NvbW1hbmRzSGFuZGxlQ2xpY2snLCBjb21tYW5kcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5wZW5kaW5nID0gc2VsZi5ib3VuZC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IG1peGVyID0gc2VsZi5ib3VuZFtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIGV4dGVuc2lvbiBtYXkgc2V0IGEgY29tbWFuZCBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhlIGNsaWNrIHNob3VsZCBub3QgYmUgaGFuZGxlZFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbWl4ZXIubGFzdENsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWl4ZXIubGFzdENsaWNrZWQgPSBidXR0b247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWl4aXR1cC5ldmVudHMuZmlyZSgnbWl4Q2xpY2snLCBtaXhlci5kb20uY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBtaXhlci5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG1peGVyLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBtaXhlci5sYXN0Q2xpY2tlZFxuICAgICAgICAgICAgICAgIH0sIG1peGVyLmRvbS5kb2N1bWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1peGVyLmNvbmZpZy5jYWxsYmFja3Mub25NaXhDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1peGVyLmNvbmZpZy5jYWxsYmFja3Mub25NaXhDbGljay5jYWxsKG1peGVyLmxhc3RDbGlja2VkLCBtaXhlci5zdGF0ZSwgZSwgbWl4ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgaGFzIHJldHVybmVkIGBmYWxzZWAgZnJvbSB0aGUgY2FsbGJhY2ssIHNvIGRvIG5vdCBoYW5kbGUgY2xpY2tcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndG9nZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSA/IG1peGVyLnRvZ2dsZU9mZihjb21tYW5kLmZpbHRlcikgOiBtaXhlci50b2dnbGVPbihjb21tYW5kLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWl4ZXIubXVsdGltaXgoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckhhbmRsZUNsaWNrJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgICAgICAgY29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gICB0b2dnbGVBcnJheVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihjb21tYW5kLCB0b2dnbGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBuZXcgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgoKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlVXBkYXRlJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5wZW5kaW5nLS07XG5cbiAgICAgICAgICAgIHNlbGYucGVuZGluZyA9IE1hdGgubWF4KDAsIHNlbGYucGVuZGluZyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLnBlbmRpbmcgPiAwKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gJ2xpdmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gTGl2ZSBjb250cm9sIChzdGF0dXMgdW5rbm93bilcblxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlTGl2ZShjb21tYW5kLCB0b2dnbGVBcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRpYyBjb250cm9sXG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zLnNvcnQgICAgPSBzZWxmLnNvcnQ7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5maWx0ZXIgID0gc2VsZi5maWx0ZXI7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxGaWx0ZXJzKCdhY3Rpb25zVXBkYXRlJywgYWN0aW9ucywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIHNlbGYucGFyc2VTdGF0dXNDaGFuZ2Uoc2VsZi5lbCwgY29tbWFuZCwgYWN0aW9ucywgdG9nZ2xlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclVwZGF0ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRNdWx0aW1peH0gY29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgIHRvZ2dsZUFycmF5XG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICB1cGRhdGVMaXZlOiBmdW5jdGlvbihjb21tYW5kLCB0b2dnbGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgY29udHJvbEJ1dHRvbnMgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGJ1dHRvbiAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVVwZGF0ZUxpdmUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuZWwpIHJldHVybjtcblxuICAgICAgICAgICAgY29udHJvbEJ1dHRvbnMgPSBzZWxmLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZi5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGJ1dHRvbiA9IGNvbnRyb2xCdXR0b25zW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gbmV3IG1peGl0dXAuQ29tbWFuZE11bHRpbWl4KCk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5maWx0ZXIgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLWZpbHRlcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29ydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNvcnQgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpbWl4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuZmlsdGVyICA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmlsdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNvcnQgICAgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmZpbHRlciAgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gc2VsZi5jYWxsRmlsdGVycygnYWN0aW9uc1VwZGF0ZUxpdmUnLCBhY3Rpb25zLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJzZVN0YXR1c0NoYW5nZShidXR0b24sIGNvbW1hbmQsIGFjdGlvbnMsIHRvZ2dsZUFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJVcGRhdGVMaXZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgICAgICAgICAgICBidXR0b25cbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuQ29tbWFuZE11bHRpbWl4fSBjb21tYW5kXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRNdWx0aW1peH0gYWN0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgIHRvZ2dsZUFycmF5XG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZVN0YXR1c0NoYW5nZTogZnVuY3Rpb24oYnV0dG9uLCBjb21tYW5kLCBhY3Rpb25zLCB0b2dnbGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFsaWFzICAgPSAnJyxcbiAgICAgICAgICAgICAgICB0b2dnbGUgID0gJycsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVQYXJzZVN0YXR1c0NoYW5nZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsdGVyJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuZmlsdGVyID09PSBhY3Rpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJTdGF0dXMoYnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXVsdGltaXgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5zb3J0ID09PSBhY3Rpb25zLnNvcnQgJiYgY29tbWFuZC5maWx0ZXIgPT09IGFjdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyU3RhdHVzKGJ1dHRvbiwgJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuc29ydC5tYXRjaCgvOmFzYy9nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBjb21tYW5kLnNvcnQucmVwbGFjZSgvOmFzYy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5zb3J0ID09PSBhY3Rpb25zLnNvcnQgfHwgYWxpYXMgPT09IGFjdGlvbnMuc29ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJTdGF0dXMoYnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9nZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvZ2dsZUFycmF5Lmxlbmd0aCA8IDEpIHNlbGYucmVuZGVyU3RhdHVzKGJ1dHRvbiwgJ2luYWN0aXZlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuZmlsdGVyID09PSBhY3Rpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJTdGF0dXMoYnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9nZ2xlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZUFycmF5W2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9nZ2xlID09PSBhY3Rpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dHRvbiBtYXRjaGVzIG9uZSBhY3RpdmUgdG9nZ2xlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdhY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUGFyc2VTdGF0dXNDaGFuZ2UnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgYnV0dG9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICBzdGF0dXNcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHJlbmRlclN0YXR1czogZnVuY3Rpb24oYnV0dG9uLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlUmVuZGVyU3RhdHVzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICAgICAgICAgICAgICBoLmFkZENsYXNzKGJ1dHRvbiwgc2VsZi5jbGFzc05hbWVzLmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3MoYnV0dG9uLCBzZWxmLmNsYXNzTmFtZXMuZGlzYWJsZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbkRpc2FibGUpIHNlbGYuZWwuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbmFjdGl2ZSc6XG4gICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3MoYnV0dG9uLCBzZWxmLmNsYXNzTmFtZXMuYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyhidXR0b24sIHNlbGYuY2xhc3NOYW1lcy5kaXNhYmxlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FuRGlzYWJsZSkgc2VsZi5lbC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FuRGlzYWJsZSkgc2VsZi5lbC5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaC5hZGRDbGFzcyhidXR0b24sIHNlbGYuY2xhc3NOYW1lcy5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3MoYnV0dG9uLCBzZWxmLmNsYXNzTmFtZXMuYWN0aXZlKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuc3RhdHVzICE9PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRyb2wncyBzdGF0dXMgcHJvcGVyeSBpZiBub3QgbGl2ZVxuXG4gICAgICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUmVuZGVyU3RhdHVzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWl4aXR1cC5jb250cm9scyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5TdHlsZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy54ICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMueSAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnRvcCAgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5yaWdodCAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMuYm90dG9tICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLmxlZnQgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ICAgID0gMDtcbiAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gICA9IDA7XG4gICAgICAgIHRoaXMub3BhY2l0eSAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnNjYWxlICAgICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVggICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVkgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVogICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnJvdGF0ZVggICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnJvdGF0ZVkgICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnJvdGF0ZVogICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlN0eWxlRGF0YSk7XG5cbiAgICBtaXhpdHVwLlN0eWxlRGF0YS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5TdHlsZURhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5TdHlsZURhdGE7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLlRyYW5zZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSAgPSAwO1xuICAgICAgICB0aGlzLnVuaXQgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlRyYW5zZm9ybURhdGEpO1xuXG4gICAgbWl4aXR1cC5UcmFuc2Zvcm1EYXRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLlRyYW5zZm9ybURhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5UcmFuc2Zvcm1EYXRhO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5UcmFuc2Zvcm1EZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLlN0eWxlRGF0YS5hcHBseSh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnNjYWxlLnZhbHVlICAgICAgICA9IDAuMDE7XG4gICAgICAgIHRoaXMuc2NhbGUudW5pdCAgICAgICAgID0gJyc7XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGVYLnZhbHVlICAgPSAyMDtcbiAgICAgICAgdGhpcy50cmFuc2xhdGVYLnVuaXQgICAgPSAncHgnO1xuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlWS52YWx1ZSAgID0gMjA7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlWS51bml0ICAgID0gJ3B4JztcblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVoudmFsdWUgICA9IDIwO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVoudW5pdCAgICA9ICdweCc7XG5cbiAgICAgICAgdGhpcy5yb3RhdGVYLnZhbHVlICAgICAgPSA5MDtcbiAgICAgICAgdGhpcy5yb3RhdGVYLnVuaXQgICAgICAgPSAnZGVnJztcblxuICAgICAgICB0aGlzLnJvdGF0ZVkudmFsdWUgICAgICA9IDkwO1xuICAgICAgICB0aGlzLnJvdGF0ZVkudW5pdCAgICAgICA9ICdkZWcnO1xuXG4gICAgICAgIHRoaXMucm90YXRlWC52YWx1ZSAgICAgID0gOTA7XG4gICAgICAgIHRoaXMucm90YXRlWC51bml0ICAgICAgID0gJ2RlZyc7XG5cbiAgICAgICAgdGhpcy5yb3RhdGVaLnZhbHVlICAgICAgPSAxODA7XG4gICAgICAgIHRoaXMucm90YXRlWi51bml0ICAgICAgID0gJ2RlZyc7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuVHJhbnNmb3JtRGVmYXVsdHMpO1xuXG4gICAgbWl4aXR1cC5UcmFuc2Zvcm1EZWZhdWx0cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuU3R5bGVEYXRhLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLlRyYW5zZm9ybURlZmF1bHRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuVHJhbnNmb3JtRGVmYXVsdHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAqIEB0eXBlICAgIHttaXhpdHVwLlRyYW5zZm9ybURlZmF1bHRzfVxuICAgICAqL1xuXG4gICAgbWl4aXR1cC50cmFuc2Zvcm1EZWZhdWx0cyA9IG5ldyBtaXhpdHVwLlRyYW5zZm9ybURlZmF1bHRzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkV2ZW50RGV0YWlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmZ1dHVyZVN0YXRlICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCAgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYG1peGl0dXAuRXZlbnRzYCBjbGFzcyBjb250YWlucyBhbGwgY3VzdG9tIGV2ZW50cyBkaXNwYXRjaGVkIGJ5IE1peEl0VXAgYXQgdmFyaW91c1xuICAgICAqIHBvaW50cyB3aXRoaW4gdGhlIGxpZmVjeWNsZSBvZiBhIG1peGVyIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEVhY2ggZXZlbnQgaXMgYW5hbG9nb3VzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvZiB0aGUgc2FtZSBuYW1lIGRlZmluZWQgaW5cbiAgICAgKiB0aGUgYGNhbGxiYWNrc2AgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCBpcyB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGl0LlxuICAgICAqXG4gICAgICogRXZlbnRzIGFyZSBhbHdheXMgdHJpZ2dlcmVkIGZyb20gdGhlIGNvbnRhaW5lciBlbGVtZW50IG9uIHdoaWNoIE1peEl0VXAgaXMgaW5zdGFudGlhdGVkXG4gICAgICogdXBvbi5cbiAgICAgKlxuICAgICAqIEFzIHdpdGggYW55IGV2ZW50LCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzIHJlY2VpdmUgdGhlIGV2ZW50IG9iamVjdCBhcyBhIHBhcmFtZXRlclxuICAgICAqIHdoaWNoIGluY2x1ZGVzIGEgYGRldGFpbGAgcHJvcGVydHkgY29udGFpbnRpbmcgcmVmZXJlbmNlcyB0byB0aGUgY3VycmVudCBgc3RhdGVgLFxuICAgICAqIHRoZSBgbWl4ZXJgIGluc3RhbmNlLCBhbmQgb3RoZXIgZXZlbnQtc3BlY2lmaWMgcHJvcGVydGllcyBkZXNjcmliZWQgYmVsb3cuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXN0b20gZXZlbnQgdHJpZ2dlcmVkIGltbWVkaWF0ZWx5IGFmdGVyIGFueSBNaXhJdFVwIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWRcbiAgICAgICAgICogYW5kIGJlZm9yZSBhbmltYXRpb25zIGhhdmUgYmVndW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgbWl4U3RhcnRgIGV2ZW50IGFsc28gZXhwb3NlcyBhIGBmdXR1cmVTdGF0ZWAgcHJvcGVydHkgdmlhIHRoZVxuICAgICAgICAgKiBgZXZlbnQuZGV0YWlsYCBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBtaXhlciBvbmNlXG4gICAgICAgICAqIHRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtaXhTdGFydFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5FdmVudHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSAgICAgICAge0N1c3RvbUV2ZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1peFN0YXJ0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXN0b20gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBNaXhJdFVwIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWQgd2hpbGUgYW5vdGhlclxuICAgICAgICAgKiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MsIGFuZCB0aGUgYW5pbWF0aW9uIHF1ZXVlIGlzIGZ1bGwsIG9yIHF1ZXVlaW5nXG4gICAgICAgICAqIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbWl4QnVzeVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5FdmVudHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSAgICAgICAge0N1c3RvbUV2ZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1peEJ1c3kgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBldmVudCB0cmlnZ2VyZWQgYWZ0ZXIgYW55IE1peEl0VXAgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQsIGFuZCB0aGVcbiAgICAgICAgICogc3RhdGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIG1peEVuZFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5FdmVudHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSAgICAgICAge0N1c3RvbUV2ZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1peEVuZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3VzdG9tIGV2ZW50IHRyaWdnZXJlZCB3aGVuZXZlciBhIGZpbHRlciBvcGVyYXRpb24gXCJmYWlsc1wiLCBpLmUuIG5vIHRhcmdldHNcbiAgICAgICAgICogY291bGQgYmUgZm91bmQgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBmaWx0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtaXhGYWlsXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkV2ZW50c1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Q3VzdG9tRXZlbnR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubWl4RmFpbCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3VzdG9tIGV2ZW50IHRyaWdnZXJlZCB3aGVuZXZlciBhIE1peEl0VXAgY29udHJvbCBpcyBjbGlja2VkLCBhbmQgYmVmb3JlIGl0c1xuICAgICAgICAgKiByZXNwZWN0aXZlIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgYWxzbyBleHBvc2VzIGFuIGBvcmlnaW5hbEV2ZW50YCBwcm9wZXJ0eSB2aWEgdGhlIGBldmVudC5kZXRhaWxgXG4gICAgICAgICAqIG9iamVjdCwgd2hpY2ggaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGNsaWNrIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbWl4Q2xpY2tcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuRXZlbnRzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtDdXN0b21FdmVudH1cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5taXhDbGljayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuRXZlbnRzKTtcblxuICAgIG1peGl0dXAuRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkV2ZW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkV2ZW50cztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICAgIGVsXG4gICAgICogQHBhcmFtICAge29iamVjdH0gICAgICBkZXRhaWxcbiAgICAgKiBAcGFyYW0gICB7RG9jdW1lbnR9ICAgIFtkb2NdXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkV2ZW50cy5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZWwsIGRldGFpbCwgZG9jKSB7XG4gICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBldmVudCAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBldmVudERldGFpbCA9IG5ldyBtaXhpdHVwLkV2ZW50RGV0YWlsKCk7XG5cbiAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlRmlyZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmW2V2ZW50VHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgXCInICsgZXZlbnRUeXBlICsgJ1wiIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50RGV0YWlsLnN0YXRlID0gbmV3IG1peGl0dXAuU3RhdGUoKTtcblxuICAgICAgICBoLmV4dGVuZChldmVudERldGFpbC5zdGF0ZSwgZGV0YWlsLnN0YXRlKTtcblxuICAgICAgICBpZiAoZGV0YWlsLmZ1dHVyZVN0YXRlKSB7XG4gICAgICAgICAgICBldmVudERldGFpbC5mdXR1cmVTdGF0ZSA9IG5ldyBtaXhpdHVwLlN0YXRlKCk7XG5cbiAgICAgICAgICAgIGguZXh0ZW5kKGV2ZW50RGV0YWlsLmZ1dHVyZVN0YXRlLCBkZXRhaWwuZnV0dXJlU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnREZXRhaWwuaW5zdGFuY2UgPSBkZXRhaWwuaW5zdGFuY2U7XG5cbiAgICAgICAgaWYgKGRldGFpbC5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICBldmVudERldGFpbC5vcmlnaW5hbEV2ZW50ID0gZGV0YWlsLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudCA9IGguZ2V0Q3VzdG9tRXZlbnQoZXZlbnRUeXBlLCBldmVudERldGFpbCwgZG9jKTtcblxuICAgICAgICBzZWxmLmNhbGxGaWx0ZXJzKCdldmVudEZpcmUnLCBldmVudCwgYXJndW1lbnRzKTtcblxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLy8gQXNpZ24gYSBzaW5nbGV0b24gaW5zdGFuY2UgdG8gYG1peGl0dXAuZXZlbnRzYDpcblxuICAgIG1peGl0dXAuZXZlbnRzID0gbmV3IG1peGl0dXAuRXZlbnRzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLlF1ZXVlSXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmFyZ3MgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24gICAgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWdnZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNUb2dnbGluZyAgICAgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5RdWV1ZUl0ZW0pO1xuXG4gICAgbWl4aXR1cC5RdWV1ZUl0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuUXVldWVJdGVtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuUXVldWVJdGVtO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBtaXhpdHVwLk1peGVyYCBjbGFzcyBpcyB1c2VkIHRvIGhvbGQgZGlzY3JlZXQsIHVzZXItY29uZmlndXJlZFxuICAgICAqIGluc3RhbmNlcyBvZiBNaXhJdFVwIG9uIGEgcHJvdmlkZWQgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBNaXhlciBpbnN0YW5jZXMgYXJlIHJldHVybmVkIHdoZW5ldmVyIHRoZSBgbWl4aXR1cCgpYCBmYWN0b3J5IGZ1bmN0aW9uIGlzIGNhbGxlZCxcbiAgICAgKiB3aGljaCBleHBvc2UgYSByYW5nZSBvZiBtZXRob2RzIGVuYWJsaW5nIEFQSS1iYXNlZCBmaWx0ZXJpbmcsIHNvcnRpbmcsXG4gICAgICogaW5zZXJ0aW9uLCByZW1vdmFsIGFuZCBtb3JlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5NaXhlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmNvbmZpZyAgICAgICAgICAgID0gbmV3IG1peGl0dXAuQ29uZmlnKCk7XG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuaXNCdXN5ICAgICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RvZ2dsaW5nICAgICAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluY1BhZGRpbmcgICAgICAgID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xzICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMudGFyZ2V0cyAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5vcmlnT3JkZXIgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLmNhY2hlICAgICAgICAgICAgID0ge307XG5cbiAgICAgICAgdGhpcy50b2dnbGVBcnJheSAgICAgICA9IFtdO1xuXG4gICAgICAgIHRoaXMudGFyZ2V0c01vdmVkICAgICAgPSAwO1xuICAgICAgICB0aGlzLnRhcmdldHNJbW1vdmFibGUgID0gMDtcbiAgICAgICAgdGhpcy50YXJnZXRzQm91bmQgICAgICA9IDA7XG4gICAgICAgIHRoaXMudGFyZ2V0c0RvbmUgICAgICAgPSAwO1xuXG4gICAgICAgIHRoaXMuc3RhZ2dlckR1cmF0aW9uICAgPSAwO1xuICAgICAgICB0aGlzLmVmZmVjdHNJbiAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZmZlY3RzT3V0ICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtSW4gICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1PdXQgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXVlICAgICAgICAgICAgID0gW107XG5cbiAgICAgICAgdGhpcy5zdGF0ZSAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE9wZXJhdGlvbiAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbGlja2VkICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudXNlckRlZmVycmVkICAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZG9tICAgICAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5NaXhlckRvbSgpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLk1peGVyKTtcblxuICAgIG1peGl0dXAuTWl4ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIGguZXh0ZW5kKG1peGl0dXAuTWl4ZXIucHJvdG90eXBlLFxuICAgIC8qKiBAbGVuZHMgbWl4aXR1cC5NaXhlciAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuTWl4ZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvY3VtZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGlkXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtjb25maWddXG4gICAgICAgICAqL1xuXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24oY29udGFpbmVyLCBkb2N1bWVudCwgaWQsIGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQXR0YWNoJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5pZCA9IGlkO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaC5leHRlbmQoc2VsZi5jb25maWcsIGNvbmZpZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuc2FuaXRpemVDb25maWcoKTtcblxuICAgICAgICAgICAgc2VsZi5jYWNoZURvbShjb250YWluZXIsIGRvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmxheW91dC5jb250YWluZXJDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBoLmFkZENsYXNzKHNlbGYuZG9tLmNvbnRhaW5lciwgc2VsZi5jb25maWcubGF5b3V0LmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWl4aXR1cC5mZWF0dXJlcy5oYXMudHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmNvbnNvbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZGVidWcuc2hvd1dhcm5pbmdzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kYXRhLnVpZEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhc2V0IEFQSSBpcyBpbiB1c2UsIGZvcmNlIGRpc2FibGUgY29udHJvbHNcblxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmNvbnRyb2xzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmluZGV4VGFyZ2V0cygpO1xuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gc2VsZi5nZXRJbml0aWFsU3RhdGUoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc2VsZi5sYXN0T3BlcmF0aW9uLnRvSGlkZVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNvbnRyb2xzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdENvbnRyb2xzKCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkVG9nZ2xlQXJyYXkobnVsbCwgc2VsZi5zdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUNvbnRyb2xzKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBzZWxmLnN0YXRlLmFjdGl2ZUZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgc29ydDogc2VsZi5zdGF0ZS5hY3RpdmVTb3J0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGFyc2VFZmZlY3RzKCk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyQXR0YWNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBzYW5pdGl6ZUNvbmZpZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNhbml0aXplQ29uZmlnJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gU2FuaXRpemUgZW51bS9zdHJpbmcgY29uZmlnIG9wdGlvbnNcblxuICAgICAgICAgICAgc2VsZi5jb25maWcuY29udHJvbHMuc2NvcGUgICAgICAgICAgPSBzZWxmLmNvbmZpZy5jb250cm9scy5zY29wZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmNvbnRyb2xzLnRvZ2dsZUxvZ2ljICAgID0gc2VsZi5jb25maWcuY29udHJvbHMudG9nZ2xlTG9naWMudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5jb250cm9scy50b2dnbGVEZWZhdWx0ICA9IHNlbGYuY29uZmlnLmNvbnRyb2xzLnRvZ2dsZURlZmF1bHQudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lZmZlY3RzICAgICAgID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVmZmVjdHMudHJpbSgpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclNhbml0aXplQ29uZmlnJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEByZXR1cm4gIHttaXhpdHVwLlN0YXRlfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICA9IG5ldyBtaXhpdHVwLlN0YXRlKCksXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgPSBuZXcgbWl4aXR1cC5PcGVyYXRpb24oKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR2V0SW5pdGlhbFN0YXRlJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gTWFwIGluaXRpYWwgdmFsdWVzIGludG8gYSBtb2NrIHN0YXRlIG9iamVjdCBpbiBvcmRlciB0byBjb25zdHJ1Y3QgYW4gb3BlcmF0aW9uXG5cbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZSA9IHNlbGYuY29uZmlnLmxheW91dC5jb250YWluZXJDbGFzc05hbWU7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5sb2FkLmRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhc2V0IEFQSVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5kYXRhLnVpZEtleSB8fCB0eXBlb2Ygc2VsZi5jb25maWcuZGF0YS51aWRLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWl4aXR1cC5tZXNzYWdlcy5lcnJvckNvbmZpZ0RhdGFVaWRLZXlOb3RTZXQoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0RGF0YXNldCA9IG9wZXJhdGlvbi5uZXdEYXRhc2V0ID0gc3RhdGUuYWN0aXZlRGF0YXNldCA9IHNlbGYuY29uZmlnLmxvYWQuZGF0YXNldC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydENvbnRhaW5lckNsYXNzTmFtZSA9IG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUgPSBzdGF0ZS5hY3RpdmVDb250YWluZXJDbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNob3cgPSBzZWxmLnRhcmdldHMuc2xpY2UoKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gc2VsZi5jYWxsRmlsdGVycygnc3RhdGVHZXRJbml0aWFsU3RhdGUnLCBzdGF0ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRE9NIEFQSVxuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlRmlsdGVyICAgICAgICAgICAgICA9IHNlbGYucGFyc2VGaWx0ZXJBcmdzKFtzZWxmLmNvbmZpZy5sb2FkLmZpbHRlcl0pLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlU29ydCAgICAgICAgICAgICAgICA9IHNlbGYucGFyc2VTb3J0QXJncyhbc2VsZi5jb25maWcubG9hZC5zb3J0XSkuY29tbWFuZDtcbiAgICAgICAgICAgICAgICBzdGF0ZS50b3RhbFRhcmdldHMgICAgICAgICAgICAgID0gc2VsZi50YXJnZXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gc2VsZi5jYWxsRmlsdGVycygnc3RhdGVHZXRJbml0aWFsU3RhdGUnLCBzdGF0ZSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlU29ydC5jb2xsZWN0aW9uIHx8IHN0YXRlLmFjdGl2ZVNvcnQuYXR0cmlidXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdyYW5kb20nIHx8IHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdkZXNjJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0aW5nIG9uIGxvYWRcblxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3U29ydCA9IHN0YXRlLmFjdGl2ZVNvcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zb3J0T3BlcmF0aW9uKG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcmludFNvcnQoZmFsc2UsIG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzID0gb3BlcmF0aW9uLm5ld09yZGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydE9yZGVyID0gb3BlcmF0aW9uLm5ld09yZGVyID0gc2VsZi50YXJnZXRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEZpbHRlciAgICAgICAgICAgICAgID0gb3BlcmF0aW9uLm5ld0ZpbHRlciAgICAgICAgICAgICAgID0gc3RhdGUuYWN0aXZlRmlsdGVyO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFNvcnQgICAgICAgICAgICAgICAgID0gb3BlcmF0aW9uLm5ld1NvcnQgICAgICAgICAgICAgICAgID0gc3RhdGUuYWN0aXZlU29ydDtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUgICA9IG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUgICA9IHN0YXRlLmFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID0gc2VsZi5jb25maWcuc2VsZWN0b3JzLnRhcmdldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdvcGVyYXRpb25HZXRJbml0aWFsU3RhdGUnLCBvcGVyYXRpb24sIFtzdGF0ZV0pO1xuXG4gICAgICAgICAgICBzZWxmLmxhc3RPcGVyYXRpb24gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUgPSBzZWxmLmJ1aWxkU3RhdGUob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZXMgcmVmZXJlbmNlcyBvZiBET00gZWxlbWVudHMgbmVjY2Vzc2FyeSBmb3IgdGhlIG1peGVyJ3MgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxIdG1sRWxlbWVudH0gICBkb2N1bWVudFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgY2FjaGVEb206IGZ1bmN0aW9uKGVsLCBkb2N1bWVudCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVDYWNoZURvbScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmRvY3VtZW50ICA9IGRvY3VtZW50O1xuICAgICAgICAgICAgc2VsZi5kb20uYm9keSAgICAgID0gc2VsZi5kb20uZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgICAgICAgICAgc2VsZi5kb20uY29udGFpbmVyID0gZWw7XG4gICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQgICAgPSBlbDtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJDYWNoZURvbScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4ZXMgYWxsIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBtaXhlciBtYXRjaGluZyB0aGUgYHNlbGVjdG9ycy50YXJnZXRgXG4gICAgICAgICAqIHNlbGVjdG9yLCBpbnN0YW50aWF0aW5nIGEgbWl4aXR1cC5UYXJnZXQgZm9yIGVhY2ggb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGluZGV4VGFyZ2V0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGVsICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YXNldCAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5kZXhUYXJnZXRzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5kb20udGFyZ2V0cyA9IHNlbGYuY29uZmlnLmxheW91dC5hbGxvd05lc3RlZFRhcmdldHMgP1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGYuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQpIDpcbiAgICAgICAgICAgICAgICBoLmNoaWxkcmVuKHNlbGYuZG9tLmNvbnRhaW5lciwgc2VsZi5jb25maWcuc2VsZWN0b3JzLnRhcmdldCwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBzZWxmLmRvbS50YXJnZXRzID0gaC5hcnJheUZyb21MaXN0KHNlbGYuZG9tLnRhcmdldHMpO1xuXG4gICAgICAgICAgICBzZWxmLnRhcmdldHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKChkYXRhc2V0ID0gc2VsZi5jb25maWcubG9hZC5kYXRhc2V0KSAmJiBkYXRhc2V0Lmxlbmd0aCAhPT0gc2VsZi5kb20udGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWl4aXR1cC5tZXNzYWdlcy5lcnJvckRhdGFzZXRQcmVyZW5kZXJlZE1pc21hdGNoKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5kb20udGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBlbCA9IHNlbGYuZG9tLnRhcmdldHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBuZXcgbWl4aXR1cC5UYXJnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaW5pdChlbCwgc2VsZiwgZGF0YXNldCA/IGRhdGFzZXRbaV0gOiB2b2lkKDApKTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaXNJbkRvbSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQgPSBzZWxmLmRvbS50YXJnZXRzWzBdLnBhcmVudEVsZW1lbnQgPT09IHNlbGYuZG9tLmNvbnRhaW5lciA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLmNvbnRhaW5lciA6XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLnRhcmdldHNbMF0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5vcmlnT3JkZXIgPSBzZWxmLnRhcmdldHM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVySW5kZXhUYXJnZXRzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0Q29udHJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24gICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBjb250cm9sRWxlbWVudHMgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlbCAgICAgICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJlbnQgICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBkZWxhZ2F0b3JzICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjb250cm9sICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gLTEsXG4gICAgICAgICAgICAgICAgaiAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVJbml0Q29udHJvbHMnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYuY29uZmlnLmNvbnRyb2xzLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9jYWwnOlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBzZWxmLmRvbS5jb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ2xvYmFsJzpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gc2VsZi5kb20uZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JDb25maWdJbnZhbGlkQ29udHJvbHNTY29wZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgZGVmaW5pdGlvbiA9IG1peGl0dXAuY29udHJvbERlZmluaXRpb25zW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuY29udHJvbHMubGl2ZSB8fCBkZWZpbml0aW9uLmxpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24ucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxhZ2F0b3JzID0gc2VsZi5kb21bZGVmaW5pdGlvbi5wYXJlbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlbGFnYXRvcnMgfHwgZGVsYWdhdG9ycy5sZW5ndGggPCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWxhZ2F0b3JzLmxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxhZ2F0b3JzID0gW2RlbGFnYXRvcnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYWdhdG9ycyA9IFtwYXJlbnRdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgKGVsID0gZGVsYWdhdG9yc1tqXSk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHNlbGYuZ2V0Q29udHJvbChlbCwgIGRlZmluaXRpb24udHlwZSwgZGVmaW5pdGlvbi5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udHJvbHMucHVzaChjb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xFbGVtZW50cyA9IHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGYuY29uZmlnLnNlbGVjdG9ycy5jb250cm9sICsgZGVmaW5pdGlvbi5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgKGVsID0gY29udHJvbEVsZW1lbnRzW2pdKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gc2VsZi5nZXRDb250cm9sKGVsLCBkZWZpbml0aW9uLnR5cGUsICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckluaXRDb250cm9scycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgdHlwZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgIHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm4gIHttaXhpdHVwLkNvbnRyb2x8bnVsbH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q29udHJvbDogZnVuY3Rpb24oZWwsIHR5cGUsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgY29udHJvbCA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRDb250cm9sJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRpYyBjb250cm9scyBvbmx5XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBjb250cm9sID0gbWl4aXR1cC5jb250cm9sc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmVsID09PSBlbCAmJiBjb250cm9sLmlzQm91bmQoc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgYWxyZWFkeSBib3VuZCB0byB0aGlzIG1peGVyIChhcyBhbm90aGVyIHR5cGUpLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOQjogVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgY29udHJvbHMgZnJvbSBiZWluZyByZWdpc3RlcmVkIHdoZXJlIGEgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pZ2h0IGNvbGxpZGUsIGVnOiBcIltkYXRhLWZpbHRlcl1cIiBhbmQgXCJbZGF0YS1maWx0ZXJdW2RhdGEtc29ydF1cIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnY29udHJvbEdldENvbnRyb2wnLCBudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRyb2wuZWwgPT09IGVsICYmIGNvbnRyb2wudHlwZSA9PT0gdHlwZSAmJiBjb250cm9sLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5vdGhlciBtaXhlciBpcyBhbHJlYWR5IHVzaW5nIHRoaXMgY29udHJvbCwgYWRkIHRoaXMgbWl4ZXIgYXMgYSBiaW5kaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuYWRkQmluZGluZyhzZWxmKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2NvbnRyb2xHZXRDb250cm9sJywgY29udHJvbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBjb250cm9sXG5cbiAgICAgICAgICAgIGNvbnRyb2wgPSBuZXcgbWl4aXR1cC5Db250cm9sKCk7XG5cbiAgICAgICAgICAgIGNvbnRyb2wuaW5pdChlbCwgdHlwZSwgc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICBjb250cm9sLmNsYXNzTmFtZXMuYmFzZSAgICAgPSBoLmdldENsYXNzbmFtZShzZWxmLmNvbmZpZy5jbGFzc05hbWVzLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnRyb2wuY2xhc3NOYW1lcy5hY3RpdmUgICA9IGguZ2V0Q2xhc3NuYW1lKHNlbGYuY29uZmlnLmNsYXNzTmFtZXMsIHR5cGUsIHNlbGYuY29uZmlnLmNsYXNzTmFtZXMubW9kaWZpZXJBY3RpdmUpO1xuICAgICAgICAgICAgY29udHJvbC5jbGFzc05hbWVzLmRpc2FibGVkID0gaC5nZXRDbGFzc25hbWUoc2VsZi5jb25maWcuY2xhc3NOYW1lcywgdHlwZSwgc2VsZi5jb25maWcuY2xhc3NOYW1lcy5tb2RpZmllckRpc2FibGVkKTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgcmVmZXJlbmNlIHRvIHRoaXMgbWl4ZXIgYXMgYSBiaW5kaW5nXG5cbiAgICAgICAgICAgIGNvbnRyb2wuYWRkQmluZGluZyhzZWxmKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2NvbnRyb2xHZXRDb250cm9sJywgY29udHJvbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvbXBvdW5kIHNlbGVjdG9yIGJ5IGpvaW5pbmcgdGhlIGB0b2dnbGVBcnJheWAgdmFsdWUgYXMgcGVyIHRoZVxuICAgICAgICAgKiBkZWZpbmVkIHRvZ2dsZSBsb2dpYy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldFRvZ2dsZVNlbGVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlbGluZWF0b3IgICAgICA9IHNlbGYuY29uZmlnLmNvbnRyb2xzLnRvZ2dsZUxvZ2ljID09PSAnb3InID8gJywgJyA6ICcnLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yICA9ICcnO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRUb2dnbGVTZWxlY3RvcicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYudG9nZ2xlQXJyYXkgPSBoLmNsZWFuKHNlbGYudG9nZ2xlQXJyYXkpO1xuXG4gICAgICAgICAgICB0b2dnbGVTZWxlY3RvciA9IHNlbGYudG9nZ2xlQXJyYXkuam9pbihkZWxpbmVhdG9yKTtcblxuICAgICAgICAgICAgaWYgKHRvZ2dsZVNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yID0gc2VsZi5jb25maWcuY29udHJvbHMudG9nZ2xlRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3NlbGVjdG9yR2V0VG9nZ2xlU2VsZWN0b3InLCB0b2dnbGVTZWxlY3RvciwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnJlYWtzIGNvbXBvdW5kIHNlbGVjdG9yIHN0cmluZ3MgaW4gYW4gYXJyYXkgb2YgZGlzY3JlZXQgc2VsZWN0b3JzLFxuICAgICAgICAgKiBhcyBwZXIgdGhlIGFjdGl2ZSBgY29udHJvbHMudG9nZ2xlTG9naWNgIGNvbmZpZ3VyYXRpb24gb3B0aW9uLiBBY2NlcHRzXG4gICAgICAgICAqIGVpdGhlciBhIGR5bmFtaWMgY29tbWFuZCBvYmplY3QsIG9yIGEgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgICAgIFtjb21tYW5kXVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5TdGF0ZX0gW3N0YXRlXVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgYnVpbGRUb2dnbGVBcnJheTogZnVuY3Rpb24oY29tbWFuZCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYWN0aXZlRmlsdGVyU2VsZWN0b3IgICAgPSAnJztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQnVpbGRUb2dnbGVBcnJheScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kICYmIGNvbW1hbmQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRmlsdGVyU2VsZWN0b3IgPSBjb21tYW5kLmZpbHRlci5zZWxlY3Rvci5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlclNlbGVjdG9yID0gc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUZpbHRlclNlbGVjdG9yID09PSBzZWxmLmNvbmZpZy5zZWxlY3RvcnMudGFyZ2V0IHx8IGFjdGl2ZUZpbHRlclNlbGVjdG9yID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlclNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jb250cm9scy50b2dnbGVMb2dpYyA9PT0gJ29yJykge1xuICAgICAgICAgICAgICAgIHNlbGYudG9nZ2xlQXJyYXkgPSBhY3RpdmVGaWx0ZXJTZWxlY3Rvci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5ID0gc2VsZi5zcGxpdENvbXBvdW5kU2VsZWN0b3IoYWN0aXZlRmlsdGVyU2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5ID0gaC5jbGVhbihzZWxmLnRvZ2dsZUFycmF5KTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJCdWlsZFRvZ2dsZUFycmF5JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBjb21wb3VuZCBzZWxlY3RvciAoZS5nLiBgLmNhdC0xLmNhdC0yYCwgYFtkYXRhLWNhdD1cIjFcIl1bZGF0YS1jYXQ9XCIyXCJdYClcbiAgICAgICAgICogYW5kIGJyZWFrcyBpbnRvIGl0cyBpbmRpdmlkdWFsIHNlbGVjdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IGNvbXBvdW5kU2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ1tdfVxuICAgICAgICAgKi9cblxuICAgICAgICBzcGxpdENvbXBvdW5kU2VsZWN0b3I6IGZ1bmN0aW9uKGNvbXBvdW5kU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIEJyZWFrIGF0IGEgYC5gIG9yIGBbYCwgY2FwdHVyaW5nIHRoZSBkZWxpbmVhdG9yXG5cbiAgICAgICAgICAgIHZhciBwYXJ0aWFscyAgICA9IGNvbXBvdW5kU2VsZWN0b3Iuc3BsaXQoLyhbXFwuXFxbXSkvZyksXG4gICAgICAgICAgICAgICAgdG9nZ2xlQXJyYXkgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0aWFsc1swXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFscy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RvciArPSBwYXJ0aWFsc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChpICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVBcnJheS5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b2dnbGVBcnJheTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBjb250cm9scyB0byB0aGVpciBhY3RpdmUvaW5hY3RpdmUgc3RhdGUgYmFzZWQgb24gdGhlIGNvbW1hbmQgb3JcbiAgICAgICAgICogY3VycmVudCBzdGF0ZSBvZiB0aGUgbWl4ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBjb21tYW5kXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICB1cGRhdGVDb250cm9sczogZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBudWxsLFxuICAgICAgICAgICAgICAgIG91dHB1dCAgPSBuZXcgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVVwZGF0ZUNvbnRyb2xzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gU2FuaXRpc2UgdG8gZGVmYXVsdHNcblxuICAgICAgICAgICAgaWYgKGNvbW1hbmQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmZpbHRlciA9IGNvbW1hbmQuZmlsdGVyLnNlbGVjdG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZmlsdGVyID0gc2VsZi5zdGF0ZS5hY3RpdmVGaWx0ZXIuc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kLnNvcnQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc29ydCA9IHNlbGYuYnVpbGRTb3J0U3RyaW5nKGNvbW1hbmQuc29ydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zb3J0ID0gc2VsZi5idWlsZFNvcnRTdHJpbmcoc2VsZi5zdGF0ZS5hY3RpdmVTb3J0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG91dHB1dC5maWx0ZXIgPT09IHNlbGYuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZmlsdGVyID0gJ2FsbCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXQuZmlsdGVyID09PSAnJykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5maWx0ZXIgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGguZnJlZXplKG91dHB1dCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGNvbnRyb2wgPSBzZWxmLmNvbnRyb2xzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnVwZGF0ZShvdXRwdXQsIHNlbGYudG9nZ2xlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclVwZGF0ZUNvbnRyb2xzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRTb3J0fSAgIGNvbW1hbmRcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgYnVpbGRTb3J0U3RyaW5nOiBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ICA9ICcnO1xuXG4gICAgICAgICAgICBvdXRwdXQgKz0gY29tbWFuZC5zb3J0U3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoY29tbWFuZC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcgJyArIHNlbGYuYnVpbGRTb3J0U3RyaW5nKGNvbW1hbmQubmV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICAgICAgY29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaW5zZXJ0VGFyZ2V0czogZnVuY3Rpb24oY29tbWFuZCwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ICA9IC0xLFxuICAgICAgICAgICAgICAgIGZyYWcgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlbCAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVJbnNlcnRUYXJnZXRzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kLmluZGV4ID09PSAndW5kZWZpbmVkJykgY29tbWFuZC5pbmRleCA9IDA7XG5cbiAgICAgICAgICAgIG5leHRTaWJsaW5nID0gc2VsZi5nZXROZXh0U2libGluZyhjb21tYW5kLmluZGV4LCBjb21tYW5kLnNpYmxpbmcsIGNvbW1hbmQucG9zaXRpb24pO1xuICAgICAgICAgICAgZnJhZyAgICAgICAgPSBzZWxmLmRvbS5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gaC5pbmRleChuZXh0U2libGluZywgc2VsZi5jb25maWcuc2VsZWN0b3JzLnRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gc2VsZi50YXJnZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1hbmQuY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGVsID0gY29tbWFuZC5jb2xsZWN0aW9uW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZG9tLnRhcmdldHMuaW5kZXhPZihlbCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JJbnNlcnRQcmVleGlzdGluZ0VsZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgZWxlbWVudHMgYXJlIGhpZGRlbiB3aGVuIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBET00sIHNvIHRoZXkgY2FuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGFuaW1hdGVkIGluIGdyYWNlZnVsbHlcblxuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHNlbGYuZG9tLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaC5pc0VsZW1lbnQoZWwsIHNlbGYuZG9tLmRvY3VtZW50KSB8fCAhZWwubWF0Y2hlcyhzZWxmLmNvbmZpZy5zZWxlY3RvcnMudGFyZ2V0KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbmV3IG1peGl0dXAuVGFyZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmluaXQoZWwsIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50Lmluc2VydEJlZm9yZShmcmFnLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNpbmNlIHRhcmdldHMgaGF2ZSBiZWVuIGFkZGVkLCB0aGUgb3JpZ2luYWwgb3JkZXIgbXVzdCBiZSB1cGRhdGVkXG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydE9yZGVyID0gc2VsZi5vcmlnT3JkZXIgPSBzZWxmLnRhcmdldHM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVySW5zZXJ0VGFyZ2V0cycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICAgIFtpbmRleF1cbiAgICAgICAgICogQHBhcmFtICAge0VsZW1lbnR9ICAgICBbc2libGluZ11cbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICBbcG9zaXRpb25dXG4gICAgICAgICAqIEByZXR1cm4gIHtFbGVtZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXROZXh0U2libGluZzogZnVuY3Rpb24oaW5kZXgsIHNpYmxpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBwb3NpdGlvbiA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBzaWJsaW5nXG5cbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2libGluZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2libGluZyAmJiBwb3NpdGlvbiA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHNpYmxpbmdcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzaWJsaW5nLm5leHRFbGVtZW50U2libGluZyB8fCBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnRhcmdldHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5kZXggYW5kIHRhcmdldHMgZXhpc3RcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAoaW5kZXggPCBzZWxmLnRhcmdldHMubGVuZ3RoIHx8ICFzZWxmLnRhcmdldHMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0c1tpbmRleF0uZG9tLmVsIDpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzW3NlbGYudGFyZ2V0cy5sZW5ndGggLSAxXS5kb20uZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnRhcmdldHMubGVuZ3RoID09PSAwICYmIHNlbGYuZG9tLnBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gdGFyZ2V0cyBidXQgb3RoZXIgc2libGluZ3NcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5sYXlvdXQuc2libGluZ0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZWxmLmNvbmZpZy5sYXlvdXQuc2libGluZ0FmdGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5jb25maWcubGF5b3V0LnNpYmxpbmdCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlbGYuY29uZmlnLmxheW91dC5zaWJsaW5nQmVmb3JlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID09PSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnZWxlbWVudEdldE5leHRTaWJsaW5nJywgZWxlbWVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGZpbHRlck9wZXJhdGlvbjogZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5kZXggICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBhY3Rpb24gICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVGaWx0ZXJPcGVyYXRpb24nLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBhY3Rpb24gPSBvcGVyYXRpb24ubmV3RmlsdGVyLmFjdGlvbjtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLm5ld09yZGVyW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm5ld0ZpbHRlci5jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3cgdmlhIGNvbGxlY3Rpb25cblxuICAgICAgICAgICAgICAgICAgICB0ZXN0UmVzdWx0ID0gb3BlcmF0aW9uLm5ld0ZpbHRlci5jb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LmRvbS5lbCkgPiAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG93IHZpYSBzZWxlY3RvclxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFJlc3VsdCA9IHRhcmdldC5kb20uZWwubWF0Y2hlcyhvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZXZhbHVhdGVIaWRlU2hvdyh0ZXN0UmVzdWx0LCB0YXJnZXQsIGFjdGlvbiwgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi50b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24udG9SZW1vdmUuaW5kZXhPZih0YXJnZXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFueSBzaG93biB0YXJnZXRzIHNob3VsZCBiZSByZW1vdmVkLCBtb3ZlIHRoZW0gaW50byB0aGUgdG9IaWRlIGFycmF5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93LnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpbmRleCA9IG9wZXJhdGlvbi50b1Nob3cuaW5kZXhPZih0YXJnZXQpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvU2hvdy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udG9IaWRlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5oaWRlLnB1c2godGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRpb24ubWF0Y2hpbmcgPSBvcGVyYXRpb24uc2hvdy5zbGljZSgpO1xuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNob3cubGVuZ3RoID09PSAwICYmIG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgIT09ICcnICYmIHNlbGYudGFyZ2V0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uaGFzRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJGaWx0ZXJPcGVyYXRpb24nLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgdGVzdFJlc3VsdFxuICAgICAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZXZhbHVhdGVIaWRlU2hvdzogZnVuY3Rpb24odGVzdFJlc3VsdCwgdGFyZ2V0LCBhY3Rpb24sIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVGVzdFJlc3VsdCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAgICAgICBmaWx0ZXJlZFRlc3RSZXN1bHQgPSBzZWxmLmNhbGxGaWx0ZXJzKCd0ZXN0UmVzdWx0RXZhbHVhdGVIaWRlU2hvdycsIHRlc3RSZXN1bHQsIGFyZ3MpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVFdmFsdWF0ZUhpZGVTaG93JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVGVzdFJlc3VsdCA9PT0gdHJ1ZSAmJiBhY3Rpb24gPT09ICdzaG93JyB8fFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVGVzdFJlc3VsdCA9PT0gZmFsc2UgJiYgYWN0aW9uID09PSAnaGlkZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93LnB1c2godGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICF0YXJnZXQuaXNTaG93biAmJiBvcGVyYXRpb24udG9TaG93LnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLmhpZGUucHVzaCh0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmlzU2hvd24gJiYgb3BlcmF0aW9uLnRvSGlkZS5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyRXZhbHVhdGVIaWRlU2hvdycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBzb3J0T3BlcmF0aW9uOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbmV3T3JkZXIgPSBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZWwgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNvcnRPcGVyYXRpb24nLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRPcmRlciA9IHNlbGYudGFyZ2V0cztcblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5uZXdTb3J0LmNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGNvbGxlY3Rpb25cblxuICAgICAgICAgICAgICAgIG5ld09yZGVyID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoZWwgPSBvcGVyYXRpb24ubmV3U29ydC5jb2xsZWN0aW9uW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRvbS50YXJnZXRzLmluZGV4T2YoZWwpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JTb3J0Tm9uRXhpc3RlbnRFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbmV3IG1peGl0dXAuVGFyZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmluaXQoZWwsIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdPcmRlci5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld09yZGVyID0gbmV3T3JkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdTb3J0Lm9yZGVyID09PSAncmFuZG9tJykge1xuICAgICAgICAgICAgICAgIC8vIFNvcnQgcmFuZG9tXG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIgPSBoLmFycmF5U2h1ZmZsZShvcGVyYXRpb24uc3RhcnRPcmRlcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdTb3J0LmF0dHJpYnV0ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGRlZmF1bHRcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdPcmRlciA9IHNlbGYub3JpZ09yZGVyLnNsaWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm5ld1NvcnQub3JkZXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU29ydCBieSBhdHRyaWJ1dGVcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdPcmRlciA9IG9wZXJhdGlvbi5zdGFydE9yZGVyLnNsaWNlKCk7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbXBhcmUoYSwgYiwgb3BlcmF0aW9uLm5ld1NvcnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaC5pc0VxdWFsQXJyYXkob3BlcmF0aW9uLm5ld09yZGVyLCBvcGVyYXRpb24uc3RhcnRPcmRlcikpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ud2lsbFNvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJTb3J0T3BlcmF0aW9uJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLlRhcmdldH0gICAgICAgIGFcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuVGFyZ2V0fSAgICAgICAgYlxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5Db21tYW5kU29ydH0gICBjb21tYW5kXG4gICAgICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGEsIGIsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3JkZXIgICAgICAgPSBjb21tYW5kLm9yZGVyLFxuICAgICAgICAgICAgICAgIGF0dHJBICAgICAgID0gc2VsZi5nZXRBdHRyaWJ1dGVWYWx1ZShhLCBjb21tYW5kLmF0dHJpYnV0ZSksXG4gICAgICAgICAgICAgICAgYXR0ckIgICAgICAgPSBzZWxmLmdldEF0dHJpYnV0ZVZhbHVlKGIsIGNvbW1hbmQuYXR0cmlidXRlKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGF0dHJBICogMSkgfHwgaXNOYU4oYXR0ckIgKiAxKSkge1xuICAgICAgICAgICAgICAgIGF0dHJBID0gYXR0ckEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBhdHRyQiA9IGF0dHJCLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJBID0gYXR0ckEgKiAxO1xuICAgICAgICAgICAgICAgIGF0dHJCID0gYXR0ckIgKiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0ckEgPCBhdHRyQikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmRlciA9PT0gJ2FzYycgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdHRyQSA+IGF0dHJCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyID09PSAnYXNjJyA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJBID09PSBhdHRyQiAmJiBjb21tYW5kLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKGEsIGIsIGNvbW1hbmQubmV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyB0aGUgdmFsdWVzIG9mIGFueSBkYXRhIGF0dHJpYnV0ZXMgcHJlc2VudCB0aGUgcHJvdmlkZWQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogd2hpY2ggbWF0Y2ggdGhlIGN1cnJlbnQgc29ydCBjb21tYW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuVGFyZ2V0fSAgICB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBbYXR0cmlidXRlXVxuICAgICAgICAgKiBAcmV0dXJuICB7KFN0cmluZ3xOdW1iZXIpfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZTogZnVuY3Rpb24odGFyZ2V0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgID0gJyc7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0LmRvbS5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zy5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb3VyYWdlIHVzZXJzIHRvIGFzc2lnbiB2YWx1ZXMgdG8gYWxsIHRhcmdldHMgdG8gYXZvaWQgZXJyb25lb3VzIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0eXBlcyBhcmUgbWl4ZWRcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obWl4aXR1cC5tZXNzYWdlcy53YXJuaW5nSW5jb25zaXN0ZW50U29ydGluZ0F0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnZGF0YS0nICsgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCwgcmV0dXJuIDAgYXMgYSBzYWZldHkgdmFsdWVcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3ZhbHVlR2V0QXR0cmlidXRlVmFsdWUnLCB2YWx1ZSB8fCAwLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIGVsZW1lbnRzIGludG8gdGhlIERPTSBpbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICAgICogb3JkZXIgdXNpbmcgYSBkb2N1bWVudCBmcmFnbWVudCBmb3IgbWluaW1hbFxuICAgICAgICAgKiBET00gdGhyYXNoaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBpc1Jlc2V0dGluZ1xuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHByaW50U29ydDogZnVuY3Rpb24oaXNSZXNldHRpbmcsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGFydE9yZGVyICA9IGlzUmVzZXR0aW5nID8gb3BlcmF0aW9uLm5ld09yZGVyIDogb3BlcmF0aW9uLnN0YXJ0T3JkZXIsXG4gICAgICAgICAgICAgICAgbmV3T3JkZXIgICAgPSBpc1Jlc2V0dGluZyA/IG9wZXJhdGlvbi5zdGFydE9yZGVyIDogb3BlcmF0aW9uLm5ld09yZGVyLFxuICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gc3RhcnRPcmRlci5sZW5ndGggPyBzdGFydE9yZGVyW3N0YXJ0T3JkZXIubGVuZ3RoIC0gMV0uZG9tLmVsLm5leHRFbGVtZW50U2libGluZyA6IG51bGwsXG4gICAgICAgICAgICAgICAgZnJhZyAgICAgICAgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgID0gbnVsbCxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZWwgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVByaW50U29ydCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBjb250YWluZXJcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc3RhcnRPcmRlcltpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB0YXJnZXQuZG9tLmVsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsLnN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGgucmVtb3ZlV2hpdGVzcGFjZShlbC5wcmV2aW91c1NpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBuZXh0U2libGluZyA/IG5leHRTaWJsaW5nLnByZXZpb3VzU2libGluZyA6IHNlbGYuZG9tLnBhcmVudC5sYXN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGlmICh3aGl0ZXNwYWNlICYmIHdoaXRlc3BhY2Uubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICBoLnJlbW92ZVdoaXRlc3BhY2Uod2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG5ld09yZGVyW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGFyZ2V0cyBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnRcblxuICAgICAgICAgICAgICAgIGVsID0gdGFyZ2V0LmRvbS5lbDtcblxuICAgICAgICAgICAgICAgIGlmIChoLmlzRWxlbWVudChmcmFnLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgZG9jdW1lbnQgZnJhZ21lbnQgaW50byB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAvLyBiZWZvcmUgYW55IG90aGVyIG5vbi10YXJnZXQgZWxlbWVudHNcblxuICAgICAgICAgICAgaWYgKHNlbGYuZG9tLnBhcmVudC5maXJzdENoaWxkICYmIHNlbGYuZG9tLnBhcmVudC5maXJzdENoaWxkICE9PSBuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGZyYWcuaW5zZXJ0QmVmb3JlKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpLCBmcmFnLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5pbnNlcnRCZWZvcmUoZnJhZywgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUHJpbnRTb3J0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIHVzZXItZGVmaW5lZCBzb3J0IHN0cmluZ3MgKGkuZS4gYGRlZmF1bHQ6YXNjYCkgaW50byBzb3J0IGNvbW1hbmRzIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgICAgICAgICAgICBzb3J0U3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRTb3J0fSAgIGNvbW1hbmRcbiAgICAgICAgICogQHJldHVybiAge21peGl0dXAuQ29tbWFuZFNvcnR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlU29ydFN0cmluZzogZnVuY3Rpb24oc29ydFN0cmluZywgY29tbWFuZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBydWxlcyAgICAgICA9IHNvcnRTdHJpbmcuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50ICAgICA9IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgcnVsZSAgICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICAvLyBjb21tYW5kLnNvcnRTdHJpbmcgPSBzb3J0U3RyaW5nO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBydWxlID0gcnVsZXNbaV0uc3BsaXQoJzonKTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnQuc29ydFN0cmluZyAgPSBydWxlc1tpXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZSAgID0gaC5kYXNoQ2FzZShydWxlWzBdKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm9yZGVyICAgICAgID0gcnVsZVsxXSB8fCAnYXNjJztcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBcImRlZmF1bHRcIiBhcyBzb3J0aW5nIGJ5IG5vIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFuZG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IFwicmFuZG9tXCIgYXMgYW4gb3JkZXIgbm90IGFuIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZSAgID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm9yZGVyICAgICAgID0gJ3JhbmRvbSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudC5hdHRyaWJ1dGUgfHwgY3VycmVudC5vcmRlciA9PT0gJ3JhbmRvbScpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBydWxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtYmVkIHJlZmVyZW5jZSB0byB0aGUgbmV4dCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gbmV3IG1peGl0dXAuQ29tbWFuZFNvcnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBoLmZyZWV6ZShjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2NvbW1hbmRzUGFyc2VTb3J0JywgY29tbWFuZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFsbCBlZmZlY3RzIG91dCBvZiB0aGUgdXNlci1kZWZpbmVkIGBhbmltYXRpb24uZWZmZWN0c2Agc3RyaW5nIGludG9cbiAgICAgICAgICogdGhlaXIgcmVzcGVjdGl2ZSBwcm9wZXJ0aWVzIGFuZCB1bml0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZUVmZmVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTmFtZSAgID0gJycsXG4gICAgICAgICAgICAgICAgZWZmZWN0c0luICAgICAgID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVmZmVjdHNJbiB8fCBzZWxmLmNvbmZpZy5hbmltYXRpb24uZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBlZmZlY3RzT3V0ICAgICAgPSBzZWxmLmNvbmZpZy5hbmltYXRpb24uZWZmZWN0c091dCB8fCBzZWxmLmNvbmZpZy5hbmltYXRpb24uZWZmZWN0cztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlUGFyc2VFZmZlY3RzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5lZmZlY3RzSW4gICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgc2VsZi5lZmZlY3RzT3V0ICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1JbiAgICA9IFtdO1xuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1PdXQgICA9IFtdO1xuXG4gICAgICAgICAgICBzZWxmLmVmZmVjdHNJbi5vcGFjaXR5ID0gc2VsZi5lZmZlY3RzT3V0Lm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdmYWRlJywgZWZmZWN0c0luLCBzZWxmLmVmZmVjdHNJbiwgc2VsZi50cmFuc2Zvcm1Jbik7XG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdmYWRlJywgZWZmZWN0c091dCwgc2VsZi5lZmZlY3RzT3V0LCBzZWxmLnRyYW5zZm9ybU91dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGZvciAodHJhbnNmb3JtTmFtZSBpbiBtaXhpdHVwLnRyYW5zZm9ybURlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWl4aXR1cC50cmFuc2Zvcm1EZWZhdWx0c1t0cmFuc2Zvcm1OYW1lXSBpbnN0YW5jZW9mIG1peGl0dXAuVHJhbnNmb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJzZUVmZmVjdCh0cmFuc2Zvcm1OYW1lLCBlZmZlY3RzSW4sIHNlbGYuZWZmZWN0c0luLCBzZWxmLnRyYW5zZm9ybUluKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KHRyYW5zZm9ybU5hbWUsIGVmZmVjdHNPdXQsIHNlbGYuZWZmZWN0c091dCwgc2VsZi50cmFuc2Zvcm1PdXQsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdzdGFnZ2VyJywgZWZmZWN0c0luLCBzZWxmLmVmZmVjdHNJbiwgc2VsZi50cmFuc2Zvcm1Jbik7XG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdzdGFnZ2VyJywgZWZmZWN0c091dCwgc2VsZi5lZmZlY3RzT3V0LCBzZWxmLnRyYW5zZm9ybU91dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUGFyc2VFZmZlY3RzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGVmZmVjdE5hbWVcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgZWZmZWN0U3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHlsZURhdGF9IGVmZmVjdHNcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ1tdfSAgdHJhbnNmb3JtXG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgIFtpc091dF1cbiAgICAgICAgICovXG5cbiAgICAgICAgcGFyc2VFZmZlY3Q6IGZ1bmN0aW9uKGVmZmVjdE5hbWUsIGVmZmVjdFN0cmluZywgZWZmZWN0cywgdHJhbnNmb3JtLCBpc091dCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZSAgICAgICAgICA9IC9cXCgoW14pXSspXFwpLyxcbiAgICAgICAgICAgICAgICBwcm9wSW5kZXggICA9IC0xLFxuICAgICAgICAgICAgICAgIHN0ciAgICAgICAgID0gJycsXG4gICAgICAgICAgICAgICAgbWF0Y2ggICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2YWwgICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIHVuaXRzICAgICAgID0gWyclJywgJ3B4JywgJ2VtJywgJ3JlbScsICd2aCcsICd2dycsICdkZWcnXSxcbiAgICAgICAgICAgICAgICB1bml0ICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVBhcnNlRWZmZWN0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3RTdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yQ29uZmlnSW52YWxpZEFuaW1hdGlvbkVmZmVjdHMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlZmZlY3RTdHJpbmcuaW5kZXhPZihlZmZlY3ROYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBlZmZlY3RzIHN0cmluZ1xuXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdE5hbWUgPT09ICdzdGFnZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdGFnZ2VyIHRvIDBcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YWdnZXJEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGlzIHByZXNlbnRcblxuICAgICAgICAgICAgcHJvcEluZGV4ID0gZWZmZWN0U3RyaW5nLmluZGV4T2YoZWZmZWN0TmFtZSArICcoJyk7XG5cbiAgICAgICAgICAgIGlmIChwcm9wSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgaGFzIGEgdXNlciBkZWZpbmVkIHZhbHVlIGluIHBhcmVudGhlc2VzXG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZpcnN0IHBhcmVudGhlc2lzIHRvIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgICAgICAgICAgICAgICBzdHIgPSBlZmZlY3RTdHJpbmcuc3Vic3RyaW5nKHByb3BJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYmV0d2VlbiBcIihcIiBhbmQgXCIpXCJcblxuICAgICAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuXG4gICAgICAgICAgICAgICAgdmFsID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZWZmZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhZGUnOlxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLm9wYWNpdHkgPSB2YWwgPyBwYXJzZUZsb2F0KHZhbCkgOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YWdnZXInOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YWdnZXJEdXJhdGlvbiA9IHZhbCA/IHBhcnNlRmxvYXQodmFsKSA6IDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDdXJyZW50bHkgc3RhZ2dlciBtdXN0IGJlIGFwcGxpZWQgZ2xvYmFsbHksIGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBzZXBlcmF0ZSB2YWx1ZXMgYXJlIHNwZWNpZmllZCBmb3IgaW4vb3V0LCB0aGlzIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSByZXNwZWN0ZWRcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXIgZWZmZWN0cyBhcmUgdHJhbnNmb3JtcyBmb2xsb3dpbmcgdGhlIHNhbWUgc3RydWN0dXJlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3V0ICYmIHNlbGYuY29uZmlnLmFuaW1hdGlvbi5yZXZlcnNlT3V0ICYmIGVmZmVjdE5hbWUgIT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHNbZWZmZWN0TmFtZV0udmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWwgPyBwYXJzZUZsb2F0KHZhbCkgOiBtaXhpdHVwLnRyYW5zZm9ybURlZmF1bHRzW2VmZmVjdE5hbWVdLnZhbHVlKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0c1tlZmZlY3ROYW1lXS52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbCA/IHBhcnNlRmxvYXQodmFsKSA6IG1peGl0dXAudHJhbnNmb3JtRGVmYXVsdHNbZWZmZWN0TmFtZV0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgdW5pdCA9IHVuaXRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzW2VmZmVjdE5hbWVdLnVuaXQgPSB1bml0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHNbZWZmZWN0TmFtZV0udW5pdCA9IG1peGl0dXAudHJhbnNmb3JtRGVmYXVsdHNbZWZmZWN0TmFtZV0udW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0c1tlZmZlY3ROYW1lXS52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzW2VmZmVjdE5hbWVdLnVuaXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUGFyc2VFZmZlY3QnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge09wZXJhdGlvbn0gICAgIG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7U3RhdGV9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGJ1aWxkU3RhdGU6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICA9IG5ldyBtaXhpdHVwLlN0YXRlKCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUJ1aWxkU3RhdGUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBNYXAgdGFyZ2V0IGVsZW1lbnRzIGludG8gc3RhdGUgYXJyYXlzLlxuICAgICAgICAgICAgLy8gdGhlIHJlYWwgdGFyZ2V0IG9iamVjdHMgc2hvdWxkIG5ldmVyIGJlIGV4cG9zZWRcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc2VsZi50YXJnZXRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdGlvbi50b1JlbW92ZS5sZW5ndGggfHwgb3BlcmF0aW9uLnRvUmVtb3ZlLmluZGV4T2YodGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0cy5wdXNoKHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLm1hdGNoaW5nW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYXRjaGluZy5wdXNoKHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2hvdy5wdXNoKHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uaGlkZVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24udG9SZW1vdmUubGVuZ3RoIHx8IG9wZXJhdGlvbi50b1JlbW92ZS5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmhpZGUucHVzaCh0YXJnZXQuZG9tLmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmlkICAgICAgICAgICAgICAgICAgICAgICAgPSBzZWxmLmlkO1xuICAgICAgICAgICAgc3RhdGUuY29udGFpbmVyICAgICAgICAgICAgICAgICA9IHNlbGYuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUZpbHRlciAgICAgICAgICAgICAgPSBvcGVyYXRpb24ubmV3RmlsdGVyO1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlU29ydCAgICAgICAgICAgICAgICA9IG9wZXJhdGlvbi5uZXdTb3J0O1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlRGF0YXNldCAgICAgICAgICAgICA9IG9wZXJhdGlvbi5uZXdEYXRhc2V0O1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3NOYW1lICA9IG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWU7XG4gICAgICAgICAgICBzdGF0ZS5oYXNGYWlsZWQgICAgICAgICAgICAgICAgID0gb3BlcmF0aW9uLmhhc0ZhaWxlZDtcbiAgICAgICAgICAgIHN0YXRlLnRvdGFsVGFyZ2V0cyAgICAgICAgICAgICAgPSBzZWxmLnRhcmdldHMubGVuZ3RoO1xuICAgICAgICAgICAgc3RhdGUudG90YWxTaG93ICAgICAgICAgICAgICAgICA9IG9wZXJhdGlvbi5zaG93Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLnRvdGFsSGlkZSAgICAgICAgICAgICAgICAgPSBvcGVyYXRpb24uaGlkZS5sZW5ndGg7XG4gICAgICAgICAgICBzdGF0ZS50b3RhbE1hdGNoaW5nICAgICAgICAgICAgID0gb3BlcmF0aW9uLm1hdGNoaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLnRyaWdnZXJFbGVtZW50ICAgICAgICAgICAgPSBvcGVyYXRpb24udHJpZ2dlckVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdzdGF0ZUJ1aWxkU3RhdGUnLCBzdGF0ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgIHNob3VsZEFuaW1hdGVcbiAgICAgICAgICogQHBhcmFtICAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnb01peDogZnVuY3Rpb24oc2hvdWxkQW5pbWF0ZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkICAgID0gbnVsbDtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR29NaXgnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGlzIHNldCB0byAwbXMsXG4gICAgICAgICAgICAvLyBvciBubyBlZmZlY3RzIHNwZWNpZmllZCxcbiAgICAgICAgICAgIC8vIG9yIHRoZSBjb250YWluZXIgaXMgaGlkZGVuXG4gICAgICAgICAgICAvLyB0aGVuIGFib3J0IGFuaW1hdGlvblxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmFuaW1hdGlvbi5kdXJhdGlvbiB8fCAhc2VsZi5jb25maWcuYW5pbWF0aW9uLmVmZmVjdHMgfHwgIWguaXNWaXNpYmxlKHNlbGYuZG9tLmNvbnRhaW5lcilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24udG9TaG93Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24udG9IaWRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24ud2lsbFNvcnQgJiZcbiAgICAgICAgICAgICAgICAhb3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgdG8gc2hvdyBvciBoaWRlLCBhbmQgbm90IHNvcnRpbmcgb3JcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2luZyBsYXlvdXRcblxuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24uc3RhcnRTdGF0ZS5zaG93Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24uc2hvdy5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgY3VycmVudGx5IHNob3duLCBub3RoaW5nIHRvIHNob3dcblxuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4aXR1cC5ldmVudHMuZmlyZSgnbWl4U3RhcnQnLCBzZWxmLmRvbS5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogb3BlcmF0aW9uLnN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgZnV0dXJlU3RhdGU6IG9wZXJhdGlvbi5uZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogc2VsZlxuICAgICAgICAgICAgfSwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmNhbGxiYWNrcy5vbk1peFN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuY2FsbGJhY2tzLm9uTWl4U3RhcnQuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kb20uY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxmXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyhzZWxmLmRvbS5jb250YWluZXIsIGguZ2V0Q2xhc3NuYW1lKHNlbGYuY29uZmlnLmNsYXNzTmFtZXMsICdjb250YWluZXInLCBzZWxmLmNvbmZpZy5jbGFzc05hbWVzLm1vZGlmaWVyRmFpbGVkKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi51c2VyRGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBRdWV1ZSBlbXB0eSwgbm8gcGVuZGluZyBvcGVyYXRpb25zXG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IHNlbGYudXNlckRlZmVycmVkID0gaC5kZWZlcihtaXhpdHVwLmxpYnJhcmllcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBleGlzdGluZyBkZWZlcnJlZFxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBzZWxmLnVzZXJEZWZlcnJlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5pc0J1c3kgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXNob3VsZEFuaW1hdGUgfHwgIW1peGl0dXAuZmVhdHVyZXMuaGFzLnRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnRcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zy5mYXV4QXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYW5VcChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCBzZWxmLmNvbmZpZy5hbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYW5VcChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwcm9taXNlR29NaXgnLCBkZWZlcnJlZC5wcm9taXNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBzaG91bGQgYW5pbWF0ZSBhbmQgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIHRyYW5zaXRpb25zLCBnbyBmb3IgaXRcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCAhPT0gb3BlcmF0aW9uLmRvY1N0YXRlLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhvcGVyYXRpb24uZG9jU3RhdGUuc2Nyb2xsTGVmdCwgb3BlcmF0aW9uLmRvY1N0YXRlLnNjcm9sbFRvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbmltYXRpb24uYXBwbHlQZXJzcGVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnBlcnNwZWN0aXZlUHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24ucGVyc3BlY3RpdmVEaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnBlcnNwZWN0aXZlT3JpZ2luUHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24ucGVyc3BlY3RpdmVPcmlnaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZUNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEhlaWdodCAhPT0gb3BlcmF0aW9uLm5ld0hlaWdodCAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi52aWV3cG9ydERlbHRhWSAhPT0gb3BlcmF0aW9uLnN0YXJ0SGVpZ2h0IC0gb3BlcmF0aW9uLm5ld0hlaWdodFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLmhlaWdodCA9IG9wZXJhdGlvbi5zdGFydEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZUNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFdpZHRoICE9PSBvcGVyYXRpb24ubmV3V2lkdGggJiZcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVggIT09IG9wZXJhdGlvbi5zdGFydFdpZHRoIC0gb3BlcmF0aW9uLm5ld1dpZHRoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUud2lkdGggPSBvcGVyYXRpb24uc3RhcnRXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uc3RhcnRIZWlnaHQgPT09IG9wZXJhdGlvbi5uZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUuaGVpZ2h0ID0gb3BlcmF0aW9uLnN0YXJ0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5zdGFydFdpZHRoID09PSBvcGVyYXRpb24ubmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUud2lkdGggPSBvcGVyYXRpb24uc3RhcnRXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uc3RhcnRIZWlnaHQgPT09IG9wZXJhdGlvbi5uZXdIZWlnaHQgJiYgb3BlcmF0aW9uLnN0YXJ0V2lkdGggPT09IG9wZXJhdGlvbi5uZXdXaWR0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb3ZlVGFyZ2V0cyhvcGVyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwcm9taXNlR29NaXgnLCBkZWZlcnJlZC5wcm9taXNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge09wZXJhdGlvbn0gICAgIG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0U3RhcnRNaXhEYXRhOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWxmLmRvbS5wYXJlbnQpLFxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3QgID0gc2VsZi5kb20ucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhICAgICAgICA9IHt9LFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTEsXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nICAgPSBwYXJlbnRTdHlsZVttaXhpdHVwLmZlYXR1cmVzLmJveFNpemluZ1Byb3BdO1xuXG4gICAgICAgICAgICBzZWxmLmluY1BhZGRpbmcgPSAoYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRTdGFydE1peERhdGEnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRhcmdldC5nZXRQb3NEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uc2hvd1Bvc0RhdGFbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zRGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi50b0hpZGVbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0YXJnZXQuZ2V0UG9zRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvSGlkZVBvc0RhdGFbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zRGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFggPSBwYXJlbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRZID0gcGFyZW50UmVjdC50b3A7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEhlaWdodCA9IHNlbGYuaW5jUGFkZGluZyA/XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC5oZWlnaHQgOlxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3QuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nVG9wKSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUucGFkZGluZ0JvdHRvbSkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlclRvcCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlckJvdHRvbSk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFdpZHRoID0gc2VsZi5pbmNQYWRkaW5nID9cbiAgICAgICAgICAgICAgICBwYXJlbnRSZWN0LndpZHRoIDpcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWN0LndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nTGVmdCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLnBhZGRpbmdSaWdodCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlckxlZnQpIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5ib3JkZXJSaWdodCk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyR2V0U3RhcnRNaXhEYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHNldEludGVyOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNldEludGVyJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxiYXIgZmxpY2tlciBvbiBub24taW5lcnRpYWwgc2Nyb2xsIHBsYXRmb3JtcyBieSBjbGFtcGluZyBoZWlnaHQvd2lkdGhcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5jbGFtcEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS5oZWlnaHQgICAgPSBvcGVyYXRpb24uc3RhcnRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS5vdmVyZmxvdyAgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5jbGFtcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLndpZHRoICAgICA9IG9wZXJhdGlvbi5zdGFydFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUub3ZlcmZsb3cgID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi50b1Nob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zaG93KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbENoYW5nZUxheW91dCkge1xuICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGguYWRkQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24ubmV3Q29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJTZXRJbnRlcicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRJbnRlck1peERhdGE6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR2V0SW50ZXJNaXhEYXRhJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93UG9zRGF0YVtpXS5pbnRlclBvc0RhdGEgPSB0YXJnZXQuZ2V0UG9zRGF0YSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udG9IaWRlUG9zRGF0YVtpXS5pbnRlclBvc0RhdGEgPSB0YXJnZXQuZ2V0UG9zRGF0YSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckdldEludGVyTWl4RGF0YScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBzZXRGaW5hbDogZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVTZXRGaW5hbCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi53aWxsU29ydCAmJiBzZWxmLnByaW50U29ydChmYWxzZSwgb3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnRvSGlkZVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJTZXRGaW5hbCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRGaW5hbE1peERhdGE6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwYXJlbnRTdHlsZSA9IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRGaW5hbE1peERhdGEnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNob3dQb3NEYXRhW2ldLmZpbmFsUG9zRGF0YSA9IHRhcmdldC5nZXRQb3NEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi50b0hpZGVbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi50b0hpZGVQb3NEYXRhW2ldLmZpbmFsUG9zRGF0YSA9IHRhcmdldC5nZXRQb3NEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBjbGFtcGluZ1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYW5pbWF0aW9uLmNsYW1wSGVpZ2h0IHx8IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5jbGFtcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLmhlaWdodCAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLndpZHRoICAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLm92ZXJmbG93ICA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlbGYuaW5jUGFkZGluZykge1xuICAgICAgICAgICAgICAgIHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2VsZi5kb20ucGFyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50UmVjdCAgPSBzZWxmLmRvbS5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdYID0gcGFyZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgb3BlcmF0aW9uLm5ld1kgPSBwYXJlbnRSZWN0LnRvcDtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0hlaWdodCA9IHNlbGYuaW5jUGFkZGluZyA/XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC5oZWlnaHQgOlxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3QuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nVG9wKSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUucGFkZGluZ0JvdHRvbSkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlclRvcCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlckJvdHRvbSk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdXaWR0aCA9IHNlbGYuaW5jUGFkZGluZyA/XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC53aWR0aCA6XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC53aWR0aCAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUucGFkZGluZ0xlZnQpIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nUmlnaHQpIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5ib3JkZXJMZWZ0KSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUuYm9yZGVyUmlnaHQpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVggPSBvcGVyYXRpb24uZG9jU3RhdGUudmlld3BvcnRXaWR0aCAtIHRoaXMuZG9tLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIG9wZXJhdGlvbi52aWV3cG9ydERlbHRhWSA9IG9wZXJhdGlvbi5kb2NTdGF0ZS52aWV3cG9ydEhlaWdodCAtIHRoaXMuZG9tLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbFNvcnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByaW50U29ydCh0cnVlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9TaG93W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHNlbGYuZG9tLmNvbnRhaW5lciwgb3BlcmF0aW9uLm5ld0NvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgaC5hZGRDbGFzcyhzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuY29uZmlnLmxheW91dC5jb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckdldEZpbmFsTWl4RGF0YScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0VHdlZW5EYXRhOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcG9zRGF0YSAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlZmZlY3ROYW1lcyAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmLmVmZmVjdHNJbiksXG4gICAgICAgICAgICAgICAgZWZmZWN0TmFtZSAgICAgID0gJycsXG4gICAgICAgICAgICAgICAgZWZmZWN0ICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICB3aWR0aENoYW5nZSAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2UgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBqICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR2V0VHdlZW5EYXRhJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc0RhdGEgICAgICAgICAgICAgPSBvcGVyYXRpb24uc2hvd1Bvc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbiAgICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0ICAgICAgPSBuZXcgbWl4aXR1cC5TdHlsZURhdGEoKTtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YSAgID0gbmV3IG1peGl0dXAuU3R5bGVEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHggYW5kIHlcblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNTaG93bikge1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLnggPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS54IC0gcG9zRGF0YS5pbnRlclBvc0RhdGEueDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi55ID0gcG9zRGF0YS5zdGFydFBvc0RhdGEueSAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi54ID0gcG9zRGF0YS5wb3NJbi55ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dC54ID0gcG9zRGF0YS5maW5hbFBvc0RhdGEueCAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLng7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQueSA9IHBvc0RhdGEuZmluYWxQb3NEYXRhLnkgLSBwb3NEYXRhLmludGVyUG9zRGF0YS55O1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBvcGFjaXR5XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLm9wYWNpdHkgICAgICAgPSB0YXJnZXQuaXNTaG93biA/IDEgOiBzZWxmLmVmZmVjdHNJbi5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0Lm9wYWNpdHkgICAgICA9IDE7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEub3BhY2l0eSAgID0gcG9zRGF0YS5wb3NPdXQub3BhY2l0eSAtIHBvc0RhdGEucG9zSW4ub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB4IGFuZCB5IGlmIG5vdCBudWRnaW5nXG5cbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1Nob3duICYmICFzZWxmLmNvbmZpZy5hbmltYXRpb24ubnVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi54ID0gcG9zRGF0YS5wb3NPdXQueDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi55ID0gcG9zRGF0YS5wb3NPdXQueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS54ID0gcG9zRGF0YS5wb3NPdXQueCAtIHBvc0RhdGEucG9zSW4ueDtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS55ID0gcG9zRGF0YS5wb3NPdXQueSAtIHBvc0RhdGEucG9zSW4ueTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3Mgd2lkdGgsIGhlaWdodCwgYW5kIG1hcmdpbnNcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZVRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi53aWR0aCAgICAgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi5oZWlnaHQgICAgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJ8fFwiIFByZXZlbnRzIHdpZHRoL2hlaWdodCBjaGFuZ2UgZnJvbSBpbmNsdWRpbmcgMCB3aWR0aC9oZWlnaHQgaWYgaGlkaW5nIG9yIHNob3dpbmdcblxuICAgICAgICAgICAgICAgICAgICB3aWR0aENoYW5nZSA9IChwb3NEYXRhLnN0YXJ0UG9zRGF0YS53aWR0aCB8fCBwb3NEYXRhLmZpbmFsUG9zRGF0YS53aWR0aCkgLSBwb3NEYXRhLmludGVyUG9zRGF0YS53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLm1hcmdpblJpZ2h0ID0gcG9zRGF0YS5zdGFydFBvc0RhdGEubWFyZ2luUmlnaHQgLSB3aWR0aENoYW5nZTtcblxuICAgICAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2UgPSAocG9zRGF0YS5zdGFydFBvc0RhdGEuaGVpZ2h0IHx8IHBvc0RhdGEuZmluYWxQb3NEYXRhLmhlaWdodCkgLSBwb3NEYXRhLmludGVyUG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi5tYXJnaW5Cb3R0b20gPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5tYXJnaW5Cb3R0b20gLSBoZWlnaHRDaGFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQud2lkdGggICAgPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQuaGVpZ2h0ICAgPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGhDaGFuZ2UgPSAocG9zRGF0YS5maW5hbFBvc0RhdGEud2lkdGggfHwgcG9zRGF0YS5zdGFydFBvc0RhdGEud2lkdGgpIC0gcG9zRGF0YS5pbnRlclBvc0RhdGEud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQubWFyZ2luUmlnaHQgPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS5tYXJnaW5SaWdodCAtIHdpZHRoQ2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZSA9IChwb3NEYXRhLmZpbmFsUG9zRGF0YS5oZWlnaHQgfHwgcG9zRGF0YS5zdGFydFBvc0RhdGEuaGVpZ2h0KSAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dC5tYXJnaW5Cb3R0b20gPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS5tYXJnaW5Cb3R0b20gLSBoZWlnaHRDaGFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEud2lkdGggICAgICAgICA9IHBvc0RhdGEucG9zT3V0LndpZHRoIC0gcG9zRGF0YS5wb3NJbi53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEuaGVpZ2h0ICAgICAgICA9IHBvc0RhdGEucG9zT3V0LmhlaWdodCAtIHBvc0RhdGEucG9zSW4uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS5tYXJnaW5SaWdodCAgID0gcG9zRGF0YS5wb3NPdXQubWFyZ2luUmlnaHQgLSBwb3NEYXRhLnBvc0luLm1hcmdpblJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS5tYXJnaW5Cb3R0b20gID0gcG9zRGF0YS5wb3NPdXQubWFyZ2luQm90dG9tIC0gcG9zRGF0YS5wb3NJbi5tYXJnaW5Cb3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0cmFuc2Zvcm1zXG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBlZmZlY3ROYW1lID0gZWZmZWN0TmFtZXNbal07IGorKykge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3QgPSBzZWxmLmVmZmVjdHNJbltlZmZlY3ROYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIShlZmZlY3QgaW5zdGFuY2VvZiBtaXhpdHVwLlRyYW5zZm9ybURhdGEpIHx8ICFlZmZlY3QudmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW5bZWZmZWN0TmFtZV0udmFsdWUgICAgID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS52YWx1ZSAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGFbZWZmZWN0TmFtZV0udmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXRbZWZmZWN0TmFtZV0udmFsdWUgLSBwb3NEYXRhLnBvc0luW2VmZmVjdE5hbWVdLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW5bZWZmZWN0TmFtZV0udW5pdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS51bml0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0RhdGEudHdlZW5EYXRhW2VmZmVjdE5hbWVdLnVuaXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3NEYXRhICAgICAgICAgICAgID0gb3BlcmF0aW9uLnRvSGlkZVBvc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbiAgICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0ICAgICAgPSBuZXcgbWl4aXR1cC5TdHlsZURhdGEoKTtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YSAgID0gbmV3IG1peGl0dXAuU3R5bGVEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHggYW5kIHlcblxuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ueCAgICAgPSB0YXJnZXQuaXNTaG93biA/IHBvc0RhdGEuc3RhcnRQb3NEYXRhLnggLSBwb3NEYXRhLmludGVyUG9zRGF0YS54IDogMDtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLnkgICAgID0gdGFyZ2V0LmlzU2hvd24gPyBwb3NEYXRhLnN0YXJ0UG9zRGF0YS55IC0gcG9zRGF0YS5pbnRlclBvc0RhdGEueSA6IDA7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQueCAgICA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5udWRnZSA/IDAgOiBwb3NEYXRhLnBvc0luLng7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQueSAgICA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5udWRnZSA/IDAgOiBwb3NEYXRhLnBvc0luLnk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEueCA9IHBvc0RhdGEucG9zT3V0LnggLSBwb3NEYXRhLnBvc0luLng7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEueSA9IHBvc0RhdGEucG9zT3V0LnkgLSBwb3NEYXRhLnBvc0luLnk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHdpZHRoLCBoZWlnaHQsIGFuZCBtYXJnaW5zXG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ud2lkdGggICAgICAgICA9IHBvc0RhdGEuc3RhcnRQb3NEYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLmhlaWdodCAgICAgICAgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGhDaGFuZ2UgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS53aWR0aCAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ubWFyZ2luUmlnaHQgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5tYXJnaW5SaWdodCAtIHdpZHRoQ2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZSA9IHBvc0RhdGEuc3RhcnRQb3NEYXRhLmhlaWdodCAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLm1hcmdpbkJvdHRvbSA9IHBvc0RhdGEuc3RhcnRQb3NEYXRhLm1hcmdpbkJvdHRvbSAtIGhlaWdodENoYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIG9wYWNpdHlcblxuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ub3BhY2l0eSAgICAgICA9IDE7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQub3BhY2l0eSAgICAgID0gc2VsZi5lZmZlY3RzT3V0Lm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEub3BhY2l0eSAgID0gcG9zRGF0YS5wb3NPdXQub3BhY2l0eSAtIHBvc0RhdGEucG9zSW4ub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdHJhbnNmb3Jtc1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgZWZmZWN0TmFtZSA9IGVmZmVjdE5hbWVzW2pdOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0ID0gc2VsZi5lZmZlY3RzT3V0W2VmZmVjdE5hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGVmZmVjdCBpbnN0YW5jZW9mIG1peGl0dXAuVHJhbnNmb3JtRGF0YSkgfHwgIWVmZmVjdC52YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbltlZmZlY3ROYW1lXS52YWx1ZSAgICAgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS52YWx1ZSAgICA9IGVmZmVjdC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YVtlZmZlY3ROYW1lXS52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS52YWx1ZSAtIHBvc0RhdGEucG9zSW5bZWZmZWN0TmFtZV0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbltlZmZlY3ROYW1lXS51bml0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0W2VmZmVjdE5hbWVdLnVuaXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGFbZWZmZWN0TmFtZV0udW5pdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3QudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyR2V0VHdlZW5EYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIG1vdmVUYXJnZXRzOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgbW92ZURhdGEgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NEYXRhICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NoYW5nZSAgICA9ICcnLFxuICAgICAgICAgICAgICAgIHdpbGxUcmFuc2l0aW9uICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0YWdnZXJJbmRleCAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGNoZWNrUHJvZ3Jlc3MgICA9IHNlbGYuY2hlY2tQcm9ncmVzcy5iaW5kKHNlbGYpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVNb3ZlVGFyZ2V0cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgYW4gZXh0cmEgbG9vcCBpbiBhZGRpdGlvbiB0byB0aGUgY2FsY3NcbiAgICAgICAgICAgIC8vIGRvbmUgaW4gZ2V0T3BlcmF0aW9uLCBjb3VsZCBzb21lIG9mIHRoaXMgYmUgZG9uZSB0aGVyZT9cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVEYXRhICAgID0gbmV3IG1peGl0dXAuSU1vdmVEYXRhKCk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YSAgICAgPSBvcGVyYXRpb24uc2hvd1Bvc0RhdGFbaV07XG5cbiAgICAgICAgICAgICAgICBzdGF0dXNDaGFuZ2UgPSB0YXJnZXQuaXNTaG93biA/ICdub25lJyA6ICdzaG93JztcblxuICAgICAgICAgICAgICAgIHdpbGxUcmFuc2l0aW9uID0gc2VsZi53aWxsVHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24uaGFzRWZmZWN0LFxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLFxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAod2lsbFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBub24tdHJhbnNpdGlvbmluZyB0YXJnZXRzIGZyb20gaW5jcmVtZW50aW5nIHRoZSBzdGFnZ2VySW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBzdGFnZ2VySW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgbW92ZURhdGEucG9zSW4gICAgICAgICAgPSBwb3NEYXRhLnBvc0luO1xuICAgICAgICAgICAgICAgIG1vdmVEYXRhLnBvc091dCAgICAgICAgID0gcG9zRGF0YS5wb3NPdXQ7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhdHVzQ2hhbmdlICAgPSBzdGF0dXNDaGFuZ2U7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4ICAgPSBzdGFnZ2VySW5kZXg7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEub3BlcmF0aW9uICAgICAgPSBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuY2FsbGJhY2sgICAgICAgPSB3aWxsVHJhbnNpdGlvbiA/IGNoZWNrUHJvZ3Jlc3MgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm1vdmUobW92ZURhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3NEYXRhICA9IG9wZXJhdGlvbi50b0hpZGVQb3NEYXRhW2ldO1xuICAgICAgICAgICAgICAgIG1vdmVEYXRhID0gbmV3IG1peGl0dXAuSU1vdmVEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICBzdGF0dXNDaGFuZ2UgPSAnaGlkZSc7XG5cbiAgICAgICAgICAgICAgICB3aWxsVHJhbnNpdGlvbiA9IHNlbGYud2lsbFRyYW5zaXRpb24oc3RhdHVzQ2hhbmdlLCBwb3NEYXRhLnBvc0luLCBwb3NEYXRhLnBvc091dCk7XG5cbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5wb3NJbiAgICAgICAgICA9IHBvc0RhdGEucG9zSW47XG4gICAgICAgICAgICAgICAgbW92ZURhdGEucG9zT3V0ICAgICAgICAgPSBwb3NEYXRhLnBvc091dDtcbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgICA9IHN0YXR1c0NoYW5nZTtcbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5zdGFnZ2VySW5kZXggICA9IGk7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEub3BlcmF0aW9uICAgICAgPSBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuY2FsbGJhY2sgICAgICAgPSB3aWxsVHJhbnNpdGlvbiA/IGNoZWNrUHJvZ3Jlc3MgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm1vdmUobW92ZURhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGVbbWl4aXR1cC5mZWF0dXJlcy50cmFuc2l0aW9uUHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0ICcgKyBzZWxmLmNvbmZpZy5hbmltYXRpb24uZHVyYXRpb24gKyAnbXMgZWFzZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCAnICsgc2VsZi5jb25maWcuYW5pbWF0aW9uLmR1cmF0aW9uICsgJ21zIGVhc2UgJztcblxuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0SGVpZ2h0ICE9PSBvcGVyYXRpb24ubmV3SGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVkgIT09IG9wZXJhdGlvbi5zdGFydEhlaWdodCAtIG9wZXJhdGlvbi5uZXdIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUuaGVpZ2h0ID0gb3BlcmF0aW9uLm5ld0hlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRXaWR0aCAhPT0gb3BlcmF0aW9uLm5ld1dpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVggIT09IG9wZXJhdGlvbi5zdGFydFdpZHRoIC0gb3BlcmF0aW9uLm5ld1dpZHRoXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLndpZHRoID0gb3BlcmF0aW9uLm5ld1dpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHNlbGYuZG9tLmNvbnRhaW5lciwgc2VsZi5jb25maWcubGF5b3V0LkNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgaC5hZGRDbGFzcyhzZWxmLmRvbS5jb250YWluZXIsIG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlck1vdmVUYXJnZXRzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBoYXNFZmZlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBFRkZFQ1RBQkxFUyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3NjYWxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvdGF0ZVgnLCAncm90YXRlWScsICdyb3RhdGVaJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZWZmZWN0TmFtZSAgPSAnJyxcbiAgICAgICAgICAgICAgICBlZmZlY3QgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmVmZmVjdHNJbi5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3Jlc3VsdEhhc0VmZmVjdCcsIHRydWUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGVmZmVjdE5hbWUgPSBFRkZFQ1RBQkxFU1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0ICA9IHNlbGYuZWZmZWN0c0luW2VmZmVjdE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgPSAodHlwZW9mIGVmZmVjdCAmJiBlZmZlY3QudmFsdWUgIT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC52YWx1ZSA6IGVmZmVjdDtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3Jlc3VsdEhhc0VmZmVjdCcsIHJlc3VsdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHRhcmdldCBlbGVtZW50IHdpbGwgdHJhbnNpdGlvbiBpblxuICAgICAgICAgKiBzb21lIGZhc2lvbiBhbmQgdGhlcmVmb3JlIHJlcXVpcmVzIGJpbmRpbmcgb2ZcbiAgICAgICAgICogdHJhbnNpdGlvbkVuZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIHN0YXR1c0NoYW5nZVxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICAgICAgaGFzRWZmZWN0XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHlsZURhdGF9ICAgICBwb3NJblxuICAgICAgICAgKiBAcGFyYW0gICB7U3R5bGVEYXRhfSAgICAgcG9zT3V0XG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICB3aWxsVHJhbnNpdGlvbjogZnVuY3Rpb24oc3RhdHVzQ2hhbmdlLCBoYXNFZmZlY3QsIHBvc0luLCBwb3NPdXQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXN1bHQgID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghaC5pc1Zpc2libGUoc2VsZi5kb20uY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaXMgbm90IHZpc2libGUsIHRoZSB0cmFuc2l0aW9uRW5kXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgd2lsbCBub3Qgb2NjdXIgYW5kIE1peEl0VXAgd2lsbCBoYW5nXG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgKHN0YXR1c0NoYW5nZSAhPT0gJ25vbmUnICYmIGhhc0VmZmVjdCkgfHxcbiAgICAgICAgICAgICAgICBwb3NJbi54ICE9PSBwb3NPdXQueCB8fFxuICAgICAgICAgICAgICAgIHBvc0luLnkgIT09IHBvc091dC55XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBvcGFjaXR5IGFuZC9vciB0cmFuc2xhdGUgd2lsbCBjaGFuZ2VcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdpZHRoLCBoZWlnaHQgb3IgbWFyZ2lucyB3aWxsIGNoYW5nZVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKFxuICAgICAgICAgICAgICAgICAgICBwb3NJbi53aWR0aCAhPT0gcG9zT3V0LndpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc0luLmhlaWdodCAhPT0gcG9zT3V0LmhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICBwb3NJbi5tYXJnaW5SaWdodCAhPT0gcG9zT3V0Lm1hcmdpblJpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc0luLm1hcmdpblRvcCAhPT0gcG9zT3V0Lm1hcmdpblRvcFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygncmVzdWx0V2lsbFRyYW5zaXRpb24nLCByZXN1bHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBjaGVja1Byb2dyZXNzOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi50YXJnZXRzRG9uZSsrO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi50YXJnZXRzQm91bmQgPT09IHNlbGYudGFyZ2V0c0RvbmUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFuVXAob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNsZWFuVXA6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VCZWZvcmUgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VBZnRlciAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIG5leHRJblF1ZXVlICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQ2xlYW5VcCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYudGFyZ2V0c01vdmVkICAgICAgICAgID1cbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHNJbW1vdmFibGUgID1cbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHNCb3VuZCAgICAgID1cbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHNEb25lICAgICAgID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5jbGVhblVwKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY2xlYW5VcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi53aWxsU29ydCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJpbnRTb3J0KGZhbHNlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBwYXJlbnQgY29udGFpbmVyXG5cbiAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnRyYW5zaXRpb25Qcm9wXSAgICAgICAgICAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLmhlaWdodCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPVxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS53aWR0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID1cbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUub3ZlcmZsb3cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlW21peGl0dXAuZmVhdHVyZXMucGVyc3BlY3RpdmVQcm9wXSAgICAgICAgPVxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnBlcnNwZWN0aXZlT3JpZ2luUHJvcF0gID0gJyc7XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbENoYW5nZUxheW91dCkge1xuICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGguYWRkQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24ubmV3Q29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi50b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBzZWxmLnRhcmdldHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnRvUmVtb3ZlLmluZGV4T2YodGFyZ2V0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdoaXRlc3BhY2VCZWZvcmUgPSB0YXJnZXQuZG9tLmVsLnByZXZpb3VzU2libGluZykgJiYgd2hpdGVzcGFjZUJlZm9yZS5ub2RlTmFtZSA9PT0gJyN0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aGl0ZXNwYWNlQWZ0ZXIgPSB0YXJnZXQuZG9tLmVsLm5leHRTaWJsaW5nKSAmJiB3aGl0ZXNwYWNlQWZ0ZXIubm9kZU5hbWUgPT09ICcjdGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlV2hpdGVzcGFjZSh3aGl0ZXNwYWNlQmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24ud2lsbFNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOQjogU29ydGluZyB3aWxsIHJlbW92ZSB0YXJnZXRzIGFzIGEgYmktcHJvZHVjdCBvZiBgcHJpbnRTb3J0KClgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQucmVtb3ZlQ2hpbGQodGFyZ2V0LmRvbS5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRhcmdldHMgaGF2ZSBiZWVuIHJlbW92ZWQsIHRoZSBvcmlnaW5hbCBvcmRlciBtdXN0IGJlIHVwZGF0ZWRcblxuICAgICAgICAgICAgICAgIHNlbGYub3JpZ09yZGVyID0gc2VsZi50YXJnZXRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLndpbGxTb3J0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzID0gb3BlcmF0aW9uLm5ld09yZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gb3BlcmF0aW9uLm5ld1N0YXRlO1xuICAgICAgICAgICAgc2VsZi5sYXN0T3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBzZWxmLmRvbS50YXJnZXRzID0gc2VsZi5zdGF0ZS50YXJnZXRzO1xuXG4gICAgICAgICAgICAvLyBtaXhFbmRcblxuICAgICAgICAgICAgbWl4aXR1cC5ldmVudHMuZmlyZSgnbWl4RW5kJywgc2VsZi5kb20uY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHNlbGYuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHNlbGZcbiAgICAgICAgICAgIH0sIHNlbGYuZG9tLmRvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhFbmQuY2FsbChzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuc3RhdGUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLmhhc0ZhaWxlZCkge1xuICAgICAgICAgICAgICAgIC8vIG1peEZhaWxcblxuICAgICAgICAgICAgICAgIG1peGl0dXAuZXZlbnRzLmZpcmUoJ21peEZhaWwnLCBzZWxmLmRvbS5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHNlbGYuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWxmXG4gICAgICAgICAgICAgICAgfSwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhGYWlsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmNhbGxiYWNrcy5vbk1peEZhaWwuY2FsbChzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuc3RhdGUsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGguYWRkQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBoLmdldENsYXNzbmFtZShzZWxmLmNvbmZpZy5jbGFzc05hbWVzLCAnY29udGFpbmVyJywgc2VsZi5jb25maWcuY2xhc3NOYW1lcy5tb2RpZmllckZhaWxlZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2VyLWRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb25cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnVzZXJDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNlbGYudXNlckNhbGxiYWNrLmNhbGwoc2VsZi5kb20uY29udGFpbmVyLCBzZWxmLnN0YXRlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnVzZXJEZWZlcnJlZC5yZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51c2VyRGVmZXJyZWQucmVzb2x2ZShzZWxmLnN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi51c2VyQ2FsbGJhY2sgID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYudXNlckRlZmVycmVkICA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmxhc3RDbGlja2VkICAgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5pc1RvZ2dsaW5nICAgID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmlzQnVzeSAgICAgICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHNlbGYucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlUmVhZFF1ZXVlQ2xlYW5VcCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBuZXh0SW5RdWV1ZSA9IHNlbGYucXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBub24tcHVibGljIEFQSSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBxdWV1ZVxuXG4gICAgICAgICAgICAgICAgc2VsZi51c2VyRGVmZXJyZWQgID0gbmV4dEluUXVldWUuZGVmZXJyZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5pc1RvZ2dsaW5nICAgID0gbmV4dEluUXVldWUuaXNUb2dnbGluZztcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RDbGlja2VkICAgPSBuZXh0SW5RdWV1ZS50cmlnZ2VyRWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5RdWV1ZS5pbnN0cnVjdGlvbi5jb21tYW5kIGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tdWx0aW1peC5hcHBseShzZWxmLCBuZXh0SW5RdWV1ZS5hcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGFzZXQuYXBwbHkoc2VsZiwgbmV4dEluUXVldWUuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckNsZWFuVXAnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlTXVsdGltaXhBcmdzOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gbmV3IG1peGl0dXAuVXNlckluc3RydWN0aW9uKCksXG4gICAgICAgICAgICAgICAgYXJnICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZCA9IG5ldyBtaXhpdHVwLkNvbW1hbmRNdWx0aW1peCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBoLmV4dGVuZChpbnN0cnVjdGlvbi5jb21tYW5kLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxiYWNrID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29lcmNlIGFyYml0cmFyeSBjb21tYW5kIGFyZ3VtZW50cyBpbnRvIHR5cGVkIGNvbW1hbmQgb2JqZWN0c1xuXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5pbnNlcnQgJiYgIShpbnN0cnVjdGlvbi5jb21tYW5kLmluc2VydCBpbnN0YW5jZW9mIG1peGl0dXAuQ29tbWFuZEluc2VydCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmluc2VydCA9IHNlbGYucGFyc2VJbnNlcnRBcmdzKFtpbnN0cnVjdGlvbi5jb21tYW5kLmluc2VydF0pLmNvbW1hbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLnJlbW92ZSAmJiAhKGluc3RydWN0aW9uLmNvbW1hbmQucmVtb3ZlIGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kUmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQucmVtb3ZlID0gc2VsZi5wYXJzZVJlbW92ZUFyZ3MoW2luc3RydWN0aW9uLmNvbW1hbmQucmVtb3ZlXSkuY29tbWFuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmNvbW1hbmQuZmlsdGVyICYmICEoaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXIgaW5zdGFuY2VvZiBtaXhpdHVwLkNvbW1hbmRGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXIgPSBzZWxmLnBhcnNlRmlsdGVyQXJncyhbaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXJdKS5jb21tYW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5zb3J0ICYmICEoaW5zdHJ1Y3Rpb24uY29tbWFuZC5zb3J0IGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kU29ydCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLnNvcnQgPSBzZWxmLnBhcnNlU29ydEFyZ3MoW2luc3RydWN0aW9uLmNvbW1hbmQuc29ydF0pLmNvbW1hbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLmNoYW5nZUxheW91dCAmJiAhKGluc3RydWN0aW9uLmNvbW1hbmQuY2hhbmdlTGF5b3V0IGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kQ2hhbmdlTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY2hhbmdlTGF5b3V0ID0gc2VsZi5wYXJzZUNoYW5nZUxheW91dEFyZ3MoW2luc3RydWN0aW9uLmNvbW1hbmQuY2hhbmdlTGF5b3V0XSkuY29tbWFuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdpbnN0cnVjdGlvblBhcnNlTXVsdGltaXhBcmdzJywgaW5zdHJ1Y3Rpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlRmlsdGVyQXJnczogZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IG5ldyBtaXhpdHVwLlVzZXJJbnN0cnVjdGlvbigpLFxuICAgICAgICAgICAgICAgIGFyZyAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5hbmltYXRlID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVuYWJsZTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQgPSBuZXcgbWl4aXR1cC5Db21tYW5kRmlsdGVyKCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gYXJnc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvclxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuc2VsZWN0b3IgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBoLmlzRWxlbWVudChhcmcsIHNlbGYuZG9tLmRvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IFthcmddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZy5sZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIGVsZW1lbnRzIGluIGFycmF5LCBOb2RlTGlzdCBvciBqUXVlcnkgY29sbGVjdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IGguYXJyYXlGcm9tTGlzdChhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGNvbW1hbmRcblxuICAgICAgICAgICAgICAgICAgICBoLmV4dGVuZChpbnN0cnVjdGlvbi5jb21tYW5kLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxiYWNrID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmNvbW1hbmQuc2VsZWN0b3IgJiYgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JGaWx0ZXJJbnZhbGlkQXJndW1lbnRzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ2luc3RydWN0aW9uUGFyc2VGaWx0ZXJBcmdzJywgaW5zdHJ1Y3Rpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlU29ydEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgc29ydFN0cmluZyAgPSAnJyxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5hbmltYXRlID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVuYWJsZTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQgPSBuZXcgbWl4aXR1cC5Db21tYW5kU29ydCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBzdHJpbmdcblxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydFN0cmluZyA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBlbGVtZW50IHJlZmVyZW5jZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24gPSBoLmFycmF5RnJvbUxpc3QoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxiYWNrID0gYXJnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3J0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZCA9IHNlbGYucGFyc2VTb3J0U3RyaW5nKHNvcnRTdHJpbmcsIGluc3RydWN0aW9uLmNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ2luc3RydWN0aW9uUGFyc2VTb3J0QXJncycsIGluc3RydWN0aW9uLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBoLmZyZWV6ZShpbnN0cnVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheTwqPn0gIGFyZ3NcbiAgICAgICAgICogQHJldHVybiAge21peGl0dXAuVXNlckluc3RydWN0aW9ufVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZUluc2VydEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZEluc2VydCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmluZGV4ID0gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgWydiZWZvcmUnLCAnYWZ0ZXInXS5pbmRleE9mKGFyZykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnYmVmb3JlJy8nYWZ0ZXInXG5cbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5wb3NpdGlvbiA9IGFyZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmt1cFxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBoLmFycmF5RnJvbUxpc3QoaC5jcmVhdGVFbGVtZW50KGFyZykuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBoLmlzRWxlbWVudChhcmcsIHNlbGYuZG9tLmRvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgICFpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24ubGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24gPSBbYXJnXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKGluc3RydWN0aW9uLmNvbW1hbmQuc2libGluZyA9IGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIGVsZW1lbnRzIGluIGFycmF5IG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgIWluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbi5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICAgICAgKGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IGFyZykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5zaWJsaW5nID0gYXJnWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnLmNoaWxkTm9kZXMgJiYgYXJnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGZyYWdtZW50XG5cbiAgICAgICAgICAgICAgICAgICAgIWluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbi5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uID0gaC5hcnJheUZyb21MaXN0KGFyZy5jaGlsZE5vZGVzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLnNpYmxpbmcgPSBhcmcuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICAgICAgaC5leHRlbmQoaW5zdHJ1Y3Rpb24uY29tbWFuZCwgYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5hbmltYXRlID0gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLmluZGV4ICYmIGluc3RydWN0aW9uLmNvbW1hbmQuc2libGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9ySW5zZXJ0SW52YWxpZEFyZ3VtZW50cygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24ubGVuZ3RoICYmIHNlbGYuY29uZmlnLmRlYnVnLnNob3dXYXJuaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdJbnNlcnROb0VsZW1lbnRzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ2luc3RydWN0aW9uUGFyc2VJbnNlcnRBcmdzJywgaW5zdHJ1Y3Rpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlUmVtb3ZlQXJnczogZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IG5ldyBtaXhpdHVwLlVzZXJJbnN0cnVjdGlvbigpLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZFJlbW92ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudGFyZ2V0c1thcmddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC50YXJnZXRzWzBdID0gc2VsZi50YXJnZXRzW2FyZ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uID0gaC5hcnJheUZyb21MaXN0KHNlbGYuZG9tLnBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKGFyZykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaC5pc0VsZW1lbnQoYXJnLCBzZWxmLmRvbS5kb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24gPSBbYXJnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNvbW1hbmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguZXh0ZW5kKGluc3RydWN0aW9uLmNvbW1hbmQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IHNlbGYudGFyZ2V0c1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQuZG9tLmVsKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluc3RydWN0aW9uLmNvbW1hbmQudGFyZ2V0cy5sZW5ndGggJiYgc2VsZi5jb25maWcuZGVidWcuc2hvd1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1peGl0dXAubWVzc2FnZXMud2FybmluZ1JlbW92ZU5vRWxlbWVudHMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlRGF0YXNldEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZERhdGFzZXQoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgdHlwZW9mIGFyZy5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5kYXRhc2V0ID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbGF5b3V0IGNvbW1hbmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguZXh0ZW5kKGluc3RydWN0aW9uLmNvbW1hbmQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoLmZyZWV6ZShpbnN0cnVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheTwqPn0gIGFyZ3NcbiAgICAgICAgICogQHJldHVybiAge21peGl0dXAuVXNlckluc3RydWN0aW9ufVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZUNoYW5nZUxheW91dEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZENoYW5nZUxheW91dCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb250YWluZXJDbGFzc05hbWUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGxheW91dCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGguZXh0ZW5kKGluc3RydWN0aW9uLmNvbW1hbmQsIGFyZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoLmZyZWV6ZShpbnN0cnVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge21peGl0dXAuUXVldWVJdGVtfSAgICAgICAgIHF1ZXVlSXRlbVxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKi9cblxuICAgICAgICBxdWV1ZU1peDogZnVuY3Rpb24ocXVldWVJdGVtKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yICA9ICcnO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVRdWV1ZU1peCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGRlZmVycmVkID0gaC5kZWZlcihtaXhpdHVwLmxpYnJhcmllcyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbmltYXRpb24ucXVldWUgJiYgc2VsZi5xdWV1ZS5sZW5ndGggPCBzZWxmLmNvbmZpZy5hbmltYXRpb24ucXVldWVMaW1pdCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5kZWZlcnJlZCA9IGRlZmVycmVkO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5xdWV1ZS5wdXNoKHF1ZXVlSXRlbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwIGNvbnRyb2xzIGluIHN5bmMgd2l0aCB1c2VyIGludGVyYWN0aW9ucy4gTWl4ZXIgd2lsbCBjYXRjaCB1cCBhcyBpdCBkcmFpbnMgdGhlIHF1ZXVlLlxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNvbnRyb2xzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc1RvZ2dsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkVG9nZ2xlQXJyYXkocXVldWVJdGVtLmluc3RydWN0aW9uLmNvbW1hbmQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RvciA9IHNlbGYuZ2V0VG9nZ2xlU2VsZWN0b3IoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb250cm9scyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiB0b2dnbGVTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb250cm9scyhxdWV1ZUl0ZW0uaW5zdHJ1Y3Rpb24uY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zy5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1peGl0dXAubWVzc2FnZXMud2FybmluZ011bHRpbWl4SW5zdGFuY2VRdWV1ZUZ1bGwoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzZWxmLnN0YXRlKTtcblxuICAgICAgICAgICAgICAgIG1peGl0dXAuZXZlbnRzLmZpcmUoJ21peEJ1c3knLCBzZWxmLmRvbS5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHNlbGYuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWxmXG4gICAgICAgICAgICAgICAgfSwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhCdXN5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmNhbGxiYWNrcy5vbk1peEJ1c3kuY2FsbChzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuc3RhdGUsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3Byb21pc2VRdWV1ZU1peCcsIGRlZmVycmVkLnByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXkuPG9iamVjdD59ICAgIG5ld0RhdGFzZXRcbiAgICAgICAgICogQHJldHVybiAge09wZXJhdGlvbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0RGF0YU9wZXJhdGlvbjogZnVuY3Rpb24obmV3RGF0YXNldCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5PcGVyYXRpb24oKSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGFzZXQgICAgICAgID0gW107XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ29wZXJhdGlvblVubWFwcGVkR2V0RGF0YU9wZXJhdGlvbicsIG9wZXJhdGlvbiwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuZG9tLnRhcmdldHMubGVuZ3RoICYmICEoc3RhcnREYXRhc2V0ID0gKHNlbGYuc3RhdGUuYWN0aXZlRGF0YXNldCB8fCBbXSkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRGF0YXNldE5vdFNldCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3BlcmF0aW9uLmlkICAgICAgICAgICAgPSBoLnJhbmRvbUhleCgpO1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0U3RhdGUgICAgPSBzZWxmLnN0YXRlO1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0RGF0YXNldCAgPSBzdGFydERhdGFzZXQ7XG4gICAgICAgICAgICBvcGVyYXRpb24ubmV3RGF0YXNldCAgICA9IG5ld0RhdGFzZXQuc2xpY2UoKTtcblxuICAgICAgICAgICAgc2VsZi5kaWZmRGF0YXNldHMob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0T3JkZXIgPSBzZWxmLnRhcmdldHM7XG4gICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIgPSBvcGVyYXRpb24uc2hvdztcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdldFN0YXJ0TWl4RGF0YShvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0SW50ZXIob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5kb2NTdGF0ZSA9IGguZ2V0RG9jdW1lbnRTdGF0ZShzZWxmLmRvbS5kb2N1bWVudCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmdldEludGVyTWl4RGF0YShvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RmluYWwob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLmdldEZpbmFsTWl4RGF0YShvcGVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJzZUVmZmVjdHMoKTtcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5oYXNFZmZlY3QgPSBzZWxmLmhhc0VmZmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRUd2VlbkRhdGEob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50YXJnZXRzID0gb3BlcmF0aW9uLnNob3cuc2xpY2UoKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLm5ld1N0YXRlID0gc2VsZi5idWlsZFN0YXRlKG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgIC8vIE5COiBUYXJnZXRzIHRvIGJlIHJlbW92ZWQgbXVzdCBiZSBpbmNsdWRlZCBpbiBgc2VsZi50YXJnZXRzYCBmb3IgcmVtb3ZhbCBkdXJpbmcgY2xlYW4gdXAsXG4gICAgICAgICAgICAvLyBidXQgYXJlIGFkZGVkIGFmdGVyIHN0YXRlIGlzIGJ1aWx0IHNvIHRoYXQgc3RhdGUgaXMgYWNjdXJhdGVcblxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoc2VsZi50YXJnZXRzLCBvcGVyYXRpb24udG9SZW1vdmUpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdvcGVyYXRpb25NYXBwZWRHZXREYXRhT3BlcmF0aW9uJywgb3BlcmF0aW9uLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGRpZmZEYXRhc2V0czogZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGVyc2lzdGFudFN0YXJ0SWRzICA9IFtdLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RhbnROZXdJZHMgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFRhcmdldHMgICAgID0gW10sXG4gICAgICAgICAgICAgICAgZGF0YSAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZWwgICAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZnJhZyAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgbmV4dEVsICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgdWlkcyAgICAgICAgICAgICAgICA9IHt9LFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZURpZmZEYXRhc2V0cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGRhdGEgPSBvcGVyYXRpb24ubmV3RGF0YXNldFtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaWQgPSBkYXRhW3NlbGYuY29uZmlnLmRhdGEudWlkS2V5XSkgPT09ICd1bmRlZmluZWQnIHx8IGlkLnRvU3RyaW5nKCkubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JEYXRhc2V0SW52YWxpZFVpZEtleSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aWRLZXk6IHNlbGYuY29uZmlnLmRhdGEudWlkS2V5XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXVpZHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWl4aXR1cC5tZXNzYWdlcy5lcnJvckRhdGFzZXREdXBsaWNhdGVVaWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCh0YXJnZXQgPSBzZWxmLmNhY2hlW2lkXSkgaW5zdGFuY2VvZiBtaXhpdHVwLlRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluIGNhY2hlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmRhdGEuZGlydHlDaGVjayAmJiAhaC5kZWVwRXF1YWxzKGRhdGEsIHRhcmdldC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIGRldGVjdGVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGFyZ2V0LnJlbmRlcihkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHRhcmdldC5kb20uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzSW5Eb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnVuYmluZEV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmlzU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZG9tLmVsID0gZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzSW5Eb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbCA9IHRhcmdldC5kb20uZWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IHRhcmdldFxuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG5ldyBtaXhpdHVwLlRhcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbml0KG51bGwsIHNlbGYsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXNJbkRvbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdG8gRE9NXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIGZyYWdcblxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHNlbGYuZG9tLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoc2VsZi5kb20uZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHRhcmdldC5kb20uZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvU2hvdy5wdXNoKHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluIERPTVxuXG4gICAgICAgICAgICAgICAgICAgIG5leHRFbCA9IHRhcmdldC5kb20uZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RhbnROZXdJZHMucHVzaChpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIGFuZCBpbnNlcnQgcHJldmlvdXNseSBvcGVuZWQgZnJhZ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5sYXN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChzZWxmLmRvbS5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnNlcnREYXRhc2V0RnJhZyhmcmFnLCB0YXJnZXQuZG9tLmVsLCBpbnNlcnRlZFRhcmdldHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93LnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmNsb3NlZCBmcmFnIHJlbWFpbmluZ1xuXG4gICAgICAgICAgICAgICAgbmV4dEVsID0gbmV4dEVsIHx8IHNlbGYuY29uZmlnLmxheW91dC5zaWJsaW5nQWZ0ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoc2VsZi5kb20uZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5pbnNlcnREYXRhc2V0RnJhZyhmcmFnLCBuZXh0RWwsIGluc2VydGVkVGFyZ2V0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGRhdGEgPSBvcGVyYXRpb24uc3RhcnREYXRhc2V0W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZCA9IGRhdGFbc2VsZi5jb25maWcuZGF0YS51aWRLZXldO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2VsZi5jYWNoZVtpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNob3cuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2aW91c2x5IHNob3duIGJ1dCBub3cgYWJzZW50XG5cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLmhpZGUucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udG9IaWRlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvUmVtb3ZlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0YW50U3RhcnRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWguaXNFcXVhbEFycmF5KHBlcnNpc3RhbnRTdGFydElkcywgcGVyc2lzdGFudE5ld0lkcykpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ud2lsbFNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckRpZmZEYXRhc2V0cycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjEuNVxuICAgICAgICAgKiBAcGFyYW0gICB7RG9jdW1lbnRGcmFnbWVudH0gICAgICAgICAgZnJhZ1xuICAgICAgICAgKiBAcGFyYW0gICB7KEhUTUxFbGVtZW50fG51bGwpfSAgICAgICAgbmV4dEVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheS48bWl4aXR1cC5UYXJnZXQ+fSAgICB0YXJnZXRzXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBpbnNlcnREYXRhc2V0RnJhZzogZnVuY3Rpb24oZnJhZywgbmV4dEVsLCB0YXJnZXRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0QXQgPSBuZXh0RWwgPyBoLmFycmF5RnJvbUxpc3Qoc2VsZi5kb20ucGFyZW50LmNoaWxkcmVuKS5pbmRleE9mKG5leHRFbCkgOiBzZWxmLnRhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuaW5zZXJ0QmVmb3JlKGZyYWcsIG5leHRFbCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0cy5zcGxpY2UoaW5zZXJ0QXQsIDAsIHRhcmdldHMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICBpbnNlcnRBdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuQ29tbWFuZFNvcnR9IHNvcnRDb21tYW5kQVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5Db21tYW5kU29ydH0gc29ydENvbW1hbmRCXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICB3aWxsU29ydDogZnVuY3Rpb24oc29ydENvbW1hbmRBLCBzb3J0Q29tbWFuZEIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXN1bHQgID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5iZWhhdmlvci5saXZlU29ydCB8fFxuICAgICAgICAgICAgICAgIHNvcnRDb21tYW5kQS5vcmRlciAgICAgICA9PT0gJ3JhbmRvbScgfHxcbiAgICAgICAgICAgICAgICBzb3J0Q29tbWFuZEEuYXR0cmlidXRlICAgIT09IHNvcnRDb21tYW5kQi5hdHRyaWJ1dGUgfHxcbiAgICAgICAgICAgICAgICBzb3J0Q29tbWFuZEEub3JkZXIgICAgICAgIT09IHNvcnRDb21tYW5kQi5vcmRlciB8fFxuICAgICAgICAgICAgICAgIHNvcnRDb21tYW5kQS5jb2xsZWN0aW9uICAhPT0gc29ydENvbW1hbmRCLmNvbGxlY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAoc29ydENvbW1hbmRBLm5leHQgPT09IG51bGwgJiYgc29ydENvbW1hbmRCLm5leHQpIHx8XG4gICAgICAgICAgICAgICAgKHNvcnRDb21tYW5kQS5uZXh0ICYmIHNvcnRDb21tYW5kQi5uZXh0ID09PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydENvbW1hbmRBLm5leHQgJiYgc29ydENvbW1hbmRCLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLndpbGxTb3J0KHNvcnRDb21tYW5kQS5uZXh0LCBzb3J0Q29tbWFuZEIubmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygncmVzdWx0V2lsbFNvcnQnLCByZXN1bHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2hvcnRoYW5kIG1ldGhvZCBmb3IgYC5maWx0ZXIoJ2FsbCcpYC4gU2hvd3MgYWxsIHRhcmdldHMgaW4gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLnNob3coKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTaG93aW5nIGFsbCB0YXJnZXRzPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5zaG93KClcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSBzdGF0ZS50b3RhbFRhcmdldHMpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqL1xuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXIoJ2FsbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNob3J0aGFuZCBtZXRob2QgZm9yIGAuZmlsdGVyKCdub25lJylgLiBIaWRlcyBhbGwgdGFyZ2V0cyBpbiB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuaGlkZSgpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEhpZGluZyBhbGwgdGFyZ2V0czwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuaGlkZSgpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRvdGFsU2hvdyA9PT0gMCk7IC8vIHRydWVcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbEhpZGUgPT09IHN0YXRlLnRvdGFsVGFyZ2V0cyk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbHRlcignbm9uZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGEgTWl4SXRVcCBvcGVyYXRpb24gaXNcbiAgICAgICAgICogY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuaXNNaXhpbmcoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBDaGVja2luZyB0aGUgc3RhdHVzIG9mIGEgbWl4ZXI8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3JhbmRvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgICAgY29uc29sZS5sb2cobWl4ZXIuaXNNaXhpbmcoKSkgLy8gZmFsc2VcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmlzTWl4aW5nKCkpIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHJldHVybiAge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlzTWl4aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaXNCdXN5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWx0ZXJzIGFsbCB0YXJnZXRzIGluIHRoZSBjb250YWluZXIgYnkgYSBwcm92aWRlZCBzZWxlY3RvciBzdHJpbmcsIG9yIHRoZSB2YWx1ZXMgYCdhbGwnYFxuICAgICAgICAgKiBvciBgJ25vbmUnYC4gT25seSB0YXJnZXRzIG1hdGNoaW5nIHRoZSBzZWxlY3RvciB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuZmlsdGVyKHNlbGVjdG9yIFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBGaWx0ZXJpbmcgdGFyZ2V0cyBieSBhIGNsYXNzIHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5maWx0ZXIoJy5jYXRlZ29yeS1hJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuY2F0ZWdvcnktYScpLmxlbmd0aCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IEZpbHRlcmluZyB0YXJnZXRzIGJ5IGFuIGF0dHJpYnV0ZSBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuZmlsdGVyKCdbZGF0YS1jYXRlZ29yeX49XCJhXCJdJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXRlZ29yeX49XCJhXCJdJykubGVuZ3RoKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogRmlsdGVyaW5nIHRhcmdldHMgYnkgYSBjb21wb3VuZCBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gU2hvdyBvbmx5IHRob3NlIHRhcmdldHMgd2l0aCB0aGUgY2xhc3NlcyAnY2F0ZWdvcnktYScgQU5EICdjYXRlZ29yeS1iJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5maWx0ZXIoJy5jYXRlZ29yeS1hLmNhdGVnb3J5LWMnKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgPT09IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeS1hLmNhdGVnb3J5LWMnKS5sZW5ndGgpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSA0OiBGaWx0ZXJpbmcgdmlhIGFuIGVsZW1lbnQgY29sbGVjdGlvbjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGNvbGxlY3Rpb24gPSBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcubWl4JykpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhjb2xsZWN0aW9uLmxlbmd0aCk7IC8vIDM0XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEZpbHRlciB0aGUgY29sbGVjdGlvbiBtYW51YWxseSB1c2luZyBBcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBmaWx0ZXJlZCA9IGNvbGxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgKiAgICByZXR1cm4gcGFyc2VJbnQodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1wcmljZScpKSA+IDEwO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coZmlsdGVyZWQubGVuZ3RoKTsgLy8gMjJcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUGFzcyB0aGUgZmlsdGVyZWQgY29sbGVjdGlvbiB0byBNaXhJdFVwXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmZpbHRlcihmaWx0ZXJlZClcbiAgICAgICAgICogICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZUZpbHRlci5jb2xsZWN0aW9uLmxlbmd0aCA9PT0gMjIpOyAvLyB0cnVlXG4gICAgICAgICAqICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoc3RyaW5nfEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD4pfSBzZWxlY3RvclxuICAgICAgICAgKiAgICAgIEFueSB2YWxpZCBDU1Mgc2VsZWN0b3IgKGkuZS4gYCcuY2F0ZWdvcnktYSdgKSwgb3IgdGhlIHZhbHVlcyBgJ2FsbCdgIG9yIGAnbm9uZSdgLiBUaGUgZmlsdGVyIG1ldGhvZCBhbHNvIGFjY2VwdHMgYSByZWZlcmVuY2UgdG8gc2luZ2xlIHRhcmdldCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbiBvZiB0YXJnZXQgZWxlbWVudHMgdG8gc2hvdy5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtib29sZWFufSAgIFthbmltYXRlPXRydWVdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciB0aGUgb3BlcmF0aW9uIHNob3VsZCBhbmltYXRlLCBvciBvY2N1ciBzeW5jcm9ub3VzbHkgd2l0aCBubyBhbmltYXRpb24uIGB0cnVlYCBieSBkZWZhdWx0LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Z1bmN0aW9ufSAgW2NhbGxiYWNrPW51bGxdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqICAgICAgQSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAgICAgICAgICovXG5cbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBzZWxmLnBhcnNlRmlsdGVyQXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tdWx0aW1peCh7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBpbnN0cnVjdGlvbi5jb21tYW5kXG4gICAgICAgICAgICB9LCBpbnN0cnVjdGlvbi5hbmltYXRlLCBpbnN0cnVjdGlvbi5jYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYWRkaXRpb25hbCBzZWxlY3RvciB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSBmaWx0ZXIgc2VsZWN0b3IsIGNvbmNhdGVuYXRpbmdcbiAgICAgICAgICogYXMgcGVyIHRoZSBsb2dpYyBkZWZpbmVkIGluIGBjb250cm9scy50b2dnbGVMb2dpY2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC50b2dnbGVPbihzZWxlY3RvciBbLCBhbmltYXRlXSBbLCBjYWxsYmFja10pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFRvZ2dsaW5nIG9uIGEgZmlsdGVyIHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLmFjdGl2ZUZpbHRlci5zZWxlY3Rvcik7IC8vICcuY2F0ZWdvcnktYSdcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIudG9nZ2xlT24oJy5jYXRlZ29yeS1iJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yKTsgLy8gJy5jYXRlZ29yeS1hLCAuY2F0ZWdvcnktYidcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIHNlbGVjdG9yXG4gICAgICAgICAqICAgICAgQW55IHZhbGlkIENTUyBzZWxlY3RvciAoaS5lLiBgJy5jYXRlZ29yeS1hJ2ApXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRvZ2dsZU9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uICAgICA9IHNlbGYucGFyc2VGaWx0ZXJBcmdzKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgICAgICAgID0gaW5zdHJ1Y3Rpb24uY29tbWFuZC5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RvciAgPSAnJztcblxuICAgICAgICAgICAgc2VsZi5pc1RvZ2dsaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNlbGYudG9nZ2xlQXJyYXkuaW5kZXhPZihzZWxlY3RvcikgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2dnbGVBcnJheS5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3IgPSBzZWxmLmdldFRvZ2dsZVNlbGVjdG9yKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLm11bHRpbWl4KHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRvZ2dsZVNlbGVjdG9yXG4gICAgICAgICAgICB9LCBpbnN0cnVjdGlvbi5hbmltYXRlLCBpbnN0cnVjdGlvbi5jYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBzZWxlY3RvciBmcm9tIHRoZSBhY3RpdmUgZmlsdGVyIHNlbGVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAudG9nZ2xlT2ZmKHNlbGVjdG9yIFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogVG9nZ2xpbmcgb2ZmIGEgZmlsdGVyIHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLmFjdGl2ZUZpbHRlci5zZWxlY3Rvcik7IC8vICcuY2F0ZWdvcnktYSwgLmNhdGVnb3J5LWInXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnRvZ2dsZU9mZignLmNhdGVnb3J5LWInKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVGaWx0ZXIuc2VsZWN0b3IpOyAvLyAnLmNhdGVnb3J5LWEnXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBzZWxlY3RvclxuICAgICAgICAgKiAgICAgIEFueSB2YWxpZCBDU1Mgc2VsZWN0b3IgKGkuZS4gYCcuY2F0ZWdvcnktYSdgKVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICB0b2dnbGVPZmY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gICAgID0gc2VsZi5wYXJzZUZpbHRlckFyZ3MoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciAgICAgICAgPSBpbnN0cnVjdGlvbi5jb21tYW5kLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggICA9IHNlbGYudG9nZ2xlQXJyYXkuaW5kZXhPZihzZWxlY3RvciksXG4gICAgICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3IgID0gJyc7XG5cbiAgICAgICAgICAgIHNlbGYuaXNUb2dnbGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RvckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5LnNwbGljZShzZWxlY3RvckluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3IgPSBzZWxmLmdldFRvZ2dsZVNlbGVjdG9yKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLm11bHRpbWl4KHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRvZ2dsZVNlbGVjdG9yXG4gICAgICAgICAgICB9LCBpbnN0cnVjdGlvbi5hbmltYXRlLCBpbnN0cnVjdGlvbi5jYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnRzIGFsbCB0YXJnZXRzIGluIHRoZSBjb250YWluZXIgYWNjb3JkaW5nIHRvIGEgcHJvdmlkZWQgc29ydCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5zb3J0KHNvcnRTdHJpbmcgWywgYW5pbWF0ZV0gWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFNvcnRpbmcgYnkgdGhlIGRlZmF1bHQgRE9NIG9yZGVyPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBSZXZlcnNlIHRoZSBkZWZhdWx0IG9yZGVyIG9mIHRoZSB0YXJnZXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ2RlZmF1bHQ6ZGVzYycpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQuYXR0cmlidXRlID09PSAnZGVmYXVsdCcpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5vcmRlciA9PT0gJ2Rlc2MnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogU29ydGluZyBieSBhIGN1c3RvbSBkYXRhLWF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gU29ydCB0aGUgdGFyZ2V0cyBieSB0aGUgdmFsdWUgb2YgYSBgZGF0YS1wdWJsaXNoZWQtZGF0ZWAgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3B1Ymxpc2hlZC1kYXRlOmFzYycpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQuYXR0cmlidXRlID09PSAncHVibGlzaGVkLWRhdGUnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdhc2MnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogU29ydGluZyBieSBtdWx0aXBsZSBhdHRyaWJ1dGVzPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBTb3J0IHRoZSB0YXJnZXRzIGJ5IHRoZSB2YWx1ZSBvZiBhIGBkYXRhLXB1Ymxpc2hlZC1kYXRlYCBhdHRyaWJ1dGUsIHRoZW4gYnkgYGRhdGEtdGl0bGVgXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3B1Ymxpc2hlZC1kYXRlOmRlc2MgZGF0YS10aXRsZTphc2MnKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVTb3J0LmF0dHJpYnV0ZSA9PT0gJ3B1Ymxpc2hlZC1kYXRlJyk7IC8vIHRydWVcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVTb3J0Lm9yZGVyID09PSAnZGVzYycpOyAvLyB0cnVlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5uZXh0LmF0dHJpYnV0ZSA9PT0gJ3RpdGxlJyk7IC8vIHRydWVcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVTb3J0Lm5leHQub3JkZXIgPT09ICdhc2MnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogU29ydGluZyBieSByYW5kb208L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3JhbmRvbScpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdyYW5kb20nKSAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSA1OiBTb3J0aW5nIHZpYSBhbiBlbGVtZW50IGNvbGxlY3Rpb248L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBjb2xsZWN0aW9uID0gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLm1peCcpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gU3dhcCB0aGUgcG9zaXRpb24gb2YgdHdvIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uOlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdGVtcCA9IGNvbGxlY3Rpb25bMV07XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbGxlY3Rpb25bMV0gPSBjb2xsZWN0aW9uWzBdO1xuICAgICAgICAgKiBjb2xsZWN0aW9uWzBdID0gdGVtcDtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUGFzcyB0aGUgc29ydGVkIGNvbGxlY3Rpb24gdG8gTWl4SXRVcFxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5zb3J0KGNvbGxlY3Rpb24pXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRhcmdldHNbMF0gPT09IGNvbGxlY3Rpb25bMF0pOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KHN0cmluZ3xBcnJheS48SFRNTEVsZW1lbnQ+KX0gICAgc29ydFN0cmluZ1xuICAgICAgICAgKiAgICAgIEEgdmFsaWQgc29ydCBzdHJpbmcgKGUuZy4gYCdkZWZhdWx0J2AsIGAncHVibGlzaGVkLWRhdGU6YXNjJ2AsIG9yIGAncmFuZG9tJ2ApLiBUaGUgc29ydCBtZXRob2QgYWxzbyBhY2NlcHRzIGFuIGFycmF5IG9mIGFsbCB0YXJnZXQgZWxlbWVudHMgaW4gYSB1c2VyLWRlZmluZWQgb3JkZXIuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYucGFyc2VTb3J0QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tdWx0aW1peCh7XG4gICAgICAgICAgICAgICAgc29ydDogaW5zdHJ1Y3Rpb24uY29tbWFuZFxuICAgICAgICAgICAgfSwgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSwgaW5zdHJ1Y3Rpb24uY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBsYXlvdXQgb2YgdGhlIGNvbnRhaW5lciBieSBhZGRpbmcsIHJlbW92aW5nIG9yIHVwZGF0aW5nIGFcbiAgICAgICAgICogbGF5b3V0LXNwZWNpZmljIGNsYXNzIG5hbWUuIElmIGBhbmltYXRpb24uYW5pbWF0ZVJlc2l6ZXRhcmdldHNgIGlzXG4gICAgICAgICAqIGVuYWJsZWQsIE1peEl0VXAgd2lsbCBhdHRlbXB0IHRvIGdyYWNlZnVsbHkgYW5pbWF0ZSB0aGUgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICogYW5kIHBvc2l0aW9uIG9mIHRhcmdldHMgYmV0d2VlbiBsYXlvdXQgc3RhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuY2hhbmdlTGF5b3V0KGNvbnRhaW5lckNsYXNzTmFtZSBbLCBhbmltYXRlXSBbLCBjYWxsYmFja10pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQWRkaW5nIGEgbmV3IGNsYXNzIG5hbWUgdG8gdGhlIGNvbnRhaW5lcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuY2hhbmdlTGF5b3V0KCdjb250YWluZXItbGlzdCcpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3MgPT09ICdjb250YWluZXItbGlzdCcpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogUmVtb3ZpbmcgYSBwcmV2aW91c2x5IGFkZGVkIGNsYXNzIG5hbWUgZnJvbSB0aGUgY29udGFpbmVyPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5jaGFuZ2VMYXlvdXQoJycpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3MgPT09ICcnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIGNvbnRhaW5lckNsYXNzTmFtZVxuICAgICAgICAgKiAgICAgIEEgbGF5b3V0LXNwZWNpZmljIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNoYW5nZUxheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gc2VsZi5wYXJzZUNoYW5nZUxheW91dEFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubXVsdGltaXgoe1xuICAgICAgICAgICAgICAgIGNoYW5nZUxheW91dDogaW5zdHJ1Y3Rpb24uY29tbWFuZFxuICAgICAgICAgICAgfSwgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSwgaW5zdHJ1Y3Rpb24uY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb250ZW50cyBhbmQgb3JkZXIgb2YgdGhlIGNvbnRhaW5lciB0byByZWZsZWN0IHRoZSBwcm92aWRlZCBkYXRhc2V0LFxuICAgICAgICAgKiBpZiB0aGUgZGF0YXNldCBBUEkgaXMgaW4gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGF0YXNldCBBUEkgaXMgZGVzaWduZWQgZm9yIHVzZSBpbiBBUEktZHJpdmVuIEphdmFTY3JpcHQgYXBwbGljYXRpb25zLCBhbmRcbiAgICAgICAgICogY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBET00tYmFzZWQgbWV0aG9kcyBzdWNoIGFzIGAuZmlsdGVyKClgLCBgLnNvcnQoKWAsXG4gICAgICAgICAqIGAuaW5zZXJ0KClgLCBldGMuIFdoZW4gdXNlZCwgaW5zZXJ0aW9uLCByZW1vdmFsLCBzb3J0aW5nIGFuZCBwYWdpbmF0aW9uIGNhbiBiZVxuICAgICAgICAgKiBhY2hpZXZlZCBwdXJlbHkgdmlhIGNoYW5nZXMgdG8geW91ciBkYXRhIG1vZGVsLCB3aXRob3V0IHRoZSB1Z2x5bmVzcyBvZiBoYXZpbmdcbiAgICAgICAgICogdG8gaW50ZXJhY3Qgd2l0aCBvciBxdWVyeSB0aGUgRE9NIGRpcmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuZGF0YXNldChkYXRhc2V0IFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBSZW5kZXJpbmcgYSBkYXRhc2V0PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbXlEYXRhc2V0ID0gW1xuICAgICAgICAgKiAgICAge2lkOiAxLCAuLi59LFxuICAgICAgICAgKiAgICAge2lkOiAyLCAuLi59LFxuICAgICAgICAgKiAgICAge2lkOiAzLCAuLi59XG4gICAgICAgICAqIF07XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmRhdGFzZXQobXlEYXRhc2V0KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgPT09IDMpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBTb3J0aW5nIGEgZGF0YXNldDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRlIGEgbmV3IGRhdGFzZXQgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RGF0YXNldCA9IG15RGF0YXNldC5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuZGF0YXNldChuZXdEYXRhc2V0KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVEYXRhc2V0WzBdID09PSBteURhdGFzZXRbMl0pOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAzOiBSZW1vdmluZyBhbiBpdGVtIGZyb20gdGhlIGRhdGFzZXQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG15RGF0YXNldC5sZW5ndGgpOyAvLyAzXG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGxhc3QgaXRlbSByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RGF0YXNldCA9IG15RGF0YXNldC5zbGljZSgpLnBvcCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5kYXRhc2V0KG5ld0RhdGFzZXQpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRvdGFsU2hvdyA9PT0gMik7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtBcnJheS48b2JqZWN0Pn0gICAgZGF0YXNldFxuICAgICAgICAgKiAgICAgIEFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb25lIHJlcHJlc2VudGluZyB0aGUgdW5kZXJseWluZyBkYXRhIG1vZGVsIG9mIGEgdGFyZ2V0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgICAgICAgICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gICAgICAgICAgW2NhbGxiYWNrPW51bGxdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqICAgICAgQSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAgICAgICAgICovXG5cbiAgICAgICAgZGF0YXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gc2VsZi5wYXJzZURhdGFzZXRBcmdzKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbSAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhbmltYXRlICAgICA9IGZhbHNlO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVEYXRhc2V0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKCFzZWxmLmlzQnVzeSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jYWxsYmFjaykgc2VsZi51c2VyQ2FsbGJhY2sgPSBpbnN0cnVjdGlvbi5jYWxsYmFjaztcblxuICAgICAgICAgICAgICAgIGFuaW1hdGUgPSAoaW5zdHJ1Y3Rpb24uYW5pbWF0ZSBeIHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGUpID8gaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA6IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmdldERhdGFPcGVyYXRpb24oaW5zdHJ1Y3Rpb24uY29tbWFuZC5kYXRhc2V0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdvTWl4KGFuaW1hdGUsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbSA9IG5ldyBtaXhpdHVwLlF1ZXVlSXRlbSgpO1xuXG4gICAgICAgICAgICAgICAgcXVldWVJdGVtLmFyZ3MgICAgICAgICAgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgcXVldWVJdGVtLmluc3RydWN0aW9uICAgPSBpbnN0cnVjdGlvbjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnF1ZXVlTWl4KHF1ZXVlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIHNpbXVsdGFuZW91cyBgZmlsdGVyYCwgYHNvcnRgLCBgaW5zZXJ0YCwgYHJlbW92ZWAgYW5kIGBjaGFuZ2VMYXlvdXRgXG4gICAgICAgICAqIG9wZXJhdGlvbnMgYXMgcmVxdWVzdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAubXVsdGltaXgobXVsdGltaXhDb21tYW5kIFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBQZXJmb3JtaW5nIHNpbXVsdGFuZW91cyBmaWx0ZXJpbmcgYW5kIHNvcnRpbmc8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLm11bHRpbWl4KHtcbiAgICAgICAgICogICAgIGZpbHRlcjogJy5jYXRlZ29yeS1iJyxcbiAgICAgICAgICogICAgIHNvcnQ6ICdwdWJsaXNoZWQtZGF0ZTpkZXNjJ1xuICAgICAgICAgKiB9KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVGaWx0ZXIuc2VsZWN0b3IgPT09ICcuY2F0ZWdvcnktYicpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5hdHRyaWJ1dGUgPT09ICdwdWJsaXNoZWQtZGF0ZScpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBQZXJmb3JtaW5nIHNpbXVsdGFuZW91cyBzb3J0aW5nLCBpbnNlcnRpb24sIGFuZCByZW1vdmFsPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDZcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gTkI6IFdoZW4gaW5zZXJ0aW5nIHZpYSBgbXVsdGltaXgoKWAsIGFuIG9iamVjdCBzaG91bGQgYmUgcHJvdmlkZWQgYXMgdGhlIHZhbHVlXG4gICAgICAgICAqIC8vIGZvciB0aGUgYGluc2VydGAgcG9ydGlvbiBvZiB0aGUgY29tbWFuZCwgYWxsb3dpbmcgZm9yIGEgY29sbGVjdGlvbiBvZiBlbGVtZW50c1xuICAgICAgICAgKiAvLyBhbmQgYW4gaW5zZXJ0aW9uIGluZGV4IHRvIGJlIHNwZWNpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIubXVsdGltaXgoe1xuICAgICAgICAgKiAgICAgc29ydDogJ3B1Ymxpc2hlZC1kYXRlOmRlc2MnLCAvLyBTb3J0IHRoZSBjb250YWluZXIsIGluY2x1ZGluZyBhbnkgbmV3IGVsZW1lbnRzXG4gICAgICAgICAqICAgICBpbnNlcnQ6IHtcbiAgICAgICAgICogICAgICAgICBjb2xsZWN0aW9uOiBbbmV3RWxlbWVudFJlZmVyZW5jZUEsIG5ld0VsZW1lbnRSZWZlcmVuY2VCXSwgLy8gQWRkIDIgbmV3IGVsZW1lbnRzIGF0IGluZGV4IDVcbiAgICAgICAgICogICAgICAgICBpbmRleDogNVxuICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICogICAgIHJlbW92ZTogZXhpc3RpbmdFbGVtZW50UmVmZXJlbmNlIC8vIFJlbW92ZSAxIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICogfSlcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5hdHRyaWJ1dGUgPT09ICdwdWJsaXNoZWQtZGF0ZScpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSA3KTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgbXVsdGltaXhDb21tYW5kXG4gICAgICAgICAqICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgdGhpbmdzIHRvIGRvXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIG11bHRpbWl4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGFuaW1hdGUgICAgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVJdGVtICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gc2VsZi5wYXJzZU11bHRpbWl4QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVNdWx0aW1peCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5pc0J1c3kpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmdldE9wZXJhdGlvbihpbnN0cnVjdGlvbi5jb21tYW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jb250cm9scy5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbnRyb2xzIGZvciBBUEkgY2FsbHNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXIgJiYgIXNlbGYuaXNUb2dnbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2UgYXJlIG5vdCB0b2dnbGluZywgcmVzZXQgdGhlIHRvZ2dsZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gbmV3IGZpbHRlciBvdmVycmlkZXMgZXhpc3RpbmcgdG9nZ2xlc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkVG9nZ2xlQXJyYXkob3BlcmF0aW9uLmNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucXVldWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb250cm9scyhvcGVyYXRpb24uY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY2FsbGJhY2spIHNlbGYudXNlckNhbGxiYWNrID0gaW5zdHJ1Y3Rpb24uY2FsbGJhY2s7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgYWxsb3cgdGhlIGluc3RydWN0aW9uIHRvIG92ZXJyaWRlIHRoZSBpbnN0YW5jZSBzZXR0aW5nXG5cbiAgICAgICAgICAgICAgICBhbmltYXRlID0gKGluc3RydWN0aW9uLmFuaW1hdGUgXiBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlKSA/XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsRmlsdGVycygnb3BlcmF0aW9uTXVsdGltaXgnLCBvcGVyYXRpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nb01peChhbmltYXRlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0gPSBuZXcgbWl4aXR1cC5RdWV1ZUl0ZW0oKTtcblxuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5hcmdzICAgICAgICAgICA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0uaW5zdHJ1Y3Rpb24gICAgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0udHJpZ2dlckVsZW1lbnQgPSBzZWxmLmxhc3RDbGlja2VkO1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5pc1RvZ2dsaW5nICAgICA9IHNlbGYuaXNUb2dnbGluZztcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnF1ZXVlTWl4KHF1ZXVlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICAgICAgICAgIG11bHRpbWl4Q29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICAgICAgICAgIFtpc1ByZUZldGNoXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBvcGVyYXRpb24gaXMgYmVpbmcgcHJlLWZldGNoZWQgZm9yIGV4ZWN1dGlvbiBhdCBhIGxhdGVyIHRpbWUuXG4gICAgICAgICAqIEByZXR1cm4gIHtPcGVyYXRpb258bnVsbH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0T3BlcmF0aW9uOiBmdW5jdGlvbihtdWx0aW1peENvbW1hbmQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzb3J0Q29tbWFuZCAgICAgICAgID0gbXVsdGltaXhDb21tYW5kLnNvcnQsXG4gICAgICAgICAgICAgICAgZmlsdGVyQ29tbWFuZCAgICAgICA9IG11bHRpbWl4Q29tbWFuZC5maWx0ZXIsXG4gICAgICAgICAgICAgICAgY2hhbmdlTGF5b3V0Q29tbWFuZCA9IG11bHRpbWl4Q29tbWFuZC5jaGFuZ2VMYXlvdXQsXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ29tbWFuZCAgICAgICA9IG11bHRpbWl4Q29tbWFuZC5yZW1vdmUsXG4gICAgICAgICAgICAgICAgaW5zZXJ0Q29tbWFuZCAgICAgICA9IG11bHRpbWl4Q29tbWFuZC5pbnNlcnQsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgICAgICAgICA9IG5ldyBtaXhpdHVwLk9wZXJhdGlvbigpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdvcGVyYXRpb25Vbm1hcHBlZEdldE9wZXJhdGlvbicsIG9wZXJhdGlvbiwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLmlkICAgICAgICAgICAgICAgID0gaC5yYW5kb21IZXgoKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5jb21tYW5kICAgICAgICAgICA9IG11bHRpbWl4Q29tbWFuZDtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFN0YXRlICAgICAgICA9IHNlbGYuc3RhdGU7XG4gICAgICAgICAgICBvcGVyYXRpb24udHJpZ2dlckVsZW1lbnQgICAgPSBzZWxmLmxhc3RDbGlja2VkO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc0J1c3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZGVidWcuc2hvd1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdHZXRPcGVyYXRpb25JbnN0YW5jZUJ1c3koKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnNlcnRUYXJnZXRzKGluc2VydENvbW1hbmQsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvUmVtb3ZlID0gcmVtb3ZlQ29tbWFuZC50YXJnZXRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRTb3J0ID0gb3BlcmF0aW9uLm5ld1NvcnQgPSBvcGVyYXRpb24uc3RhcnRTdGF0ZS5hY3RpdmVTb3J0O1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0T3JkZXIgPSBvcGVyYXRpb24ubmV3T3JkZXIgPSBzZWxmLnRhcmdldHM7XG5cbiAgICAgICAgICAgIGlmIChzb3J0Q29tbWFuZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFNvcnQgPSBvcGVyYXRpb24uc3RhcnRTdGF0ZS5hY3RpdmVTb3J0O1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdTb3J0ICAgPSBzb3J0Q29tbWFuZDtcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi53aWxsU29ydCA9IHNlbGYud2lsbFNvcnQoc29ydENvbW1hbmQsIG9wZXJhdGlvbi5zdGFydFN0YXRlLmFjdGl2ZVNvcnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi53aWxsU29ydCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnRPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEZpbHRlciA9IG9wZXJhdGlvbi5zdGFydFN0YXRlLmFjdGl2ZUZpbHRlcjtcblxuICAgICAgICAgICAgaWYgKGZpbHRlckNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3RmlsdGVyID0gZmlsdGVyQ29tbWFuZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0ZpbHRlciA9IGguZXh0ZW5kKG5ldyBtaXhpdHVwLkNvbW1hbmRGaWx0ZXIoKSwgb3BlcmF0aW9uLnN0YXJ0RmlsdGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0ZpbHRlci5zZWxlY3RvciA9IHNlbGYuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5maWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0Q29udGFpbmVyQ2xhc3NOYW1lID0gb3BlcmF0aW9uLnN0YXJ0U3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3NOYW1lO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlTGF5b3V0Q29tbWFuZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUgPSBjaGFuZ2VMYXlvdXRDb21tYW5kLmNvbnRhaW5lckNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3Q29udGFpbmVyQ2xhc3NOYW1lICE9PSBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0NvbnRhaW5lckNsYXNzTmFtZSA9IG9wZXJhdGlvbi5zdGFydENvbnRhaW5lckNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgb3BlcmF0aW9uJ3MgcG9zaXRpb24gZGF0YVxuXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRTdGFydE1peERhdGEob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEludGVyKG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZG9jU3RhdGUgPSBoLmdldERvY3VtZW50U3RhdGUoc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRJbnRlck1peERhdGEob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEZpbmFsKG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgc2VsZi5nZXRGaW5hbE1peERhdGEob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIHNlbGYucGFyc2VFZmZlY3RzKCk7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uaGFzRWZmZWN0ID0gc2VsZi5oYXNFZmZlY3QoKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0VHdlZW5EYXRhKG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbFNvcnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHMgPSBvcGVyYXRpb24ubmV3T3JkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdTdGF0ZSA9IHNlbGYuYnVpbGRTdGF0ZShvcGVyYXRpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnb3BlcmF0aW9uTWFwcGVkR2V0T3BlcmF0aW9uJywgb3BlcmF0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIGEgcHJldmlvdXNseSBjcmVhdGVkIG9wZXJhdGlvbiBhdCBhIHNwZWNpZmljIHBvaW50IGluIGl0cyBwYXRoLCBhc1xuICAgICAgICAgKiBkZXRlcm1pbmVkIGJ5IGEgbXVsdGlwbGllciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC50d2VlbihvcGVyYXRpb24sIG11bHRpcGxpZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5PcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogICAgICBBbiBvcGVyYXRpb24gb2JqZWN0IGNyZWF0ZWQgdmlhIHRoZSBgZ2V0T3BlcmF0aW9uYCBtZXRob2RcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge0Zsb2F0fSAgICAgICAgICAgICAgICAgbXVsdGlwbGllclxuICAgICAgICAgKiAgICAgIEFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudGFnZSBjb21wbGV0ZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICB0d2VlbjogZnVuY3Rpb24ob3BlcmF0aW9uLCBtdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NEYXRhICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRvSGlkZUluZGV4ICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gTWF0aC5taW4obXVsdGlwbGllciwgMSk7XG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gTWF0aC5tYXgobXVsdGlwbGllciwgMCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi5zaG93W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3NEYXRhID0gb3BlcmF0aW9uLnNob3dQb3NEYXRhW2ldO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5VHdlZW4ocG9zRGF0YSwgbXVsdGlwbGllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi5oaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRvSGlkZUluZGV4ID0gb3BlcmF0aW9uLnRvSGlkZS5pbmRleE9mKHRhcmdldCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YSA9IG9wZXJhdGlvbi50b0hpZGVQb3NEYXRhW3RvSGlkZUluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5VHdlZW4ocG9zRGF0YSwgbXVsdGlwbGllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIG9uZSBvciBtb3JlIG5ldyB0YXJnZXQgZWxlbWVudHMgaW50byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkXG4gICAgICAgICAqIGluZGV4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBiZSBpbmRleGVkIGFzIHRhcmdldHMsIG5ldyBlbGVtZW50cyBtdXN0IG1hdGNoIHRoZSBgc2VsZWN0b3JzLnRhcmdldGBcbiAgICAgICAgICogc2VsZWN0b3IgKGAnLm1peCdgIGJ5IGRlZmF1bHQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuaW5zZXJ0KG5ld0VsZW1lbnRzIFssIGluZGV4XSBbLCBhbmltYXRlXSwgWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IEluc2VydGluZyBhIHNpbmdsZSBlbGVtZW50IHZpYSByZWZlcmVuY2U8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmdldFN0YXRlKCkudG90YWxTaG93KTsgLy8gMFxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBDcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgKiBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21peCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5pbnNlcnQobmV3RWxlbWVudClcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSAxKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogSW5zZXJ0aW5nIGEgc2luZ2xlIGVsZW1lbnQgdmlhIEhUTUwgc3RyaW5nPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDFcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRlIGEgbmV3IGVsZW1lbnQgdmlhIHJlZmVyZW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudEh0bWwgPSAnJmx0O2RpdiBjbGFzcz1cIm1peFwiJmd0OyZsdDsvZGl2Jmd0Oyc7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhbmQgaW5zZXJ0IHRoZSBuZXcgZWxlbWVudCBhdCBpbmRleCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmluc2VydChuZXdFbGVtZW50SHRtbCwgMSlcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSAyKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbMV0ub3V0ZXJIVE1MID09PSBuZXdFbGVtZW50SHRtbCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDM6IEluc2VydGluZyBtdWx0aXBsZSBlbGVtZW50cyB2aWEgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDJcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRlIGFuIGFycmF5IG9mIG5ldyBlbGVtZW50cyB0byBpbnNlcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50MSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogbmV3RWxlbWVudDEuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQyLmNsYXNzTGlzdC5hZGQoJ21peCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudHNDb2xsZWN0aW9uID0gW25ld0VsZW1lbnQxLCBuZXdFbGVtZW50Ml07XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEluc2VydCB0aGUgbmV3IGVsZW1lbnRzIHN0YXJ0aW5nIGF0IGluZGV4IDFcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuaW5zZXJ0KG5ld0VsZW1lbnRzQ29sbGVjdGlvbiwgMSlcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSA0KTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbMV0gPT09IG5ld0VsZW1lbnQxKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbMl0gPT09IG5ld0VsZW1lbnQyKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogSW5zZXJ0aW5nIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgZWxlbWVudHM8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmdldFN0YXRlKCkudG90YWxTaG93KTsgLy8gNFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgJG5ld0VsZW1lbnQgPSAkKCcmbHQ7ZGl2IGNsYXNzPVwibWl4XCImZ3Q7Jmx0Oy9kaXYmZ3Q7Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEluc2VydCB0aGUgbmV3IGVsZW1lbnRzIHN0YXJ0aW5nIGF0IGluZGV4IDNcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuaW5zZXJ0KCRuZXdFbGVtZW50LCAzKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgPT09IDUpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc2hvd1szXSA9PT0gJG5ld0VsZW1lbnRbMF0pOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD58c3RyaW5nKX0gICAgbmV3RWxlbWVudHNcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byBhIHNpbmdsZSBlbGVtZW50IHRvIGluc2VydCwgYW4gYXJyYXktbGlrZSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLCBvciBhbiBIVE1MIHN0cmluZyByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgIGluZGV4PTBcbiAgICAgICAgICogICAgICBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBuZXcgZWxlbWVudChzKS4gYDBgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGluc2VydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyA9IHNlbGYucGFyc2VJbnNlcnRBcmdzKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLm11bHRpbWl4KHtcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IGFyZ3MuY29tbWFuZFxuICAgICAgICAgICAgfSwgYXJncy5hbmltYXRlLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBuZXcgZWxlbWVudHMgYmVmb3JlIGEgcHJvdmlkZWQgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudHMsIHJlZmVyZW5jZUVsZW1lbnQgWywgYW5pbWF0ZV0gWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBJbnNlcnRpbmcgYSBuZXcgZWxlbWVudCBiZWZvcmUgYSByZWZlcmVuY2UgZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQW4gZXhpc3RpbmcgcmVmZXJlbmNlIGVsZW1lbnQgaXMgY2hvc2VuIGF0IGluZGV4IDJcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBtaXhlci5nZXRTdGF0ZSgpLnNob3dbMl07XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmluc2VydEJlZm9yZShuZXdFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAvLyBUaGUgbmV3IGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY29udGFpbmVyIGF0IGluZGV4IDIsIGJlZm9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5zaG93WzJdID09PSBuZXdFbGVtZW50KTsgLy8gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIC8vIFRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBub3cgYXQgaW5kZXggM1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbM10gPT09IHJlZmVyZW5jZUVsZW1lbnQpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD58c3RyaW5nKX0gICAgbmV3RWxlbWVudHNcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byBhIHNpbmdsZSBlbGVtZW50IHRvIGluc2VydCwgYW4gYXJyYXktbGlrZSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLCBvciBhbiBIVE1MIHN0cmluZyByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtIVE1MRWxlbWVudH0gICAgcmVmZXJlbmNlRWxlbWVudFxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lciB0byBpbnNlcnQgbmV3IGVsZW1lbnRzIGJlZm9yZS5cbiAgICAgICAgICpAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBzZWxmLnBhcnNlSW5zZXJ0QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnNlcnQoYXJncy5jb21tYW5kLmNvbGxlY3Rpb24sICdiZWZvcmUnLCBhcmdzLmNvbW1hbmQuc2libGluZywgYXJncy5hbmltYXRlLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBuZXcgZWxlbWVudHMgYWZ0ZXIgYSBwcm92aWRlZCByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLmluc2VydEFmdGVyKG5ld0VsZW1lbnRzLCByZWZlcmVuY2VFbGVtZW50IFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogSW5zZXJ0aW5nIGEgbmV3IGVsZW1lbnQgYWZ0ZXIgYSByZWZlcmVuY2UgZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQW4gZXhpc3RpbmcgcmVmZXJlbmNlIGVsZW1lbnQgaXMgY2hvc2VuIGF0IGluZGV4IDJcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBtaXhlci5nZXRTdGF0ZSgpLnNob3dbMl07XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnQpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIC8vIFRoZSBuZXcgZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBjb250YWluZXIgYXQgaW5kZXggMywgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc2hvd1szXSA9PT0gbmV3RWxlbWVudCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoSFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50PnxzdHJpbmcpfSAgICBuZXdFbGVtZW50c1xuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGEgc2luZ2xlIGVsZW1lbnQgdG8gaW5zZXJ0LCBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMsIG9yIGFuIEhUTUwgc3RyaW5nIHJlcHJlc2VudGluZyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge0hUTUxFbGVtZW50fSAgICByZWZlcmVuY2VFbGVtZW50XG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gYW4gZXhpc3RpbmcgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyIHRvIGluc2VydCBuZXcgZWxlbWVudHMgYWZ0ZXIuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gc2VsZi5wYXJzZUluc2VydEFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5zZXJ0KGFyZ3MuY29tbWFuZC5jb2xsZWN0aW9uLCAnYWZ0ZXInLCBhcmdzLmNvbW1hbmQuc2libGluZywgYXJncy5hbmltYXRlLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBuZXcgZWxlbWVudHMgaW50byB0aGUgY29udGFpbmVyIGJlZm9yZSBhbGwgZXhpc3RpbmcgdGFyZ2V0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLnByZXBlbmQobmV3RWxlbWVudHMgWyxhbmltYXRlXSBbLGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogUHJlcGVuZGluZyBhIG5ldyBlbGVtZW50PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBDcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgKiBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21peCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBJbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgY29udGFpbmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnByZXBlbmQobmV3RWxlbWVudClcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc2hvd1swXSA9PT0gbmV3RWxlbWVudCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoSFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50PnxzdHJpbmcpfSAgICBuZXdFbGVtZW50c1xuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGEgc2luZ2xlIGVsZW1lbnQgdG8gaW5zZXJ0LCBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMsIG9yIGFuIEhUTUwgc3RyaW5nIHJlcHJlc2VudGluZyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gc2VsZi5wYXJzZUluc2VydEFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5zZXJ0KDAsIGFyZ3MuY29tbWFuZC5jb2xsZWN0aW9uLCBhcmdzLmFuaW1hdGUsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIG9uZSBvciBtb3JlIG5ldyBlbGVtZW50cyBpbnRvIHRoZSBjb250YWluZXIgYWZ0ZXIgYWxsIGV4aXN0aW5nIHRhcmdldHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5hcHBlbmQobmV3RWxlbWVudHMgWyxhbmltYXRlXSBbLGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQXBwZW5kaW5nIGEgbmV3IGVsZW1lbnQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEluc2VydCB0aGUgZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXJcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuYXBwZW5kKG5ld0VsZW1lbnQpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbc3RhdGUuc2hvdy5sZW5ndGggLSAxXSA9PT0gbmV3RWxlbWVudCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoSFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50PnxzdHJpbmcpfSAgICBuZXdFbGVtZW50c1xuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGEgc2luZ2xlIGVsZW1lbnQgdG8gaW5zZXJ0LCBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMsIG9yIGFuIEhUTUwgc3RyaW5nIHJlcHJlc2VudGluZyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBzZWxmLnBhcnNlSW5zZXJ0QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnNlcnQoc2VsZi5zdGF0ZS50b3RhbFRhcmdldHMsIGFyZ3MuY29tbWFuZC5jb2xsZWN0aW9uLCBhcmdzLmFuaW1hdGUsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGV4aXN0aW5nIHRhcmdldCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5yZW1vdmUoZWxlbWVudHMgWywgYW5pbWF0ZV0gWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFJlbW92aW5nIGFuIGVsZW1lbnQgYnkgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgZWxlbWVudFRvUmVtb3ZlID0gY29udGFpbmVyRWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnJlbW92ZShlbGVtZW50VG9SZW1vdmUpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudGFyZ2V0cy5pbmRleE9mKGVsZW1lbnRUb1JlbW92ZSkgPT09IC0xKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IFJlbW92aW5nIGEgY29sbGVjdGlvbiBvZiBlbGVtZW50cyBieSByZWZlcmVuY2U8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBlbGVtZW50c1RvUmVtb3ZlID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLmNhdGVnb3J5LWEnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coZWxlbWVudHNUb1JlbW92ZS5sZW5ndGgpIC8vIDNcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIucmVtb3ZlKGVsZW1lbnRzVG9SZW1vdmUpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeS1hJykubGVuZ3RoKTsgLy8gMFxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDM6IFJlbW92aW5nIG9uZSBvciBtb3JlIGVsZW1lbnRzIGJ5IHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5yZW1vdmUoJy5jYXRlZ29yeS1hJylcbiAgICAgICAgICogICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coY29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLmNhdGVnb3J5LWEnKS5sZW5ndGgpOyAvLyAwXG4gICAgICAgICAqICAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogUmVtb3ZpbmcgYW4gZWxlbWVudCBieSBpbmRleDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cobWl4ZXIuZ2V0U3RhdGUudG90YWxTaG93KTsgLy8gNFxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgYXQgaW5kZXggM1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5yZW1vdmUoMylcbiAgICAgICAgICogICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cpOyAvLyAzXG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbM10pOyAvLyB1bmRlZmluZWRcbiAgICAgICAgICogICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD58c3RyaW5nfG51bWJlcil9ICAgIGVsZW1lbnRzXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gYSBzaW5nbGUgZWxlbWVudCB0byByZW1vdmUsIGFuIGFycmF5LWxpa2UgY29sbGVjdGlvbiBvZiBlbGVtZW50cywgYSBzZWxlY3RvciBzdHJpbmcsIG9yIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtib29sZWFufSAgIFthbmltYXRlPXRydWVdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciB0aGUgb3BlcmF0aW9uIHNob3VsZCBhbmltYXRlLCBvciBvY2N1ciBzeW5jcm9ub3VzbHkgd2l0aCBubyBhbmltYXRpb24uIGB0cnVlYCBieSBkZWZhdWx0LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Z1bmN0aW9ufSAgW2NhbGxiYWNrPW51bGxdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqICAgICAgQSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAgICAgICAgICovXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gc2VsZi5wYXJzZVJlbW92ZUFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubXVsdGltaXgoe1xuICAgICAgICAgICAgICAgIHJlbW92ZTogYXJncy5jb21tYW5kXG4gICAgICAgICAgICB9LCBhcmdzLmFuaW1hdGUsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIHRoZSB2YWx1ZSBvZiBhbnkgcHJvcGVydHkgb3Igc3ViLW9iamVjdCB3aXRoaW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICogbWl4aXR1cCBjb25maWd1cmF0aW9uLCBvciB0aGUgd2hvbGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5nZXRDb25maWcoW3N0cmluZ0tleV0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogcmV0cmlldmUgdGhlIGVudGlyZSBjb25maWd1cmF0aW9uIG9iamVjdDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGNvbmZpZyA9IG1peGVyLmdldENvbmZpZygpOyAvLyBDb25maWcgeyAuLi4gfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IHJldHJpZXZlIGEgbmFtZWQgc3ViLW9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9iamVjdDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGFuaW1hdGlvbiA9IG1peGVyLmdldENvbmZpZygnYW5pbWF0aW9uJyk7IC8vIENvbmZpZ0FuaW1hdGlvbiB7IC4uLiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogcmV0cmlldmUgYSB2YWx1ZSBvZiBjb25maWd1cmF0aW9uIG9iamVjdCB2aWEgYSBkb3Qtbm90YXRpb24gc3RyaW5nIGtleTwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGVmZmVjdHMgPSBtaXhlci5nZXRDb25maWcoJ2FuaW1hdGlvbi5lZmZlY3RzJyk7IC8vICdmYWRlIHNjYWxlJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIFtzdHJpbmdLZXldICAgIEEgXCJkb3Qtbm90YXRpb25cIiBzdHJpbmcga2V5XG4gICAgICAgICAqIEByZXR1cm4gICAgICB7Kn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q29uZmlnOiBmdW5jdGlvbihzdHJpbmdLZXkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFzdHJpbmdLZXkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGguZ2V0UHJvcGVydHkoc2VsZi5jb25maWcsIHN0cmluZ0tleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCd2YWx1ZUdldENvbmZpZycsIHZhbHVlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBtaXhlciwgYWZ0ZXIgaXQgaGFzIGJlZW4gaW5zdGFudGlhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgdGhlIENvbmZpZ3VyYXRpb24gT2JqZWN0IGRvY3VtZW50YXRpb24gZm9yIGEgZnVsbCBsaXN0IG9mIGF2aWxhYmxlXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLmNvbmZpZ3VyZShjb25maWcpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogVXBkYXRpbmcgYW5pbWF0aW9uIG9wdGlvbnM8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlZmZlY3RzOiAnZmFkZSB0cmFuc2xhdGVYKC0xMDAlKScsXG4gICAgICAgICAqICAgICAgICAgZHVyYXRpb246IDMwMFxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBSZW1vdmluZyBhIGNhbGxiYWNrIGFmdGVyIGl0IGhhcyBiZWVuIHNldDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyO1xuICAgICAgICAgKlxuICAgICAgICAgKiBmdW5jdGlvbiBoYW5kbGVNaXhFbmRPbmNlKCkge1xuICAgICAgICAgKiAgICAgLy8gRG8gc29tZXRoaW5nIC4uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBUaGVuIG51bGxpZnkgdGhlIGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBtaXhlci5jb25maWd1cmUoe1xuICAgICAgICAgKiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgICAgICBvbk1peEVuZDogbnVsbFxuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKiB9O1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBJbnN0YW50aWF0ZSBhIG1peGVyIHdpdGggYSBjYWxsYmFjayBkZWZpbmVkXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAqICAgICAgICAgb25NaXhFbmQ6IGhhbmRsZU1peEVuZE9uY2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgY29uZmlnXG4gICAgICAgICAqICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9mIG1vcmUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbmZpZ3VyZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZXh0ZW5kKHNlbGYuY29uZmlnLCBjb25maWcsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckNvbmZpZ3VyZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gICAgICAgICAqIG1peGVyLiBTZWUgdGhlIFN0YXRlIE9iamVjdCBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOQjogU3RhdGUgb2JqZWN0cyBhcmUgaW1tdXRhYmxlIGFuZCBzaG91bGQgdGhlcmVmb3JlIGJlIHJlZ2VuZXJhdGVkXG4gICAgICAgICAqIGFmdGVyIGFueSBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5nZXRTdGF0ZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBSZXRyaWV2aW5nIGEgc3RhdGUgb2JqZWN0PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgc3RhdGUgPSBtaXhlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgKyAndGFyZ2V0cyBhcmUgY3VycmVudGx5IHNob3duJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICAgICAge21peGl0dXAuU3RhdGV9IEFuIG9iamVjdCByZWZsZWN0aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtaXhlci5cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0YXRlICAgPSBudWxsO1xuXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBtaXhpdHVwLlN0YXRlKCk7XG5cbiAgICAgICAgICAgIGguZXh0ZW5kKHN0YXRlLCBzZWxmLnN0YXRlKTtcblxuICAgICAgICAgICAgaC5mcmVlemUoc3RhdGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnc3RhdGVHZXRTdGF0ZScsIHN0YXRlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZXMgdGhlIHJlLWluZGV4aW5nIGFsbCB0YXJnZXRzIHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgc29tZSBvdGhlciBwaWVjZSBvZiBjb2RlIGluIHlvdXIgYXBwbGljYXRpb25cbiAgICAgICAgICogaGFzIG1hbmlwdWxhdGVkIHRoZSBjb250ZW50cyBvZiB5b3VyIGNvbnRhaW5lciwgd2hpY2ggc2hvdWxkIGJlIGF2b2lkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSBuZWVkIHRvIGFkZCBvciByZW1vdmUgdGFyZ2V0IGVsZW1lbnRzIGZyb20gdGhlIGNvbnRhaW5lciwgdXNlXG4gICAgICAgICAqIHRoZSBidWlsdC1pbiBgLmluc2VydCgpYCBvciBgLnJlbW92ZSgpYCBtZXRob2RzLCBhbmQgTWl4SXRVcCB3aWxsIGtlZXBcbiAgICAgICAgICogaXRzZWxmIHVwIHRvIGRhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5mb3JjZVJlZnJlc2goKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBGb3JjZSByZWZyZXNoaW5nIHRoZSBtaXhlciBhZnRlciBleHRlcm5hbCBET00gbWFuaXB1bGF0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDNcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIGNvbnRhaW5lciB2aWEgc29tZSBleHRlcm5hbCBET00gbWFuaXB1bGF0aW9uIGNvZGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnRhaW5lckVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gVGhlIG1peGVyIGRvZXMgbm90IGtub3cgdGhhdCB0aGUgbnVtYmVyIG9mIHRhcmdldHMgaGFzIGNoYW5nZWQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmdldFN0YXRlKCkudG90YWxTaG93KTsgLy8gM1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5mb3JjZVJlZnJlc2goKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWZ0ZXIgZm9yY2VSZWZyZXNoLCB0aGUgbWl4ZXIgaXMgaW4gc3luYyBhZ2FpbjpcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cobWl4ZXIuZ2V0U3RhdGUoKS50b3RhbFNob3cpOyAvLyAyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAyLjEuMlxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBmb3JjZVJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLmluZGV4VGFyZ2V0cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZXMgdGhlIHJlLXJlbmRlcmluZyBvZiBhbGwgdGFyZ2V0cyB3aGVuIHVzaW5nIHRoZSBEYXRhc2V0IEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGFyZ2V0cyBhcmUgb25seSByZS1yZW5kZXJlZCB3aGVuIGBkYXRhLmRpcnR5Q2hlY2tgIGlzXG4gICAgICAgICAqIGVuYWJsZWQsIGFuZCBhbiBpdGVtJ3MgZGF0YSBoYXMgY2hhbmdlZCB3aGVuIGBkYXRhc2V0KClgIGlzIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBmb3JjZVJlbmRlcigpYCBtZXRob2QgYWxsb3dzIGZvciB0aGUgcmUtcmVuZGVyaW5nIG9mIGFsbCB0YXJnZXRzXG4gICAgICAgICAqIGluIHJlc3BvbnNlIHRvIHNvbWUgYXJiaXRyYXJ5IGV2ZW50LCBzdWNoIGFzIHRoZSBjaGFuZ2luZyBvZiB0aGUgdGFyZ2V0XG4gICAgICAgICAqIHJlbmRlciBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGFyZ2V0cyBhcmUgcmVuZGVyZWQgYWdhaW5zdCB0aGVpciBleGlzdGluZyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuZm9yY2VSZW5kZXIoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBGb3JjZSByZW5kZXIgdGFyZ2V0cyBhZnRlciBjaGFuZ2luZyB0aGUgdGFyZ2V0IHJlbmRlciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coY29udGFpbmVyLmlubmVySFRNTCk7IC8vIC4uLiAmbHQ7c3BhbiBjbGFzcz1cIm1peFwiJmd0O0ZvbyZsdDsvc3BhbiZndDsgLi4uXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAqICAgICByZW5kZXI6IHtcbiAgICAgICAgICogICAgICAgICB0YXJnZXQ6IChpdGVtKSA9PiBgJmx0O2EgaHJlZj1cIi8ke2l0ZW0uc2x1Z30vXCIgY2xhc3M9XCJtaXhcIiZndDske2l0ZW0udGl0bGV9Jmx0Oy9hJmd0O2BcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKGNvbnRhaW5lci5pbm5lckhUTUwpOyAvLyAuLi4gJmx0O2EgaHJlZj1cIi9mb28vXCIgY2xhc3M9XCJtaXhcIiZndDtGb28mbHQ7L2EmZ3Q7IC4uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgMy4yLjFcbiAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGVsICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGlkICAgICAgPSAnJztcblxuICAgICAgICAgICAgZm9yIChpZCBpbiBzZWxmLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2VsZi5jYWNoZVtpZF07XG5cbiAgICAgICAgICAgICAgICBlbCA9IHRhcmdldC5yZW5kZXIodGFyZ2V0LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQuZG9tLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2VcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzSW5Eb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC51bmJpbmRFdmVudHMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0LmRvbS5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRvbS5lbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNJbkRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuYnVpbGRTdGF0ZShzZWxmLmxhc3RPcGVyYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIG1peGl0dXAgZnVuY3Rpb25hbGl0eSBmcm9tIHRoZSBjb250YWluZXIsIHVuYmluZHMgYWxsIGNvbnRyb2xcbiAgICAgICAgICogZXZlbnQgaGFuZGxlcnMsIGFuZCBkZWxldGVzIHRoZSBtaXhlciBpbnN0YW5jZSBmcm9tIE1peEl0VXAncyBpbnRlcm5hbFxuICAgICAgICAgKiBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBzaG91bGQgYmUgcGVyZm9ybWVkIHdoZW5ldmVyIGEgbWl4ZXIncyBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tXG4gICAgICAgICAqIHRoZSBET00sIHN1Y2ggYXMgZHVyaW5nIGEgcGFnZSBjaGFuZ2UgaW4gYSBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbixcbiAgICAgICAgICogb3IgUmVhY3QncyBgY29tcG9uZW50V2lsbFVubW91bnQoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5kZXN0cm95KFtjbGVhblVwXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRGVzdHJveWluZyB0aGUgbWl4ZXIgYmVmb3JlIHJlbW92aW5nIGl0cyBjb250YWluZXIgZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb250YWluZXJFbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2NsZWFuVXA9ZmFsc2VdXG4gICAgICAgICAqICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0byBjbGVhbiB1cCBhbnkgaW5saW5lIGBkaXNwbGF5OiBub25lO2Agc3R5bGluZyBhcHBsaWVkIHRvIGhpZGRlbiB0YXJnZXRzLlxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oY2xlYW5VcCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgPSAwO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVEZXN0cm95JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgY29udHJvbCA9IHNlbGYuY29udHJvbHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVtb3ZlQmluZGluZyhzZWxmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc2VsZi50YXJnZXRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5VcCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldC51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuZG9tLmNvbnRhaW5lci5pZC5tYXRjaCgvXk1peEl0VXAvKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtaXhpdHVwLmluc3RhbmNlc1tzZWxmLmlkXTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJEZXN0cm95JywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5JTW92ZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5wb3NJbiAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zT3V0ICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlICAgPSAnJztcbiAgICAgICAgdGhpcy5kdXJhdGlvbiAgICAgICA9IC0xO1xuICAgICAgICB0aGlzLnN0YWdnZXJJbmRleCAgID0gLTE7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuSU1vdmVEYXRhKTtcblxuICAgIG1peGl0dXAuSU1vdmVEYXRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLklNb3ZlRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLklNb3ZlRGF0YTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuVGFyZ2V0RG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlRhcmdldERvbSk7XG5cbiAgICBtaXhpdHVwLlRhcmdldERvbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5UYXJnZXREb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5UYXJnZXREb207XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5UYXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMuc29ydFN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLm1peGVyICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbGxiYWNrICAgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2hvd24gICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0JvdW5kICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNFeGNsdWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW5Eb20gICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gICAgICAgID0gbmV3IG1peGl0dXAuVGFyZ2V0RG9tKCk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuVGFyZ2V0KTtcblxuICAgIG1peGl0dXAuVGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBoLmV4dGVuZChtaXhpdHVwLlRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuVGFyZ2V0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXNlcyBhIG5ld2x5IGluc3RhbnRpYXRlZCBUYXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7KEVsZW1lbnR8bnVsbCl9ICAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgICAgICAgICAgbWl4ZXJcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgICAgICAgICBbZGF0YV1cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsLCBtaXhlciwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGlkICAgPSAnJztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYubWl4ZXIgPSBtaXhlcjtcblxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGVsZW1lbnQgaXMgcHJvdmlkZWQsIHJlbmRlciBpdFxuXG4gICAgICAgICAgICAgICAgZWwgPSBzZWxmLnJlbmRlcihkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWNoZURvbShlbCk7XG5cbiAgICAgICAgICAgIHNlbGYuYmluZEV2ZW50cygpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5kb20uZWwuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgbWl4ZXIuY29uZmlnLmRhdGEudWlkS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaWQgPSBkYXRhW21peGVyLmNvbmZpZy5kYXRhLnVpZEtleV0pID09PSAndW5kZWZpbmVkJyB8fCBpZC50b1N0cmluZygpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRGF0YXNldEludmFsaWRVaWRLZXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkS2V5OiBtaXhlci5jb25maWcuZGF0YS51aWRLZXlcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuaWQgICAgID0gaWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhICAgPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgbWl4ZXIuY2FjaGVbaWRdID0gc2VsZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJJbml0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVycyB0aGUgdGFyZ2V0IGVsZW1lbnQgdXNpbmcgYSB1c2VyLWRlZmluZWQgcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjEuNFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBkYXRhXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZW5kZXIgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlbCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICB0ZW1wICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgID0gJyc7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVJlbmRlcicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJlbmRlciA9IHNlbGYuY2FsbEZpbHRlcnMoJ3JlbmRlclJlbmRlcicsIHNlbGYubWl4ZXIuY29uZmlnLnJlbmRlci50YXJnZXQsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRGF0YXNldFJlbmRlcmVyTm90U2V0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRwdXQgPSByZW5kZXIoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgdHlwZW9mIG91dHB1dCA9PT0gJ29iamVjdCcgJiYgaC5pc0VsZW1lbnQob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgIGVsID0gb3V0cHV0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICB0ZW1wLmlubmVySFRNTCA9IG91dHB1dDtcblxuICAgICAgICAgICAgICAgIGVsID0gdGVtcC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2VsUmVuZGVyJywgZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlcyByZWZlcmVuY2VzIG9mIERPTSBlbGVtZW50cyBuZWNjZXNzYXJ5IGZvciB0aGUgdGFyZ2V0J3MgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSBlbFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgY2FjaGVEb206IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUNhY2hlRG9tJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5kb20uZWwgPSBlbDtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJDYWNoZURvbScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRTb3J0U3RyaW5nOiBmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsdWUgICA9IHNlbGYuZG9tLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgYXR0cmlidXRlTmFtZSkgfHwgJyc7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUdldFNvcnRTdHJpbmcnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IGlzTmFOKHZhbHVlICogMSkgP1xuICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgIHZhbHVlICogMTtcblxuICAgICAgICAgICAgc2VsZi5zb3J0U3RyaW5nID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyR2V0U29ydFN0cmluZycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNob3cnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTaG93bikge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICAgICAgICAgIHNlbGYuaXNTaG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyU2hvdycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUhpZGUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgICAgIHNlbGYuaXNTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckhpZGUnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuSU1vdmVEYXRhfSBtb3ZlRGF0YVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgbW92ZTogZnVuY3Rpb24obW92ZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlTW92ZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5pc0V4Y2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5taXhlci50YXJnZXRzTW92ZWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5hcHBseVN0eWxlc0luKG1vdmVEYXRhKTtcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwbHlTdHlsZXNPdXQobW92ZURhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyTW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBwb3NEYXRhXG4gICAgICAgICAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgIG11bHRpcGxpZXJcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFwcGx5VHdlZW46IGZ1bmN0aW9uKHBvc0RhdGEsIG11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICB0d2VlbkRhdGEgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcG9zSW4gICAgICAgICAgICAgICAgICAgPSBwb3NEYXRhLnBvc0luLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm1WYWx1ZXMgID0gW10sXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcyAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5TdHlsZURhdGEoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVBcHBseVR3ZWVuJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgY3VycmVudFZhbHVlcy54ICAgICA9IHBvc0luLng7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWVzLnkgICAgID0gcG9zSW4ueTtcblxuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGYuaXNTaG93bikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBwcm9wZXJ0eU5hbWUgPSBtaXhpdHVwLmZlYXR1cmVzLlRXRUVOQUJMRVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhID0gcG9zRGF0YS50d2VlbkRhdGFbcHJvcGVydHlOYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR3ZWVuRGF0YSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcy54ID0gcG9zSW4ueCArICh0d2VlbkRhdGEgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHdlZW5EYXRhKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzLnkgPSBwb3NJbi55ICsgKHR3ZWVuRGF0YSAqIG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5EYXRhIGluc3RhbmNlb2YgbWl4aXR1cC5UcmFuc2Zvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHdlZW5EYXRhLnZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0udmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zSW5bcHJvcGVydHlOYW1lXS52YWx1ZSArICh0d2VlbkRhdGEudmFsdWUgKiBtdWx0aXBsaWVyKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0udW5pdCAgPSB0d2VlbkRhdGEudW5pdDtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtVmFsdWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgKyAnKCcgKyBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0udmFsdWUgKyB0d2VlbkRhdGEudW5pdCArICcpJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHdlZW5EYXRhKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0gPSBwb3NJbltwcm9wZXJ0eU5hbWVdICsgKHR3ZWVuRGF0YSAqIG11bHRpcGxpZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW3Byb3BlcnR5TmFtZV0gPSBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy54IHx8IGN1cnJlbnRWYWx1ZXMueSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm1WYWx1ZXMudW5zaGlmdCgndHJhbnNsYXRlKCcgKyBjdXJyZW50VmFsdWVzLnggKyAncHgsICcgKyBjdXJyZW50VmFsdWVzLnkgKyAncHgpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gPSBjdXJyZW50VHJhbnNmb3JtVmFsdWVzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJBcHBseVR3ZWVuJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgaW5pdGlhbCBzdHlsaW5nIHRvIGEgdGFyZ2V0IGVsZW1lbnQgYmVmb3JlIGFueSB0cmFuc2l0aW9uXG4gICAgICAgICAqIGlzIGFwcGxpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5JTW92ZURhdGF9IG1vdmVEYXRhXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBhcHBseVN0eWxlc0luOiBmdW5jdGlvbihtb3ZlRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcG9zSW4gICAgICAgICAgID0gbW92ZURhdGEucG9zSW4sXG4gICAgICAgICAgICAgICAgaXNGYWRpbmcgICAgICAgID0gc2VsZi5taXhlci5lZmZlY3RzSW4ub3BhY2l0eSAhPT0gMSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WYWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQXBwbHlTdHlsZXNJbicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcy5wdXNoKCd0cmFuc2xhdGUoJyArIHBvc0luLnggKyAncHgsICcgKyBwb3NJbi55ICsgJ3B4KScpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVEYXRhLnN0YXR1c0NoYW5nZSAhPT0gJ3Nob3cnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHBvc0luIHdpZHRoIG9yIGhlaWdodCBvciBzaG93aW5nLCBhcyB3aWxsIGJlIDBcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZS53aWR0aCAgPSBwb3NJbi53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLmhlaWdodCA9IHBvc0luLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUubWFyZ2luUmlnaHQgID0gcG9zSW4ubWFyZ2luUmlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9IHBvc0luLm1hcmdpbkJvdHRvbSArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzRmFkaW5nICYmIChzZWxmLmRvbS5lbC5zdHlsZS5vcGFjaXR5ID0gcG9zSW4ub3BhY2l0eSk7XG5cbiAgICAgICAgICAgIGlmIChtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgPT09ICdzaG93Jykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcyA9IHRyYW5zZm9ybVZhbHVlcy5jb25jYXQoc2VsZi5taXhlci50cmFuc2Zvcm1Jbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1WYWx1ZXMuam9pbignICcpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckFwcGx5U3R5bGVzSW4nLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGEgdHJhbnNpdGlvbiBmb2xsb3dlZCBieSB0aGUgZmluYWwgc3R5bGVzIGZvciB0aGUgZWxlbWVudCB0b1xuICAgICAgICAgKiB0cmFuc2l0aW9uIHRvd2FyZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5JTW92ZURhdGF9IG1vdmVEYXRhXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBhcHBseVN0eWxlc091dDogZnVuY3Rpb24obW92ZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25SdWxlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGlzUmVzaXppbmcgICAgICA9IHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cyxcbiAgICAgICAgICAgICAgICBpc0ZhZGluZyAgICAgICAgPSB0eXBlb2Ygc2VsZi5taXhlci5lZmZlY3RzSW4ub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUFwcGx5U3R5bGVzT3V0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHRyYW5zaXRpb24gcnVsZXNcblxuICAgICAgICAgICAgdHJhbnNpdGlvblJ1bGVzLnB1c2goc2VsZi53cml0ZVRyYW5zaXRpb25SdWxlKFxuICAgICAgICAgICAgICAgIG1peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUnVsZSxcbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5zdGFnZ2VySW5kZXhcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBpZiAobW92ZURhdGEuc3RhdHVzQ2hhbmdlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUnVsZXMucHVzaChzZWxmLndyaXRlVHJhbnNpdGlvblJ1bGUoXG4gICAgICAgICAgICAgICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25SdWxlcy5wdXNoKHNlbGYud3JpdGVUcmFuc2l0aW9uUnVsZShcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblJ1bGVzLnB1c2goc2VsZi53cml0ZVRyYW5zaXRpb25SdWxlKFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblJ1bGVzLnB1c2goc2VsZi53cml0ZVRyYW5zaXRpb25SdWxlKFxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luJyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIHRoZSBlbGVtZW50IHdpbGxcbiAgICAgICAgICAgIC8vIG5vdCB0cmFuc2l0aW9uIGluIGFueSB3YXkgc28gdGFnIGl0IGFzIFwiaW1tb3ZhYmxlXCJcblxuICAgICAgICAgICAgaWYgKCFtb3ZlRGF0YS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNlbGYubWl4ZXIudGFyZ2V0c0ltbW92YWJsZSsrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubWl4ZXIudGFyZ2V0c01vdmVkID09PSBzZWxmLm1peGVyLnRhcmdldHNJbW1vdmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIHRhcmdldHMgbW92ZWQgaXMgZXF1YWwgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBpbW1vdmFibGUgdGFyZ2V0cywgdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgY29uc2lkZXJlZCBmaW5pc2hlZFxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWl4ZXIuY2xlYW5VcChtb3ZlRGF0YS5vcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCB3aWxsIHRyYW5zaXRpb24gaW4gc29tZSBmYXNpb24sXG4gICAgICAgICAgICAvLyBhc3NpZ24gYSBjYWxsYmFjayBmdW5jdGlvblxuXG4gICAgICAgICAgICBzZWxmLm9wZXJhdGlvbiA9IG1vdmVEYXRhLm9wZXJhdGlvbjtcbiAgICAgICAgICAgIHNlbGYuY2FsbGJhY2sgPSBtb3ZlRGF0YS5jYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGUgdGFyZ2V0IGlzIG5vdCBleGNsdWRlZCwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHRhcmdldHMgYm91bmRcblxuICAgICAgICAgICAgIXNlbGYuaXNFeGNsdWRlZCAmJiBzZWxmLm1peGVyLnRhcmdldHNCb3VuZCsrO1xuXG4gICAgICAgICAgICAvLyBUYWcgdGhlIHRhcmdldCBhcyBib3VuZCB0byBkaWZmZXJlbnRpYXRlIGZyb20gdHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgLy8gZXZlbnRzIHRoYXQgbWF5IGNvbWUgZnJvbSBzdHlsZXNoZWV0IGRyaXZlbiBlZmZlY3RzXG5cbiAgICAgICAgICAgIHNlbGYuaXNCb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSB0cmFuc2l0aW9uXG5cbiAgICAgICAgICAgIHNlbGYuYXBwbHlUcmFuc2l0aW9uKHRyYW5zaXRpb25SdWxlcyk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHdpZHRoLCBoZWlnaHQgYW5kIG1hcmdpbiBuZWdhdGlvblxuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZyAmJiBtb3ZlRGF0YS5wb3NPdXQud2lkdGggPiAwICYmIG1vdmVEYXRhLnBvc091dC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUud2lkdGggICAgICAgID0gbW92ZURhdGEucG9zT3V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZS5oZWlnaHQgICAgICAgPSBtb3ZlRGF0YS5wb3NPdXQuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZS5tYXJnaW5SaWdodCAgPSBtb3ZlRGF0YS5wb3NPdXQubWFyZ2luUmlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9IG1vdmVEYXRhLnBvc091dC5tYXJnaW5Cb3R0b20gKyAncHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5udWRnZSAmJiBtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgPT09ICdoaWRlJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBudWRnaW5nLCB0aGUgdHJhbnNsYXRpb24gc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gYXBwbGllZCBiZWZvcmUgYW55IG90aGVyIHRyYW5zZm9ybXMgdG8gcHJldmVudFxuICAgICAgICAgICAgICAgIC8vIGxhdGVyYWwgbW92ZW1lbnRcblxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcy5wdXNoKCd0cmFuc2xhdGUoJyArIG1vdmVEYXRhLnBvc091dC54ICsgJ3B4LCAnICsgbW92ZURhdGEucG9zT3V0LnkgKyAncHgpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGZhZGVcblxuICAgICAgICAgICAgc3dpdGNoIChtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdoaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgaXNGYWRpbmcgJiYgKHNlbGYuZG9tLmVsLnN0eWxlLm9wYWNpdHkgPSBzZWxmLm1peGVyLmVmZmVjdHNPdXQub3BhY2l0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFsdWVzID0gdHJhbnNmb3JtVmFsdWVzLmNvbmNhdChzZWxmLm1peGVyLnRyYW5zZm9ybU91dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2hvdyc6XG4gICAgICAgICAgICAgICAgICAgIGlzRmFkaW5nICYmIChzZWxmLmRvbS5lbC5zdHlsZS5vcGFjaXR5ID0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLm1peGVyLmNvbmZpZy5hbmltYXRpb24ubnVkZ2UgfHxcbiAgICAgICAgICAgICAgICAoIXNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5udWRnZSAmJiBtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgIT09ICdoaWRlJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIE9wcG9zaXRlIG9mIGFib3ZlIC0gYXBwbHkgdHJhbnNsYXRlIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdHJhbnNmb3JtXG5cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WYWx1ZXMucHVzaCgndHJhbnNsYXRlKCcgKyBtb3ZlRGF0YS5wb3NPdXQueCArICdweCwgJyArIG1vdmVEYXRhLnBvc091dC55ICsgJ3B4KScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm1zXG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1WYWx1ZXMuam9pbignICcpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckFwcGx5U3R5bGVzT3V0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZXMgdGhlIG5hbWUgb2YgYSBDU1MgcHJvcGVydHkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgZHVyYXRpb24gYW5kIGRlbGF5XG4gICAgICAgICAqIHZhbHVlcyB0byBjcmVhdGVkIGEgdmFsaWQgdHJhbnNpdGlvbiBydWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgcHJvcGVydHlcbiAgICAgICAgICogQHBhcmFtICAge251bWJlcn0gICAgc3RhZ2dlckluZGV4XG4gICAgICAgICAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgIGR1cmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHdyaXRlVHJhbnNpdGlvblJ1bGU6IGZ1bmN0aW9uKHByb3BlcnR5LCBzdGFnZ2VySW5kZXgsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlbGF5ID0gc2VsZi5nZXREZWxheShzdGFnZ2VySW5kZXgpLFxuICAgICAgICAgICAgICAgIHJ1bGUgID0gJyc7XG5cbiAgICAgICAgICAgIHJ1bGUgPSBwcm9wZXJ0eSArICcgJyArXG4gICAgICAgICAgICAgICAgKGR1cmF0aW9uID4gMCA/IGR1cmF0aW9uIDogc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmR1cmF0aW9uKSArICdtcyAnICtcbiAgICAgICAgICAgICAgICBkZWxheSArICdtcyAnICtcbiAgICAgICAgICAgICAgICAocHJvcGVydHkgPT09ICdvcGFjaXR5JyA/ICdsaW5lYXInIDogc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmVhc2luZyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdydWxlV3JpdGVUcmFuc2l0aW9uUnVsZScsIHJ1bGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHRyYW5zaXRpb24gZGVsYXkgZm9yIGVhY2ggdGFyZ2V0IGVsZW1lbnQgYmFzZWQgb24gaXRzIGluZGV4LCBpZlxuICAgICAgICAgKiBzdGFnZ2VyaW5nIGlzIGFwcGxpZWQuIElmIGRlZmluZWQsIEEgY3VzdG9tIGBhbmltYXRpb24uc3RhZ2dlclNlcWV1ZW5jZWBcbiAgICAgICAgICogZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgb2YgaW5kaWNlcyB0byBwcm9kdWNlIGN1c3RvbVxuICAgICAgICAgKiBzdGFnZ2VyIGVmZmVjdHMgKGUuZy4gZm9yIHVzZSBpbiBhIGdyaWQgd2l0aCBpcnJlZ3VsYXIgcm93IGxlbmd0aHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge251bWJlcn0gICAgaW5kZXhcbiAgICAgICAgICogQHJldHVybiAge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0RGVsYXk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGVsYXkgICA9IC0xO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5zdGFnZ2VyU2VxdWVuY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5zdGFnZ2VyU2VxdWVuY2UuY2FsbChzZWxmLCBpbmRleCwgc2VsZi5zdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGF5ID0gISFzZWxmLm1peGVyLnN0YWdnZXJEdXJhdGlvbiA/IGluZGV4ICogc2VsZi5taXhlci5zdGFnZ2VyRHVyYXRpb24gOiAwO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnZGVsYXlHZXREZWxheScsIGRlbGF5LCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ1tdfSAgcnVsZXNcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFwcGx5VHJhbnNpdGlvbjogZnVuY3Rpb24ocnVsZXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uU3RyaW5nICAgID0gcnVsZXMuam9pbignLCAnKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQXBwbHlUcmFuc2l0aW9uJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGVbbWl4aXR1cC5mZWF0dXJlcy50cmFuc2l0aW9uUHJvcF0gPSB0cmFuc2l0aW9uU3RyaW5nO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckFwcGx5VHJhbnNpdGlvbicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGhhbmRsZVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgICAgPSBlLnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBjYW5SZXNpemUgICA9IHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSGFuZGxlVHJhbnNpdGlvbkVuZCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmlzQm91bmQgJiZcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5tYXRjaGVzKHNlbGYubWl4ZXIuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQpICYmXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhblJlc2l6ZSAmJiBwcm9wTmFtZS5pbmRleE9mKCdoZWlnaHQnKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhblJlc2l6ZSAmJiBwcm9wTmFtZS5pbmRleE9mKCd3aWR0aCcpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgY2FuUmVzaXplICYmIHByb3BOYW1lLmluZGV4T2YoJ21hcmdpbicpID4gLTFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrLmNhbGwoc2VsZiwgc2VsZi5vcGVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckhhbmRsZVRyYW5zaXRpb25FbmQnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0V2ZW50fSAgICAgZVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZXZlbnRCdXM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlRXZlbnRCdXMnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlYmtpdFRyYW5zaXRpb25FbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zaXRpb25lbmQnOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVRyYW5zaXRpb25FbmQoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyRXZlbnRCdXMnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVVuYmluZEV2ZW50cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGgub2ZmKHNlbGYuZG9tLmVsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHNlbGYuaGFuZGxlcik7XG4gICAgICAgICAgICBoLm9mZihzZWxmLmRvbS5lbCwgJ3RyYW5zaXRpb25lbmQnLCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclVuYmluZEV2ZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ICA9ICcnO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVCaW5kRXZlbnRzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gbWl4aXR1cC5mZWF0dXJlcy50cmFuc2l0aW9uUHJlZml4ID09PSAnd2Via2l0JyA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcblxuICAgICAgICAgICAgc2VsZi5oYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmV2ZW50QnVzKGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaC5vbihzZWxmLmRvbS5lbCwgdHJhbnNpdGlvbkVuZEV2ZW50LCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckJpbmRFdmVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2dldEJveF1cbiAgICAgICAgICogQHJldHVybiAge1Bvc0RhdGF9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldFBvc0RhdGE6IGZ1bmN0aW9uKGdldEJveCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0eWxlcyAgPSB7fSxcbiAgICAgICAgICAgICAgICByZWN0ICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NEYXRhID0gbmV3IG1peGl0dXAuU3R5bGVEYXRhKCk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUdldFBvc0RhdGEnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBwb3NEYXRhLnggPSBzZWxmLmRvbS5lbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgcG9zRGF0YS55ID0gc2VsZi5kb20uZWwub2Zmc2V0VG9wO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVUYXJnZXRzIHx8IGdldEJveCkge1xuICAgICAgICAgICAgICAgIHJlY3QgPSBzZWxmLmRvbS5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIHBvc0RhdGEudG9wICAgICA9IHJlY3QudG9wO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucmlnaHQgICA9IHJlY3QucmlnaHQ7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5ib3R0b20gID0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5sZWZ0ICAgID0gcmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgcG9zRGF0YS53aWR0aCAgPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLm1peGVyLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZVRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWxmLmRvbS5lbCk7XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLm1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5tYXJnaW5SaWdodCAgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwb3NEYXRhR2V0UG9zRGF0YScsIHBvc0RhdGEsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAgICAgIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBjbGVhblVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQ2xlYW5VcCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gID0gJyc7XG4gICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnRyYW5zaXRpb25Qcm9wXSA9ICcnO1xuICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUub3BhY2l0eSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAnJztcblxuICAgICAgICAgICAgaWYgKHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLndpZHRoICAgICAgICA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLmhlaWdodCAgICAgICA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpblJpZ2h0ICA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckNsZWFuVXAnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGpRdWVyeS1jb2xsZWN0aW9uLWxpa2Ugd3JhcHBlciBhcm91bmQgb25lIG9yIG1vcmUgYG1peGl0dXAuTWl4ZXJgIGluc3RhbmNlc1xuICAgICAqIGFsbG93aW5nIHNpbXVsdGFuZW91cyBjb250cm9sIG9mIHNhaWQgaW5zdGFuY2VzIHNpbWlsYXIgdG8gdGhlIE1peEl0VXAgMiBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ldyBtaXhpdHVwLkNvbGxlY3Rpb24oaW5zdGFuY2VzKVxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgICAge21peGl0dXAuTWl4ZXJbXX0gICBpbnN0YW5jZXNcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgICAgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlbmd0aCA9IGluc3RhbmNlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLmZyZWV6ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db2xsZWN0aW9uKTtcblxuICAgIG1peGl0dXAuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgaC5leHRlbmQobWl4aXR1cC5Db2xsZWN0aW9uLnByb3RvdHlwZSxcbiAgICAvKiogQGxlbmRzIG1peGl0dXAuQ29sbGVjdGlvbiAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuQ29sbGVjdGlvbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYSBtZXRob2Qgb24gYWxsIGluc3RhbmNlcyBpbiB0aGUgY29sbGVjdGlvbiBieSBwYXNzaW5nIHRoZSBtZXRob2RcbiAgICAgICAgICogbmFtZSBhcyBhIHN0cmluZyBmb2xsb3dlZCBieSBhbnkgYXBwbGljYWJsZSBwYXJhbWV0ZXJzIHRvIGJlIGN1cnJpZWQgaW50b1xuICAgICAgICAgKiB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAubWl4aXR1cChtZXRob2ROYW1lWyxhcmcxXVssYXJnMi4uXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oW21peGVyMSwgbWl4ZXIyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHJldHVybiBjb2xsZWN0aW9uLm1peGl0dXAoJ2ZpbHRlcicsICcuY2F0ZWdvcnktYScpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZXMpIHtcbiAgICAgICAgICogICAgICAgICBzdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZUZpbHRlci5zZWxlY3Rvcik7IC8vIC5jYXRlZ29yeS1hXG4gICAgICAgICAqICAgICAgICAgfSk7XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgbWV0aG9kTmFtZVxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2U8QXJyYXk8bWl4aXR1cC5TdGF0ZT4+fVxuICAgICAgICAgKi9cblxuICAgICAgICBtaXhpdHVwOiBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhcmdzICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVNaXhpdHVwJyk7XG5cbiAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaW5zdGFuY2UgPSBzZWxmW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KGluc3RhbmNlLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwcm9taXNlTWl4aXR1cCcsIGguYWxsKHRhc2tzLCBtaXhpdHVwLmxpYnJhcmllcyksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIGBtaXhpdHVwLk9wZXJhdGlvbmAgb2JqZWN0cyBjb250YWluIGFsbCBkYXRhIG5lY2Nlc3NhcnkgdG8gZGVzY3JpYmUgdGhlIGZ1bGxcbiAgICAgKiBsaWZlY3ljbGUgb2YgYW55IE1peEl0VXAgb3BlcmF0aW9uLiBUaGV5IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgYW5kIHN0b3JlIGFuXG4gICAgICogb3BlcmF0aW9uIGZvciB1c2UgYXQgYSBsYXRlciB0aW1lIChlLmcuIHByb2dyYW1tYXRpYyB0d2VlbmluZykuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5PcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgICAgICAgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuYXJncyAgICAgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5jb21tYW5kICAgICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvd1Bvc0RhdGEgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy50b0hpZGVQb3NEYXRhICAgICAgICAgICA9IFtdO1xuXG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm5ld1N0YXRlICAgICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb2NTdGF0ZSAgICAgICAgICAgICAgICA9IG51bGw7XG5cbiAgICAgICAgdGhpcy53aWxsU29ydCAgICAgICAgICAgICAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpbGxDaGFuZ2VMYXlvdXQgICAgICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRWZmZWN0ICAgICAgICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgICAgICAgICAgICAgICA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlckVsZW1lbnQgICAgICAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc2hvdyAgICAgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5oaWRlICAgICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoaW5nICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMudG9TaG93ICAgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy50b0hpZGUgICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnRvTW92ZSAgICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMudG9SZW1vdmUgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydE9yZGVyICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLm5ld09yZGVyICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRTb3J0ICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm5ld1NvcnQgICAgICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydEZpbHRlciAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMubmV3RmlsdGVyICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0RGF0YXNldCAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXdEYXRhc2V0ICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld3BvcnREZWx0YVggICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0RGVsdGFZICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFggICAgICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRZICAgICAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0SGVpZ2h0ICAgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFdpZHRoICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMubmV3WCAgICAgICAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLm5ld1kgICAgICAgICAgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5uZXdIZWlnaHQgICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMubmV3V2lkdGggICAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0Q29udGFpbmVyQ2xhc3NOYW1lID0gJyc7XG4gICAgICAgIHRoaXMuc3RhcnREaXNwbGF5ICAgICAgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy5uZXdDb250YWluZXJDbGFzc05hbWUgICA9ICcnO1xuICAgICAgICB0aGlzLm5ld0Rpc3BsYXkgICAgICAgICAgICAgID0gJyc7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuT3BlcmF0aW9uKTtcblxuICAgIG1peGl0dXAuT3BlcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLk9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLk9wZXJhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIGBtaXhpdHVwLlN0YXRlYCBvYmplY3RzIGV4cG9zZSB2YXJpb3VzIHBpZWNlcyBvZiBkYXRhIGRldGFpbGluZyB0aGUgc3RhdGUgb2ZcbiAgICAgKiBhIE1peEl0VXAgaW5zdGFuY2UuIFRoZXkgYXJlIHByb3ZpZGVkIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIGFueSBvcGVyYXRpb24gdmlhXG4gICAgICogY2FsbGJhY2tzIGFuZCBldmVudHMsIHdpdGggdGhlIG1vc3QgcmVjZW50IHN0YXRlIHN0b3JlZCBiZXR3ZWVuIG9wZXJhdGlvbnNcbiAgICAgKiBmb3IgcmV0cmlldmFsIGF0IGFueSB0aW1lIHZpYSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5TdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBtaXhlciBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGlkXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICcnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuaWQgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyIGNvbW1hbmQgYXMgc2V0IGJ5IGEgY29udHJvbCBjbGljayBvciBBUEkgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGFjdGl2ZUZpbHRlclxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5TdGF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHttaXhpdHVwLkNvbW1hbmRGaWx0ZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsdGVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgc29ydCBjb21tYW5kIGFzIHNldCBieSBhIGNvbnRyb2wgY2xpY2sgb3IgQVBJIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhY3RpdmVTb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge21peGl0dXAuQ29tbWFuZFNvcnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuYWN0aXZlU29ydCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGxheW91dC1zcGVjaWZpYyBjb250YWluZXIgY2xhc3MgbmFtZSwgaWYgYXBwbGllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5TdGF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZSA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgbWl4ZXIgaXMgaW5zdGFudGlhdGVkIG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0VsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgYWxsIHRhcmdldCBlbGVtZW50cyBpbmRleGVkIGJ5IHRoZSBtaXhlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRhcmdldHNcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7QXJyYXkuPEVsZW1lbnQ+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgW11cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50YXJnZXRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGFsbCB0YXJnZXQgZWxlbWVudHMgbm90IG1hdGNoaW5nIHRoZSBjdXJyZW50IGZpbHRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGhpZGVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7QXJyYXkuPEVsZW1lbnQ+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgW11cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5oaWRlID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGFsbCB0YXJnZXQgZWxlbWVudHMgbWF0Y2hpbmcgdGhlIGN1cnJlbnQgZmlsdGVyIGFuZCBhbnkgYWRkaXRpb25hbFxuICAgICAgICAgKiBsaW1pdHMgYXBwbGllZCBzdWNoIGFzIHBhZ2luYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzaG93XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0FycmF5LjxFbGVtZW50Pn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIFtdXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuc2hvdyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBhbGwgdGFyZ2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBjdXJyZW50IGZpbHRlciBpcnJlc3BlY3RpdmUgb2ZcbiAgICAgICAgICogYW55IGFkZGl0aW9uYWwgbGltaXRzIGFwcGxpZWQgc3VjaCBhcyBwYWdpbmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbWF0Y2hpbmdcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7QXJyYXkuPEVsZW1lbnQ+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgW11cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5tYXRjaGluZyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIHRhcmdldCBlbGVtZW50cyBpbmRleGVkIGJ5IHRoZVxuICAgICAgICAgKiBtaXhlci4gRXF1aXZhbGVudCB0byBgc3RhdGUudGFyZ2V0cy5sZW5ndGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdG90YWxUYXJnZXRzXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIC0xXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudG90YWxUYXJnZXRzID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgdGFyZ2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZVxuICAgICAgICAgKiBjdXJyZW50IGZpbHRlciBhbmQgYW55IGFkZGl0aW9uYWwgbGltaXRzIGFwcGxpZWQgc3VjaCBhcyBwYWdpbmF0aW9uLlxuICAgICAgICAgKiBFcXVpdmFsZW50IHRvIGBzdGF0ZS5zaG93Lmxlbmd0aGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICB0b3RhbFNob3dcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgLTFcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50b3RhbFNob3cgPSAtMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIHRvdGFsIG51bWJlciBvZiB0YXJnZXQgZWxlbWVudHMgbm90IG1hdGNoaW5nXG4gICAgICAgICAqIHRoZSBjdXJyZW50IGZpbHRlci4gRXF1aXZhbGVudCB0byBgc3RhdGUuaGlkZS5sZW5ndGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdG90YWxIaWRlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIC0xXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudG90YWxIaWRlID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgdGFyZ2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZVxuICAgICAgICAgKiBjdXJyZW50IGZpbHRlciBpcnJlc3BlY3RpdmUgb2YgYW55IG90aGVyIGxpbWl0cyBhcHBsaWVkIHN1Y2ggYXMgcGFnaW5hdGlvbi5cbiAgICAgICAgICogRXF1aXZhbGVudCB0byBgc3RhdGUubWF0Y2hpbmcubGVuZ3RoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRvdGFsTWF0Y2hpbmdcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgLTFcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50b3RhbE1hdGNoaW5nID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGxhc3Qgb3BlcmF0aW9uIFwiZmFpbGVkXCIsIGkuZS4gbm8gdGFyZ2V0c1xuICAgICAgICAgKiBjb3VsZCBiZSBmb3VuZCBtYXRjaGluZyB0aGUgZmlsdGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgaGFzRmFpbGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBmYWxzZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmhhc0ZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBpZiB0aGUgbGFzdCBvcGVyYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGVcbiAgICAgICAgICogY2xpY2tpbmcgb2YgYSBjb250cm9sIGFuZCBub3QgYW4gQVBJIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICB0cmlnZ2VyRWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5TdGF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtFbGVtZW50fG51bGx9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudHJpZ2dlckVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkYXRhc2V0IHVuZGVybHlpbmcgdGhlIHJlbmRlcmVkIHRhcmdldHMsIGlmIHRoZVxuICAgICAgICAgKiBkYXRhc2V0IEFQSSBpcyBpbiB1c2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhY3RpdmVEYXRhc2V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0FycmF5LjxvYmplY3Q+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmFjdGl2ZURhdGFzZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlN0YXRlKTtcblxuICAgIG1peGl0dXAuU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5TdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuVXNlckluc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIHRoaXMuY29tbWFuZCAgICA9IHt9O1xuICAgICAgICB0aGlzLmFuaW1hdGUgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayAgID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24pO1xuXG4gICAgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuVXNlckluc3RydWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuVXNlckluc3RydWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5NZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKiBFcnJvcnNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICB0aGlzLkVSUk9SX0ZBQ1RPUllfSU5WQUxJRF9DT05UQUlORVIgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBBbiBpbnZhbGlkIHNlbGVjdG9yIG9yIGVsZW1lbnQgcmVmZXJlbmNlIHdhcyBwYXNzZWQgdG8gdGhlIG1peGl0dXAgZmFjdG9yeSBmdW5jdGlvbic7XG5cbiAgICAgICAgdGhpcy5FUlJPUl9GQUNUT1JZX0NPTlRBSU5FUl9OT1RfRk9VTkQgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBUaGUgcHJvdmlkZWQgc2VsZWN0b3IgeWllbGRlZCBubyBjb250YWluZXIgZWxlbWVudCc7XG5cbiAgICAgICAgdGhpcy5FUlJPUl9DT05GSUdfSU5WQUxJRF9BTklNQVRJT05fRUZGRUNUUyA9XG4gICAgICAgICAgICAnW01peEl0VXBdIEludmFsaWQgdmFsdWUgZm9yIGBhbmltYXRpb24uZWZmZWN0c2AnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfQ09ORklHX0lOVkFMSURfQ09OVFJPTFNfU0NPUEUgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBJbnZhbGlkIHZhbHVlIGZvciBgY29udHJvbHMuc2NvcGVgJztcblxuICAgICAgICB0aGlzLkVSUk9SX0NPTkZJR19JTlZBTElEX1BST1BFUlRZID1cbiAgICAgICAgICAgICdbTWl4aXRVcF0gSW52YWxpZCBjb25maWd1cmF0aW9uIG9iamVjdCBwcm9wZXJ0eSBcIiR7ZXJyb25lb3VzfVwiJHtzdWdnZXN0aW9ufSc7XG5cbiAgICAgICAgdGhpcy5FUlJPUl9DT05GSUdfSU5WQUxJRF9QUk9QRVJUWV9TVUdHRVNUSU9OID1cbiAgICAgICAgICAgICcuIERpZCB5b3UgbWVhbiBcIiR7cHJvYmFibGVNYXRjaH1cIj8nO1xuXG4gICAgICAgIHRoaXMuRVJST1JfQ09ORklHX0RBVEFfVUlEX0tFWV9OT1RfU0VUID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gVG8gdXNlIHRoZSBkYXRhc2V0IEFQSSwgYSBVSUQga2V5IG11c3QgYmUgc3BlY2lmaWVkIHVzaW5nIGBkYXRhLnVpZEtleWAnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfREFUQVNFVF9JTlZBTElEX1VJRF9LRVkgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBUaGUgc3BlY2lmaWVkIFVJRCBrZXkgXCIke3VpZEtleX1cIiBpcyBub3QgcHJlc2VudCBvbiBvbmUgb3IgbW9yZSBkYXRhc2V0IGl0ZW1zJztcblxuICAgICAgICB0aGlzLkVSUk9SX0RBVEFTRVRfRFVQTElDQVRFX1VJRCA9XG4gICAgICAgICAgICAnW01peEl0VXBdIFRoZSBVSUQgXCIke3VpZH1cIiB3YXMgZm91bmQgb24gdHdvIG9yIG1vcmUgZGF0YXNldCBpdGVtcy4gVUlEcyBtdXN0IGJlIHVuaXF1ZS4nO1xuXG4gICAgICAgIHRoaXMuRVJST1JfSU5TRVJUX0lOVkFMSURfQVJHVU1FTlRTID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gUGxlYXNlIHByb3ZpZGVyIGVpdGhlciBhbiBpbmRleCBvciBhIHNpYmxpbmcgYW5kIHBvc2l0aW9uIHRvIGluc2VydCwgbm90IGJvdGgnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfSU5TRVJUX1BSRUVYSVNUSU5HX0VMRU1FTlQgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBBbiBlbGVtZW50IHRvIGJlIGluc2VydGVkIGFscmVhZHkgZXhpc3RzIGluIHRoZSBjb250YWluZXInO1xuXG4gICAgICAgIHRoaXMuRVJST1JfRklMVEVSX0lOVkFMSURfQVJHVU1FTlRTID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgc2VsZWN0b3Igb3IgY29sbGVjdGlvbiBgLmZpbHRlcigpYCwgbm90IGJvdGgnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfREFUQVNFVF9OT1RfU0VUID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gVG8gdXNlIHRoZSBkYXRhc2V0IEFQSSB3aXRoIHByZS1yZW5kZXJlZCB0YXJnZXRzLCBhIHN0YXJ0aW5nIGRhdGFzZXQgbXVzdCBiZSBzZXQgdXNpbmcgYGxvYWQuZGF0YXNldGAnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfREFUQVNFVF9QUkVSRU5ERVJFRF9NSVNNQVRDSCA9XG4gICAgICAgICAgICAnW01peEl0VXBdIGBsb2FkLmRhdGFzZXRgIGRvZXMgbm90IG1hdGNoIHByZS1yZW5kZXJlZCB0YXJnZXRzJztcblxuICAgICAgICB0aGlzLkVSUk9SX0RBVEFTRVRfUkVOREVSRVJfTk9UX1NFVCA9XG4gICAgICAgICAgICAnW01peEl0VXBdIFRvIGluc2VydCBhbiBlbGVtZW50IHZpYSB0aGUgZGF0YXNldCBBUEksIGEgdGFyZ2V0IHJlbmRlcmVyIGZ1bmN0aW9uIG11c3QgYmUgcHJvdmlkZWQgdG8gYHJlbmRlci50YXJnZXRgJztcblxuICAgICAgICB0aGlzLkVSUk9SX1NPUlRfTk9OX0VYSVNURU5UX0VMRU1FTlQgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBBbiBlbGVtZW50IHRvIGJlIHNvcnRlZCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb250YWluZXInO1xuXG4gICAgICAgIC8qIFdhcm5pbmdzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgdGhpcy5XQVJOSU5HX0ZBQ1RPUllfUFJFRVhJU1RJTkdfSU5TVEFOQ0UgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBUaGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYW4gYWN0aXZlIE1peEl0VXAgaW5zdGFuY2UuIFRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIG9iamVjdCB3aWxsIGJlIGlnbm9yZWQuJyArXG4gICAgICAgICAgICAnIElmIHlvdSB3aXNoIHRvIHBlcmZvcm0gYWRkaXRpb25hbCBtZXRob2RzIG9uIHRoaXMgaW5zdGFuY2UsIHBsZWFzZSBjcmVhdGUgYSByZWZlcmVuY2UuJztcblxuICAgICAgICB0aGlzLldBUk5JTkdfSU5TRVJUX05PX0VMRU1FTlRTID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gV0FSTklORzogTm8gdmFsaWQgZWxlbWVudHMgd2VyZSBwYXNzZWQgdG8gYC5pbnNlcnQoKWAnO1xuXG4gICAgICAgIHRoaXMuV0FSTklOR19SRU1PVkVfTk9fRUxFTUVOVFMgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBObyB2YWxpZCBlbGVtZW50cyB3ZXJlIHBhc3NlZCB0byBgLnJlbW92ZSgpYCc7XG5cbiAgICAgICAgdGhpcy5XQVJOSU5HX01VTFRJTUlYX0lOU1RBTkNFX1FVRVVFX0ZVTEwgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBBbiBvcGVyYXRpb24gd2FzIHJlcXVlc3RlZCBidXQgdGhlIE1peEl0VXAgaW5zdGFuY2Ugd2FzIGJ1c3kuIFRoZSBvcGVyYXRpb24gd2FzIHJlamVjdGVkIGJlY2F1c2UgdGhlICcgK1xuICAgICAgICAgICAgJ3F1ZXVlIGlzIGZ1bGwgb3IgcXVldWluZyBpcyBkaXNhYmxlZC4nO1xuXG4gICAgICAgIHRoaXMuV0FSTklOR19HRVRfT1BFUkFUSU9OX0lOU1RBTkNFX0JVU1kgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBPcGVyYXRpb25zIGNhbiBiZSBiZSBjcmVhdGVkIHdoaWxlIHRoZSBNaXhJdFVwIGluc3RhbmNlIGlzIGJ1c3kuJztcblxuICAgICAgICB0aGlzLldBUk5JTkdfTk9fUFJPTUlTRV9JTVBMRU1FTlRBVElPTiA9XG4gICAgICAgICAgICAnW01peEl0VXBdIFdBUk5JTkc6IE5vIFByb21pc2UgaW1wbGVtZW50YXRpb25zIGNvdWxkIGJlIGZvdW5kLiBJZiB5b3Ugd2lzaCB0byB1c2UgcHJvbWlzZXMgd2l0aCBNaXhJdFVwIHBsZWFzZSBpbnN0YWxsJyArXG4gICAgICAgICAgICAnIGFuIEVTNiBQcm9taXNlIHBvbHlmaWxsLic7XG5cbiAgICAgICAgdGhpcy5XQVJOSU5HX0lOQ09OU0lTVEVOVF9TT1JUSU5HX0FUVFJJQlVURVMgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBUaGUgcmVxdWVzdGVkIHNvcnRpbmcgZGF0YSBhdHRyaWJ1dGUgXCIke2F0dHJpYnV0ZX1cIiB3YXMgbm90IHByZXNlbnQgb24gb25lIG9yIG1vcmUgdGFyZ2V0IGVsZW1lbnRzJyArXG4gICAgICAgICAgICAnIHdoaWNoIG1heSBwcm9kdWN0IHVuZXhwZWN0ZWQgc29ydCBvdXRwdXQnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb21waWxlVGVtcGxhdGVzKCk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLk1lc3NhZ2VzKTtcblxuICAgIG1peGl0dXAuTWVzc2FnZXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuTWVzc2FnZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5NZXNzYWdlcztcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBtaXhpdHVwLk1lc3NhZ2VzLnByb3RvdHlwZS5jb21waWxlVGVtcGxhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlcnJvcktleSAgICAgICAgPSAnJztcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSAgICA9ICcnO1xuXG4gICAgICAgIGZvciAoZXJyb3JLZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3JNZXNzYWdlID0gdGhpc1tlcnJvcktleV0pICE9PSAnc3RyaW5nJykgY29udGludWU7XG5cbiAgICAgICAgICAgIHRoaXNbaC5jYW1lbENhc2UoZXJyb3JLZXkpXSA9IGgudGVtcGxhdGUoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtaXhpdHVwLm1lc3NhZ2VzID0gbmV3IG1peGl0dXAuTWVzc2FnZXMoKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgICAge21peGl0dXAuTWl4ZXJ9IG1peGVyXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkZhY2FkZSA9IGZ1bmN0aW9uIE1peGVyKG1peGVyKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmUgICAgICAgICAgPSBtaXhlci5jb25maWd1cmUuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuc2hvdyAgICAgICAgICAgICAgID0gbWl4ZXIuc2hvdy5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5oaWRlICAgICAgICAgICAgICAgPSBtaXhlci5oaWRlLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmZpbHRlciAgICAgICAgICAgICA9IG1peGVyLmZpbHRlci5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy50b2dnbGVPbiAgICAgICAgICAgPSBtaXhlci50b2dnbGVPbi5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy50b2dnbGVPZmYgICAgICAgICAgPSBtaXhlci50b2dnbGVPZmYuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuc29ydCAgICAgICAgICAgICAgID0gbWl4ZXIuc29ydC5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VMYXlvdXQgICAgICAgPSBtaXhlci5jaGFuZ2VMYXlvdXQuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMubXVsdGltaXggICAgICAgICAgID0gbWl4ZXIubXVsdGltaXguYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuZGF0YXNldCAgICAgICAgICAgID0gbWl4ZXIuZGF0YXNldC5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy50d2VlbiAgICAgICAgICAgICAgPSBtaXhlci50d2Vlbi5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5pbnNlcnQgICAgICAgICAgICAgPSBtaXhlci5pbnNlcnQuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlICAgICAgID0gbWl4ZXIuaW5zZXJ0QmVmb3JlLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmluc2VydEFmdGVyICAgICAgICA9IG1peGVyLmluc2VydEFmdGVyLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLnByZXBlbmQgICAgICAgICAgICA9IG1peGVyLnByZXBlbmQuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuYXBwZW5kICAgICAgICAgICAgID0gbWl4ZXIuYXBwZW5kLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLnJlbW92ZSAgICAgICAgICAgICA9IG1peGVyLnJlbW92ZS5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ICAgICAgICAgICAgPSBtaXhlci5kZXN0cm95LmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCAgICAgICA9IG1peGVyLmZvcmNlUmVmcmVzaC5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5mb3JjZVJlbmRlciAgICAgICAgPSBtaXhlci5mb3JjZVJlbmRlci5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5pc01peGluZyAgICAgICAgICAgPSBtaXhlci5pc01peGluZy5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5nZXRPcGVyYXRpb24gICAgICAgPSBtaXhlci5nZXRPcGVyYXRpb24uYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnICAgICAgICAgID0gbWl4ZXIuZ2V0Q29uZmlnLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmdldFN0YXRlICAgICAgICAgICA9IG1peGVyLmdldFN0YXRlLmJpbmQobWl4ZXIpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0JywgYXJndW1lbnRzKTtcblxuICAgICAgICBoLmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkZhY2FkZSk7XG5cbiAgICBtaXhpdHVwLkZhY2FkZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5GYWNhZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5GYWNhZGU7XG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWl4aXR1cDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4aXR1cDtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lm1peGl0dXAgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cubWl4aXR1cCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cubWl4aXR1cCA9IG1peGl0dXA7XG4gICAgfVxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuY29uc3RydWN0b3IpO1xuXG4gICAgbWl4aXR1cC5OQU1FID0gJ21peGl0dXAnO1xuICAgIG1peGl0dXAuQ09SRV9WRVJTSU9OID0gJzMuMy4xJztcbn0pKHdpbmRvdyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///273\n")}}]);